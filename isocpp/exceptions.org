#+title: Static Exception Specifications
#+author: Lewis Baker <lewissbaker@gmail.com>

* Abstract

Exceptions are the C++ language's primary tool for communicating errors to callers.
However, the dynamic exceptions we have today come with runtime overheads that
cause many people to avoid using, or even completely disable exceptions in domains
that are performance-sensitive.

This leads to a variety of alternative error-signalling patterns being used in
code-bases, including ~std::error_code~ out-parameters, or ~std::optional~,
~std::variant~ and ~std::expected~ return-types. These alternatives have their
limitations, however. For example, they are difficult/impossible to apply to
constructors or overloaded operators, where we cannot change the return-type,
or add additional out-parameters.

Exceptions can also be problematic in embedded or safety-critical contexts, where
the use of ~noexcept~ in conjunction with exceptions can potentially insert hidden
calls to ~std::terminate()~, which is banned by some coding guidelines for
safety-critical systems, and that might only be discovered as reachable at runtime.

Both of these problems with exceptions can be somewhat traced back to the dynamic
nature of C++ exceptions.

This paper proposes introducing static exception specifications, repurposing the
~throw()~ specification syntax which was removed in C++17, to provide additional
type-information about the closed-set of possible exception types that might be
thrown from a function, while avoiding the shortcomings of the previous design of
throw-specifications.

Function definitions with a ~throw()~ specification are statically checked by the
compiler at compile-time to ensure that there are no code-paths that might allow
exceptions to exit the function that would violate the declared throw-specification,
rather than dynamically check this at runtime and terminate.

While we are yet to gain implementation experience for this proposal, the design
for static exception specifications should permit implementation strategies that
can achieve efficiency of throwing exceptions close to that of normal return values,
with exception objects able to be returned on the stack or in registers using
similar conventions to normal return-values.

This design is less limiting than the design proposed in [[https://wg21.link/P0709R4][P0709R4 - Zero-overhead deterministic exceptions: Throwing values]]
in that it does not require the introduction of a special ~std::error~ type and
does not require falling back to heap-allocation for exception types that do not
fit in the small-object optimisation built into ~std::error~.

This design does not change the semantics of existing C++20 code. It can be
incrementally adopted throughout a code-base by annotating functions with
static exception specifications using the ~throw()~ syntax where appropriate
in much the same way that programmers could incrementally adopt ~noexcept~
specifiers in their code-base when they were introduced.

This proposal aims to enable use of static exception specifications in freestanding
environments which were traditionally unable to use exceptions. The ability to enable
compile-time checking that all exceptions are handled and that there are no hidden
calls to ~std::terminate()~ inserted by the compiler due to unhandled exceptions
also removes some barriers to C++ exceptions being used in embedded environments
which cannot afford to terminate.

* Motivation

TODO: Basically see Herb's paper [[https://wg21.link/P0709][P0709]] for motivation on improving exceptions,
which does a better job than I could of covering the background. Much of the
same philosophy went into the design of this paper, albeit taking a slightly
different approach.

* Proposal

** Overview

The key components of this proposal are as follows:

It proposes (re)adding ~throw()~ specifiers which can be used to declare a function
as having either a static exception specifier or dynamic exception specifier.

It proposes adding the ~throw(auto)~ syntax for deducing the throw-specification of a
function from its definition, which must be visible before use of the function.

It proposes rules for statically checking at compile-time that the bodies of function
definitions with ~throw()~ specifiers do not violate their exception specification.

It proposes adding the ~declthrow(expr)~ syntax for querying what set of exception
types might be thrown from a particular exception.

It proposes adding the ~template catch~ syntax to allow catching static exceptions
thrown from the associated try-block, allowing a way to use the same handler template
to handle different types, without the need for type-erasing the exception.

It proposes limiting the scope of ~throw;~ statements within the dynamic scope
of the most-recently activated catch-block of a function definition that has a
throw-specification to the immediately lexical scope of the handler.
i.e. you can you only rethrow an exception from the body of the handler, not
from a from a function called by that handler.

** (Re)Adding ~throw()~ specifiers

The original design of exceptions in C++ included a throw-specification that allowed
the programmer to declare a list of exceptions that a function might exit with, by
specifying the ~throw(E1, E2, E3)~ specifier after the function parameter list.

For example:
#+begin_src c++
    void Example(const std::string_view& path)
      throw(std::bad_alloc, std::system_error);
#+end_src

The throw-specification as originally designed had a number of issues that limited
its usability and utility, and in time most people came to avoid the feature as its
pitfalls outweighed the benefits of using it.

TODO: Elaborate on what the issues were
- runtime/code-size overhead cost due to need to dynamically-check for unhandled exceptions
- ~std::unexpected()~ notification mechanism did not lend itself to recovery
- MSVC (at the time) did not enforce the contract - a function with a ~throw()~ specification
  could still throw exceptions of types other than those mentioned in the throw-specification,
  but the compiler would optimise based assumptions that it did not. Made it dangerous to use.

In C++11, we introduced ~noexcept~, initially as a tool needed to restore the strong exception-safety
guarantee to types like ~std::vector~ after the introduction of move-constructors.

The original throw-specifications were deprecated along with the introduction of ~noexcept~ and,
in C++17, were removed from the C++ language. This frees up the syntax for being reused for a similar
purpose, albeit with an improved design that tries to avoid the pitfalls of the original design.

** Static exception specifications

A /static exception specification/ is an exception specification that lists a finite
list of possible exception types that a function may exit with.

A /non-empty static exception specification/ is a static exception specification that contains
one or more exception types listed in the throw specification.

A /dynamic exception specification/ is an exception specification that allows the function
to exit with any exception type.

A /throw-specifier/ can be used to declare a function with either a static or dynamic exception specification.

For example:
#+BEGIN_SRC c++
  void f() throw();    // equivalent to noexcept(true)  - static-exception-specification with empty exception type list
  void g() throw(...); // equivalent to noexcept(false) - dynamic-exception-specification
  void g() throw(std::any_exception); // equivalent to throw(...) - see section on declthrow for rationale
  void h() throw(E1);     // throws only E1             - static-exception-specification
  void i() throw(E1, E2); // throws either E1 or E2
  void j() throw(Es...);  // throws one of the types in pack Es...
  void k() throw(auto);   // set of exceptions it could throw is deduced from body of function,
                          // much like using decltype(auto) to deduce the return-type.
#+END_SRC

A declaration signature of ~void foo() throw();~ is equivalent to ~void foo() noexcept;~.
However, a function definition with a ~throw()~ specification differs from one with ~noexcept~
in that the definition is ill-formed if an exception can possibly escape the function,
whereas ~void foo() noexcept~ detects such a failure to fulfil its contract at runtime and terminates.
i.e. throw-specifications are statically checked/enforced rather than dynamically checked/enforced.

Similarly, ~void bar() throw(E1, E2)~ is ill-formed if any exception types other than ~E1~ or ~E2~
can possibly escape the body of the function. The aim is to avoid the compiler inserting any hidden
calls to ~std::terminate~ in the body of the coroutine.

It is permitted to declare a function with the specifier ~noexcept(true)~ and define it with
the specifier ~throw()~, and vica versa. Doing so allows you to have the compiler statically
check that there are no unhandled exceptions exiting the function body that might implicitly
result in a call to ~std::terminate~.

Similarly, it is permitted to declare a function with the specifier ~noexcept(false)~ and define
it with the specifier ~throw(...)~, and vica versa. However, there are no differences in semantics
of the definition between these two syntaxes - they are pure aliases for each other.

A forward declaration of a function with a non-empty static exception specification on its
definition must have an equivalent static exception specification on the declaration.

*** Types in a throw-specification form an unordered set

The order of the types in the throw-specification is not significant. The throw-specification
declares an unordered set of types that may be thrown, rather than an ordered list of types.

Two throw-specifications are equivalent if they contain the same set of types, regardless
of the order in which those types are listed.

It is valid to list a type multiple times in a throw-specification.
Any duplicates are ignored/eliminated by the compiler.

Eliminating duplicates is helpful when composing lists of exception types
from multiple ~declthrow~ expressions that have overlap in the set of exceptions
they may throw - see the section "Querying the throw-specification".

For example, the following functions all have the same exception specification:
#+BEGIN_SRC c++
void f() throw(E1, E2);
void g() throw(E2, E1);
void h() throw(E1, E1, E2);
#+END_SRC

The rationale for making the set of exceptions an unordered set rather than an ordered list is
to reduce the chance of annoying incompatibilities when casting a function to a function-pointer.

For example:
#+begin_src c++
  // declared in lib1
  void f() throw(E1, E2);

  // declared in lib2
  void g() throw(E2, E1);


  void (*func)() throw(E1, E2) = &f;
  if (cond) {
    func = &g; // It would be annonying if this was ill-formed because the throw-specification had a different order.
  }
#+end_src

*** Handling of ~std::any_exception~ in the throw-specifier

The ~std::any_exception~ type is a type that is handled specially by throw specifications.
See the section "~declthrow~ of a ~throw(...)~ expression" below for a definition of this type.

If the list of types passed as arguments to the ~throw~ specifier contains the type
~std::any_exception~ then the overall exception-specification is evaluated to be
~throw(...)~. i.e. that it can throw any exception type.

For example:
#+begin_src c++
  void a() throw(std::any_exception);       // -> throw(...)
  void b() throw(A, B, std::any_exception); // -> throw(...)
#+end_src

The use of a type ~std::any_exception~ allows template metaprogramming libraries to be
able to conditionally compute a throw-specification that can evaluate as either a static exception specification
or a dynamic exception specification.

For example: Computing a throw-specification to either be ~throw(...)~ or
a static exception specification, depending on a template parameter.


#+begin_src c++
  template<typename... Ts>
  using ...type_list = Ts...; // P1858R2 pack alias syntax

  // Generic case
  template<typename T>
  struct _compute_foo_throw_types {
    using ...types = type_list<std::any_exception>...; // P1858R2 pack alias syntax
  };

  // When T satisfies the Foo concept, we know it will only
  // fail with two possible exceptions.
  template<typename T>
    requires Foo<T>
  struct _compute_foo_throw_types<T> {
    using ...types = type_list<FooError, std::bad_alloc>...;
  };

  template<typename T>
  void foo(const T& x) throw(_compute_foo_throw_types<T>::types...); // P1858R2 pack expansion syntax
#+end_src

Here, the function ~foo<T>~ has an exception specification that is either ~throw(FooError, std::bad_alloc)~ or ~throw(...)~,
depending on the type, ~T~.

*** The types in the throw specification describe all concrete types that may be thrown

One of the prime motivations behind re-adding throw-specifications is to provide the compiler
with enough static type information for it to be able to allocate storage for exceptions that
may be thrown on the stack of the caller, rather than the runtime having to dynamically-allocate
storage for them on the heap. It also allows the compiler to statically dispatch to the appropriate
handler for each possible exception that might be thrown, without requiring dynamic type-matching
or run-time type information.

For this to be possible, the compiler needs to know the size/alignment of all exception types so
that it can reserve storage in the stack-frame for any exception-types which cannot be passed
back to the caller in registers. Similarly, it needs to know which exception types may be passed
back in registers.

This means that we cannot just list an exception base-class in the throw-specification and then
leave the set of possible exception types open to include any type derived from that base-class,
as this would not allow callers to reserve space for any such exception on the stack-frame caller.

For example, a declaration with a throw-specification of ~throw(std::exception)~ does not declare
that the function may throw an exception derived from ~std::exception~, it instead states that
the function may throw an instance of ~std::exception~ (e.g. as if via ~throw std::exception{};~)
and does not exit with any other type of exception.

The implication of this restriction, however, is that any changes to the set of exception-types
that may be returned by a function is a potential ABI break for that function, requiring at a minimum,
recompilation of all callers of that function.

This is no different to changing the return-type of a function.
e.g. when adding a new entry to a ~std::variant~-returning function.

This places some interesting constraints on the evolution of such functions, which are discussed
in detail in a later section (TODO: Put link to other section).

*** Exception types may not be references, cv-qualified, or void

Types listed in the throw-specification may not be references, cv-qualified, or ~void~.

Static-exception types are returned by-value to callers, so it does not make sense to
support throw-specifications that are references or cv-qualified.

*** Static exception specifications are part of the function type

The throw-specification is part of the function type, much like ~noexcept~ specifier is
part of the function type.

In general, a function-pointer with a non-empty static-exception-specification cannot be cast to a
function-pointer type with a different exception-specification. This is because the calling-convention
between such functions may be different, as the list of exceptions that may be thrown forms part of the
ABI of such a function.

Note that it is possible to cast a function directly to a function-pointer type with a wider exception
specification than the function was declared with as the compiler is able to then generate
a thunk that can implement the ABI for the wider specification in terms of the function's native ABI.

Once the identity of the function has been erased as a function-pointer, it is no longer possible for
the compiler to know how to generate such a thunk.

For example:
#+BEGIN_SRC c++
  void f() throw();
  void g() throw(E1);
  void h() throw(E1, E2);
  void i() throw(...);

  void(*pf)() throw() = f; // OK
  pf = g; // ERROR - can't cast g() to a function-pointer with narrower throw-specification
  pf = h; // ERROR - can't cast h() to a function-pointer with narrower throw-specification
  pf = i; // ERROR - can't cast i() to a function-pointer with narrower throw-specification

  void(*pg)() throw(E1) = g; // OK
  pg = f; // OK - points either to f or to thunk that calls f
  pg = h; // ERROR - can't cast h() to a function-pointer with narrower throw-specification
  pg = i; // ERROR - can't cast i() to a function-pointer with narrower throw-specification

  void(*ph)() throw(E1, E2) = h; // OK
  ph = f;  // OK - ph points to f or to a thunk that calls f
  ph = g;  // OK - ph points to a thunk that calls g
  ph = i;  // ERROR - can't cast i() to function-pointer with narrower throw-specification

  void(*pi)() throw(...) = i; // OK
  pi = f; // OK - ph points to f (same as casting noexcept(true) function to noexcept(false) one)
  pi = g; // OK - ph points to a thunk that calls g and translates static-exceptions into dynamic-exceptions
  pi = h; // OK - ph points to a thunk that calls g and translates static-exceptions into dynamic-exceptions

  // The same casts are not all valid when casting function-pointers to other function-pointer types
  // instead of functions to function-pointer types.
  pf = pg; // ERROR: Can't function pointer with static throw specification to another function-pointer type
  pf = ph; // ERROR: (same)
  pf = pi; // ERROR: Can't cast throw(...) function-ptr to throw() function-ptr

  pg = pf; // MAYBE?: In some ABIs the calling convention may be compatible. Do we want to restrict the options here?
  pg = ph; // ERROR: Can't cross cast throw(E1, E2) function-ptr to throw(E1) function-ptr
  pg = pi; // ERROR: Can't cast to function-pointer with narrower throw-specification

  ph = pf; // MAYBE?: In some ABIs the calling convention may be compatible.
  ph = pg; // ERROR: Can't cast function-ptr with static exception specification to function-ptr with different static exception specification.
           // compiler is unable to generate the necessary thunk here.
  ph = pi; // ERROR: Can't cast to function-ptr with narrower throw-specification.

  pi = pf; // OK: this is same as casting function-ptr with noexcept(true) to function-ptr with noexcept(false)
  pi = pg; // ERROR: Can't cast function-ptr with static exception specification to function-ptr with different exception specification.
           // compiler is unable to generate the necessary thunk here.
  pi = ph; // ERROR: Can't cast function-ptr with static exception specification to function-ptr with different exception specification.
#+END_SRC

The existing type-conversions from pointers to a function with a ~noexcept(true)~ exception specification
to a pointer to a function with a ~noexcept(false)~ exception specification are unchanged.

*** Deducing throw-specifications from a function signature

It is permitted to allow template arguments to be deduced from the throw-specification
in a function-signature.

For example:
#+begin_src c++
  template<typename Ret, typename... Args, typename... Errors>
  void Call(Ret(*func_ptr)(Args...) throw(Errors...));

  void a() throw();
  void b() throw(int);
  void c() throw(std::bad_alloc, std::system_error);
  void d() throw(...);

  Call(&a); // deduces Errors to be the empty pack.
  Call(&b); // deduces Errors to be the pack: int
  Call(&c); // deduces Errors to be the pack: std::bad_alloc, std::system_error   (in some unspecified order)
  Call(&d); // deduces Errors to be the pack: std::any_exception
#+end_src

This is similar to the ability to deduce whether a function signature is ~noexcept~ or not.

*** ~throw(auto)~ - Deducing exception-specifications from the body of a function

Often, when writing forwarding functions, or function templates, you just want the function to be
transparent to exceptions. i.e. any unhandled exceptions should be propagated to the caller.

In these cases, ideally the function's exception-specification should mirror the set of
exceptions that the body of the function may throw.

With the current facilities available with ~noexcept~, this typically means that you need to
repeat every expression in the body of the function in the ~noexcept~ specifier for that function.

For simple functions this is manageable, although tedious. However, for more complicated function bodies,
or for function-bodies that include conditionally-executed logic guarded by an ~if constexpr~ branch,
the expression needed to compute the ~noexcept~ specifier argument quickly becomes unwieldy.

**** Prior work on deducing exception specifications

This usability issue was identified as a problem back when ~noexcept~ was originally proposed for C++11:
- [[https://wg21.link/N3227][N3227]] - Please reconsider ~noexcept~ (Ottosen, 2010)

There have since been multiple papers exploring the idea of deducing the exception-specification:
- [[https://wg21.link/N3202][N3202]] - To which extent can ~noexcept~ be deduced? (Stroustrup, 2010)
- [[https://wg21.link/N3207][N3207]] - ~noexcept(auto)~ (Merrill, 2010)
- [[https://wg21.link/N4473][N4473]] - ~noexcept(auto)~, again (Voutilainen, 2015)
- [[https://wg21.link/P0133R0][P0133R0]] - Putting ~noexcept(auto)~ on hold, again (Voutilainen, 2015)

It is worth noting that the rationale given in P0133R0 for putting on hold the pursuit of
~noexcept(auto)~ was mainly because it did not solve the whole problem of having to duplicate
the function-body in the declaration - the expressions of the body still needed to be duplicated
in the return-type for SFINAE purposes - and therefore it was not good use of committee time
to pursue a partial solution.

Since this paper was written, we have gained support for concepts in C++20, which goes someway
to simplifying the code needed to write function-templates that eliminates overloads with SFINAE.
However, this only applies when there are existing concepts defined that can be used to constrain
the function. For many cases you still need to duplicate the expressions of the function body
in a ~requires~ clause.

Despite this limitation, I feel there is still benefit to enabling deduced exception specifications
as there are often case that are either covered by concepts or that do not require SFINAE, but that
do need to compute accurate exception specifications.

**** ~throw(auto)~

With the (re)introduction of throw-specifications, the task of computing a correct throw-specification
from a set of sub-expressions becomes even more onerous than for ~noexcept~, as you need to compute
lists of types, not just a boolean expression.

This paper therefore proposes the addition of the ~throw(auto)~ specifier on a function declaration,
as a way of declaring that the compiler should compute the set of exception types that may exit the
function from the definition of the body of the function and use that as the exception-specification
for the function.

For example, consider a hypothetical ~for_each~ function that invokes a function for each
element of a range. If we wanted this function to have the same exception-specification as its
body, it would need to be written with ~noexcept~ specifiers, something similar to the following:
#+begin_src c++
  template<
    std::ranges::range Range,
    typename Func>
  requires std::invocable<Func&, std::ranges::range_reference_t<Range>>
  void for_each(Range&& range, Func&& func)
    noexcept(noexcept(std::ranges::begin(range)) &&
             noexcept(std::ranges::end(range)) &&
             noexcept(++std::declval<std::ranges::iterator_t<Range>&>()) &&
             noexcept(std::declval<std::ranges::iterator_t<Range>&>() != std::declval<std::ranges::sentinel_t<Range>&>()) &&
             noexcept(func(*std::declval<std::ranges::iterator_t<Range>&>()))) {
    auto iterEnd = std::ranges::end(range);
    auto iter = std::ranges::begin(range);
    while (iter != iterEnd) {
      func(*iter);
      ++iter;
    }
  }
#+end_src

And with the ~throw()~ specifier proposed by this paper, in conjunction with the ~declthrow()~ expression
(described in detail in the following section), we would need to write:
#+begin_src c++
  template<std::ranges::range Range, typename Func>
  requires std::invocable<Func&, std::ranges::range_reference_t<Range>>
  void for_each(Range&& range, Func&& func)
    throw(declthrow(std::ranges::begin(range))...,
          declthrow(std::ranges::end(range))...,
          declthrow(++std::declval<std::ranges::iterator_t<Range>&>())...,
          declthrow(std::declval<std::ranges::iterator_t<Range>&>() != std::declval<std::ranges::sentinel_t<Range>&>())...
          declthrow(func(*std::declval<std::ranges::iterator_t<Range>&>()))...)  {
    auto iterEnd = std::ranges::end(range);
    auto iter = std::ranges::begin(range);
    while (iter != iterEnd) {
      func(*iter);
      ++iter;
    }
  }
#+end_src

Having to repeat the body in a different way in the ~noexcept~ or ~throw~ specification like
this is tedious and error-prone. It can be easy to miss an expression, or to later modify the
body of the function and forget to update the throw-specification.

Instead, if we add support for ~throw(auto)~, then the function definition simply becomes:
#+begin_src c++
  template<std::ranges::range Range, typename Func>
  requires std::invocable<Func&, std::ranges::range_reference_t<Range>>
  void for_each(Range&& range, Func&& func) throw(auto) {
    auto iterEnd = std::ranges::end(range);
    auto iter = std::ranges::begin(range);
    while (iter != iterEnd) {
      func(*iter);
      ++iter;
    }
  }
#+end_src

This is much more concise, and is now impossible for the throw-specification to be
inconsistent with the function body.

This facility will greatly simplify the definition of function-templates, in particular the
function-templates that are defined as "expression-equivalent to" some expression.

*** Forward declarations of ~throw(auto)~ functions

The use of ~throw(auto)~ on a forward-declaration of the function requires that the definition
of the function is visible before the use of the function, in the same way that a function
declared with a deduced-return-type requires that the function definition is available before
it's ODR-used.

For example:
#+begin_src c++
  void example() throw(auto);

  void caller1() {
    example();  // ill-formed. cannot be ODR-used before the definition is seen
  }

  auto* example_ptr = &example; // ill-formed. Type of example() is not known until definition is seen.

  void caller2() throw(declthrow(example())...); // ill-formed. Cannot query the exception specification of example() before it's definition is seen.
  void caller3() noexcept(noexcept(example())); // ill-formed. For same reason.

  void example() throw(auto) {
    if (foo()) {
      do_thing1();
    } else {
      try {
        do_thing2();
      } catch (Thing2Failure) {
        do_backup_thing2();
      }
    }
  }

  // Now that the definition is visible and the exception-specification
  // can be deduced, the following things are well-formed.

  void caller4() throw(declthrow(example())...) { // OK
    example(); // OK
  }

  auto* example_ptr2 = &example; // OK
#+end_src

The restriction that the function definition with a deduced exception specification needs to be visible before
it can be used has implications for recursive functions, however.

*** Deduced exception-specifications and recursive functions

Supporting deduced exception-specifications for recursive functions is a challenge.

In theory we could define some language rules that would allow some kinds of recursive
functions to be able to deduce their exception-specification.

For example:
#+begin_src c++
  struct Tree {
    Tree* left;
    Tree* right;
    int value;
  };

  void process_value(int value) throw(InvalidValue);

  void process_tree(Tree& tree) throw(auto) {
    if (tree.left != nullptr)
      process_tree(*tree.left);

    process_value(tree.value); // recursive-call

    if (tree.right != nullptr)
      process_tree(*tree.right);
  }
#+end_src

In this case, the only call that is made that is not recursive is the call to ~process_value()~
which can throw ~InvalidValue~. Therefore, we could in theory deduce that the overall throw
specification is ~throw(InvalidValue)~.

However, it is relatively easy to construct examples where such rules would not work.

Consider:
#+begin_src c++
  void contradiction(int arg) throw(auto) {
    if constexpr (noexcept(contradiction(arg)) {
        throw X{};
    } else {
        if (arg > 0)
             return contradiction(arg - 1);
    }
  }
#+end_src

If the throw-specification is deduced to be ~throw()~ then it throws an exception,
otherwise if it is potentially throwing, it calls itself but no longer contains
any statements that might throw an exception except the call to itself, leading
to a contradiction.

The key feature of this example that makes it problematic is that it is attempting
to query the exception specification before the exception specification has been deduced.

There are also other cases that can directly or indirectly require the exception specification to be known.
Including:
- Calling the function within a ~try { ... } template catch (auto e) { ... }~ block.
  The template catch block needs to know the types that might be thrown in order to
  instantiate the catch-block with the correct types.
- Passing a pointer to the function to an algorithm.
  Constructing the function-pointer type to pass requires knowing the exception specification.
- Forming a call to the function as a sub-expression passed to ~declthrow()~.

There are also further challenges with defining mutually-recursive functions that both
have deduced exception specifications.

TODO: Add example here.

While we may be able to eventually define rules that may allow a subset of recursive
function use-cases to have deduced exception specifications, this seems like a relatively
niche case which can be left ill-formed for now.

*** Delayed computation of deduced throw specifications

The throw-specification of a function or function-template need only be computed when the
function is selected by overload resolution, or is otherwise ODR-used.

This allows the compiler to avoid instantiating function-templates that are part of an overload
set but that are never selected for overload resolution.

Taking the address of a function with a deduced throw-specification will also force the compiler
to compute the throw-specification.

*** Do we also need ~noexcept(auto)~?

We could also consider adding support for the ~noexcept(auto)~ syntax, in addition to ~throw(auto)~.

The primary semantic difference between these two would be that ~noexcept(auto)~ would only deduce
to either ~noexcept(true)~ or ~noexcept(false)~, (equivalent to ~throw()~ or ~throw(...)~, respectively),
whereas ~throw(auto)~ could also deduce to a non-empty static-exception-specification.

While, in most cases, it would be preferable to use ~throw(auto)~, as that allows the exception-specification
to deduce to the more-efficient static-exception-specification, where possible, there may be some scenarios
where deducing to either ~noexcept(true)~ or ~noexcept(false)~ could be preferable.

The one use-case I can think of is where you want to have the exception-specification deduce to a function
whose signature allows a pointer to that function to be assigned to a function-pointer variable that has a
~noexcept(false)~ exception-specification.

However, this use-case is somewhat tenuous as it would still be possible to directly cast any function
to a signature-compatible function-pointer with a ~noexcept(false)~ exception-specification, it's just
not possible to cast first to a function-pointer with a non-empty static exception specification and
then cast that function-pointer to a function-pointer with a ~noexcept(false)~ exception-specification.

For example:
#+begin_src c++
  void a() throw(A);
  void b() throw(B);

  void c() throw(auto) { // deduces to throw(A, B)
    a();
    b();
  }

  void d() noexcept(auto) { // deduces to noexcept(false)
    a();
    b();
  }

  void execute(void(*func)());

  void example() {
    auto* c_ptr = &c;
    execute(c_ptr); // ill-formed: no conversion from 'void(*)() throw(A,B)' to 'void(*)()'

    auto* d_ptr = &d;
    execute(d_ptr); // OK: 'void(*)() noexcept' implicitly convertible to 'void(*)()'.
  }

  void workaround() {
    execute(static_cast<void(*)()>(c)); // OK: explicit cast to noexcept(false) function-pointer from function
    execute(&d); // OK: Explicit cast not needed
  }
#+end_src

It is an open question whether adding support for ~noexcept(auto)~ in addition to ~throw(auto)~ is
worth the extra complexity/specification effort.

However, in the author's opinion, it is probably not necessary to add in the initial version.
It can be added later if usage experience shows that it would have sufficient value.

** Querying the throw-specification

Once we have the ability to specify static-exception-specifications on functions, there
will inevitably be cases where we want to be able to know what that set of exception
types is in library code.

This paper proposes adding ~declthrow(expr)~ syntax as a way of querying what the list of exceptions
that ~expr~ may exit with.

As the ~declthrow(expr)~ needs to be able to produce a list of types, it is proposed that this
form names a pack of types, which can be expanded as needed using ~declthrow(expr)...~.

Note that the pack of types produced by ~declthrow()~ does not contain any duplicate types.

One of the common expected use-cases is in computing a derived throw-specification
for a function composing other functions such that if their exception specifications change
then so does the exception specification of the function composing them.

For example:
#+begin_src c++
  // Header file
  void PartA() throw(OutOfWidgets);
  void PartB() throw(ProtocolError, Timeout);

  void ComposedOperation() throw(declthrow(PartA())...,
                                 declthrow(PartB())...);

  // ... out-of-line definition in .cpp file

  void ComposedOperation() throw(declthrow(PartA())...,
                                 declthrow(PartB())...) {
    PartA();
    PartB();
    try {
      PartC();
    } catch (...) {
      NothrowFallbackPart();
    }
  }
#+end_src

*** ~declthrow~ of a ~throw(...)~ expression

If the expression may exit with a dynamic-exception (i.e. one of the sub-expressions has an exception specification of ~noexcept(false)~ or ~throw(...)~)
then the result of this is an unspecified, compiler-generated type, much like ~decltype(nullptr)~.

An alias for this type is made available as ~std::any_exception~ in the header ~<exception>~.

#+name: <exception>
#+begin_src c++
  namespace std {
    // NOTE: using pack indexing syntax proposed in P2662R2
    using any_exception = declthrow(static_cast<void(*)()throw(...)>(nullptr)())...[0];
  }
#+end_src

The ~std::any_exception~ type is not constructible or usable as a value.
It is only intended for use as a placeholder/marker for throw-specifications to indicate
a dynamic exception specification.

*** Mixed dynamic and static exception specifications

When the operand to ~declthrow()~ contains multiple sub-expressions, some of which have
non-empty static exception specifications and some of which have dynamic exception specifications,
there is the question of what the result of the ~decthrow()~ expression should be.

For example:
#+begin_src c++
  // Given the following
  struct X;
  struct Y;
  int foo() throw(X, Y);
  void bar(int x) throw(...);

  // What types are in the following type-list?
  using types = type_list<declthrow(bar(foo()))...>;
#+end_src

There are two viable options to consider here:
- We say that the overall expression could emit any exception, so the deduced exception
  specification of a function containing this expression would be ~throw(...)~, and so
  the resulting type list should contain only ~std::any_exception~.
- We list the union of all of the types listed in static exception specifications and
  also list ~std::any_exception~ in the result.

This paper proposes to have the result include both ~std::any_exception~ and the types
from any static exception specifications, for the following reasons:
- It can be used to determine what types might be used to instantiate a ~template catch~
  block (see section on this below) associated with a try-block that contains this expression.
- It is not necessary to reduce the result to ~std::any_exception~ in the ~declthrow()~
  expression if it is being used as the argument to a ~throw~ specifier - the ~throw~
  specifier will do the reduction for you. Reducing the result early is just throwing away
  type information.

For example:
#+begin_src c++
  template<typename T, typename... Ts>
  concept one_of = (std::same_as<T, Ts> || ...);

  template<typename... Es>
  using err_variant = std::variant<std::monostate,
                                   std::conditional_t<std::same_as<std::any_exception, Es>,
                                                      std::exception_ptr, Es>...>;

  err_variant<declthrow(do_foo())...> error;
  try {
    do_foo();
  } template catch (auto e) {
    error.emplace<decltype(e)>(std::move(e));
  } catch (...) {
    if constexpr (one_of<std::any_exception, declthrow(do_foo())...>) {
      error.emplace<std::exception_ptr>(std::current_exception());
    }
  }
#+end_src

*** Order of the exception types

In the section on throw-specifications above it noted that the order of types listed in the throw
specification was not significant, and that the types in the throw-specification formed an
unordered set for the purposes of function-type-equivalence.

However, when querying the types in the throw-specification, we need to return the types in /some/
order, and so we need to specify what the constraints of that order are.

At the very least, the order of the types returned needs to be deterministic and consistent across
different queries of the same expression, across all translation-units. This is because code may
compute types that have different layouts or ABIs based on the order of the types produced by the
~declthrow~ expression, and having the same computation produce the results in different orders
is a sure-fire way to introduce ODR-violations.

There are a few other questions around the ordering of the exception types:
- Should the order be some partial-ordering of all types?
  i.e. if ~E1~ appears before ~E2~ in some ~declthrow()~ query, then ~E1~ appears before ~E2~ in /all/ ~declthrow()~ queries.
  - This would effectively provide a built-in facility for sorting types in type-lists.
- Should the order be specified by the standard? or should it be unspecified/implementation-defined?
  - It might be difficult to specify an ordering of all types in a portable way.
  - Doing so may improve portability/compatibility of code across compilers.
  - Standard library implementations do not necessarily define all types with portable canonical names.
    e.g. some implementations place some ~std::~ library types inside inline ABI-version namespaces, which would give those
    types different names to the same types defined in other standard library implementations.
    This would negate some of the portability benefit.
- Should the order of the exceptions be consistent with the order of exception types
  deduced by querying the type of a function and deducing the types listed in the throw-specification?
  #+begin_src c++
    // Given the following.
    void foo() throw(A, B);

    template<typename T>
    struct throw_specifier;

    template<typename Ret, typename... Args, typename... Es>
    struct throw_specifier<Ret(Args...) throw(Es...)> {
      using ...types = Es...;
    };

    template<typename... Ts>
    struct type_list {};

    // Should the following static_assert be guaranteed to hold on all conforming implementations?
    static_assert(std::same_as<type_list<declthrow(foo())...>,
                               type_list<throw_specifier<decltype(foo())>::types...>>);
  #+end_src
- Should the ~std::any_exception~ type appear in a specific location within the types returned
  by ~declthrow()~ if it is present? e.g. as the first or last type in the pack.
  - This might make it easier/more compile-time efficient to write metafunctions that want to
    detect whether there is a dynamic exception that may be thrown.
    e.g.
    #+begin_src c++
      // If std::any_exception is always first type
      template<typename... Es>
      concept DynamicException = sizeof...(Es) > 0 && std::same_as<std::any_exception, Es...[0]>; // P2662R2 pack indexing

      // vs

      // If std::any_exception could appear anywhere
      template<typename... Es>
      concept DynamicException = (std::same_as<std::any_exception, Es> || ...);
    #+end_src
- Do exception types need to be complete when used in throw specifications and
  subsequently queried via ~declthrow()~?
  - This may be somewhat limiting.
  - It would open the possibility of sorting types based on their ABI properties like size/trivial-copyability, etc.
    e.g. so that all error-types that might be returned by register appear earlier in the list
  - The exception types need to be complete anyway when a function that might throw them is invoked, just like
    the return-type needs to be complete.
  - The syntax proposed below for filtering exception types would need the exception types
    to be complete so that it can determine whether they would match a given ~catch~ handler.
    
Implementations may choose to sort exception types in the throw-specification by their mangled names,
or by their fully-scoped names.

It would not be appropriate for an implementation to sort them based on some non-stable attribute (like the
address of the 'Type' object representing that type in the compiler) which may change with different compilation runs.

*** Exception specifications of defaulted special member functions

See [dcl.fct.def.default].

The following functions may have defaulted definitions
- special member functions
  - default ctor
  - move ctor
  - copy ctor
  - move assignment
  - copy assignment
  - destructor
- comparison operators
  - equality
  - three-way-comparison

- implicitly defaulted functions have an implicit exception specification
- explicitly defaulted functions which are defaulted on first declaration have an implicit exception specification
  if they don't explicitly specify an exception specification.
- explicitly defaulted functions which are defaulted on first declaration that have an explicit exception specification
  use that explicit exception specification.

This paper proposes changing the implicit exception specifications of defaulted functions
to be equivalent to a throw-specification of ~throw(auto)~.

This should have no semantic effect on existing types / existing programs as
all existing types will have either a ~noexcept(true)~ or ~noexcept(false)~
member function and thus the deduced exception specification will either
deduce to ~noexcept(false)~ or ~noexcept(true)~. The rules for deduction of
the exception specification via ~throw(auto)~ are consistent with the pre-existing
rules of deduction for defaulted member functions.

However, it would ideally have an effect on types that compose new types that
are defined with static exception specifications for these special
member functions.

For example: Defining a struct that composes two types with static exception
specifications on their special member functions.
#+begin_src c++
  struct A {
    A() throw(std::bad_alloc);
    A(const A&) throw(std::bad_alloc);
    A(A&&) throw();
    ~A();
  };

  struct B {
    B() throw(std::system_error);
    B(const B&) throw(std::system_error);
    B(B&&) throw();
    ~B();
  };

  struct C {
    A a;
    B b;

    // C has implicitly defaulted special member functions.
  };

  template<typename... Ts>
  struct type_list;

  template<typename Func>
  struct throw_specification;

  template<typename Ret, typename... Args, typename... Es>
  struct throw_specification<Ret(Args...) throw(Es...)> {
    using types = type_list<Es...>;
  };

  // Sorts the list of types in the canonical order for a throw-specification
  template<typename... Ts>
  using throw_specification_t = typename throw_specification<void() throw(Ts...)>::types;

  // The following static_asserts will always pass for conforming implementations.
  
  static_assert(std::same_as<throw_specification_t<declthrow(C{})...>,
                             throw_specification_t<std::bad_alloc, std::system_error>>);
  static_assert(std::same_as<throw_specification_t<declthrow(C{std::declval<const C&>()})...>,
                             throw_specification_t<std::bad_alloc, std::system_error>>);
  static_assert(std::is_nothrow_move_constructible_v<C>);
#+end_src

It would also be ideal if the same approach could be applied to special member
functions of certain standard library types.

For example: Constructing a ~std::tuple~ of types with default-constructors with
static exception specifications would ideally result in the ~std::tuple~ type
having a static exception specification.
#+begin_src c++
  // Ideally the following would hold true for all implementations.
  // i.e. the throw-specification of the default constructor of std::tuple is the union
  // of the throw-specifications for all of the tuple member default constructors.
  static_assert(std::same_as<throw_specification_t<declthrow(std::tuple<A, B>{})...>,
                             throw_specification_t<std::bad_alloc, std::system_error>>);
#+end_src

It's worth noting that, as currently specified, the default constructor of ~std::pair~ or
~std::tuple~ is not required to be declared ~noexcept~ if all of its member default constructors are
declared ~noexcept~, so making this work would require a change to the exception-specification of
the default constructors.

The copy/move constructors are, however, declared as either implicitly or explicitly defaulted,
which therefore implies that the exception specification for these functions is deduced from the
exception specifications of the members.

A more in-depth analysis of standard library types is required to determine where this kind
of defaulting exception specifications can be applied.

*** Introducing a pack outside of a template

The introduction of a ~declthrow(expr)~ syntax that can introduce a pack of types at an arbitrary
point within the program.

It may be problematic for some compilers to support arbitrary use of anonymous packs outside
of templates.

If this is a restriction we want to maintain in the language, then it's possible we can
restrict, for now, the ~declthrow(expr)~ syntax to having to be immediately expanded in-place
to the list of types. i.e. ~declthrow(expr)~ must be immediately followed by a ~...~ to
expand the pack.

While this would be somewhat restrictive, it would still allow some basic common usage
within ~throw()~ specifiers, and can be used to expand into the template arguments of
variadic class templates, or concepts.

For example:
#+begin_src c++
    template<typename... Ts> class type_list {};

    // Can pass the result as template arguments to a class-template.
    using error_types = type_list<declthrow(foo(a,b,c))...>;

    template<typename T, typename... Ts>
    concept one_of = (std::same_as<T, Ts> || ...);

    // Can pass the result as template-arguments to a concept.
    constexpr bool throws_bad_alloc =
       one_of<std::bad_alloc, declthrow(foo(a,b,c))...>;

    // Can use it to compute the type of a variant that can hold all
    // possible exception types that might be thrown.
    std::variant<std::monostate, declthrow(foo(a,b,c))...> error;
    try {
        foo(a,b,c);
    } template catch (auto e) {
      error.template emplace<decltype(e)>(std::move(e));
    }

    // Can use it in the throw-specification of a function that wants to transparently
    // throw whatever exceptions foo() throws, plus errors that it throws itself.
    void example(int a, int b, int c) throw(std::system_error, declthrow(foo(a,b,c))...);
#+end_src

However, it wouldn't be able to support things like the following:
#+begin_src c++
  void foo() throw(A, B);

  template<typename Nested>
  struct BarError {
    Nested nested;
  };

  void bar(int count) throw(BarError<declthrow(foo())>...) {
    try {
      for (int i = 0; i < count; ++i) { 
        foo();
      }
    } template catch(auto e) {
      throw BarError<decltype(e)>{std::move(e)};
    }
  }

#+end_src

As that requires using the pack in way that is not immediately expanding the pack.

Further, if we do not have the ability to generate a pack in a non-template then we
will not be able to take a type-list computed by some meta-programming and then expand
that type-list into elements of the ~throw()~ specification.

#+begin_src c++
  template<typename... Ts>
  struct compute_new_exception_types {
    using type = type_list< /* template magic goes here */>;
  };

  template<typename T>
  void algorithm(const T& obj)
     throw(typename compute_new_exception_types<
             declthrow((obj.foo(), obj.bar()))...>::type /* how to expand this to a pack here? */);

#+end_src

While additional workarounds could be added to the ~throw()~ specification to make this
work, I think doing this would needlessly complicate the design. I am hopeful that we
can instead make progress on improving general pack-manipulation facilites to make
some of these cases possible. See P1858R2, P2632R0.

*** Packs of ~declthrow~ packs

One common use-case of ~declthrow~ is to compute throw-specifications for other functions.

For example, say we have a user pass an invocable that we will call with elements of a span,
the ~throw()~ specification might be defined as follows:
#+begin_src c++
  template<typename T, typename Func>
      requires std::invocable<Func&, T&>
  void for_each(std::span<T> values, Func&& func) throw(declthrow(func(std::declval<T&>()))...);
#+end_src

However, if we were to, say, try to do something similar with a ~std::tuple~, where the function
may be evaluated with multiple different argument types, each argument type represented by a
pack element, then the throw-specification effectively needs to become a concatenation of the
~declthrow~ packs, one pack for each element of the tuple.

Ideally we'd be able to write something like the following:
#+begin_src c++
  template<typename... Ts, typename Func>
      requires (std::invocable<Func&, Ts> && ...)
  void for_each(std::tuple<Ts...>& values, Func&& func) throw(declthrow(func(std::declval<Ts&>()))... ...);
#+end_src

However, there are known issues with expanding a pack of packs (see P2632R0 - section "Single level of packness").

As a workaround, we could instead write this with a single ~declthrow~ expression that
contains a compound expression using ~operator,~.
For example:
#+begin_src c++
  template<typename... Ts, typename Func>
      requires (std::invocable<Func&, Ts> && ...)
  void for_each(std::tuple<Ts...>& values, Func&& func) throw(declthrow((func(std::declval<Ts&>()), ...))...);
#+end_src

This way the ~Ts~ pack is expanded inside the argument to ~declthrow~ and it is no longer problematic
expanding the ~declthrow~ expression.

The other alternative for function templates / inline functions that wish to be transparent in the set
of exceptions they may throw is to just use ~throw(auto)~ to deduce the throw-specification
from the body, rather than having to duplicate the relevant parts of the body in the ~throw()~-specification.

*** Availability of the ~declthrow~ keyword

A search of GitHub public repositories yielded no direct matches for the identifier ~declthrow~,
although it is worth noting that it did yield instances of a macro named ~DECLTHROW(X)~ which
was used to conditionally define throw-specifications if available in the target C++ language/compiler.

A search of https://codesearch.isocpp.org/ yielded no matches for ~declthrow~.

*** Alternative Syntaxes Considered

Another alternative syntax considered was the reuse of the ~throw~ keyword in a
~throw...(expr)~ that would expand to the pack of types that could potentially be
thrown by that expression.

However, this syntax would have a potential inconsistency with ~sizeof...(pack)~
which takes an unexpanded pack and returns a single value. Whereas ~throw...(expr)~
needs to take a single expression and produce a pack.

The ~declthrow~ keyword also has the benefit of association/similarity with ~decltype~ which is
used to query the value-type of an expression.

*** Filtering the set of exceptions

Sometimes we want to build a throw-specification that indicates that we throw any exception
that some other expression throws, but that we handle some number of errors within the function
and so we want to exclude those from the list. This way if the exception-specification of the
other expression changes, then the expression-specification of our function changes to
include the new set of exceptions.

While this could, in theory, be done with some template metaprogramming on packs, which would
become possible with the introduction of more pack-manipulation facilites described in P2632R0,
the resulting code is still onerous, and compile-time expensive compared to not filtering
the exceptions.

For example: Using P1858R2 generalized pack facilities, we can define a helper ~filter_exceptions~
#+begin_src c++
  template<typename HandledType, typename ErrorType>
  concept handler_for = std::same_as<HandledType, std::any_exception> ||
                        (std::derived_from<ErrorType, HandledType> &&
                         std::convertible_to<ErrorType, HandledType>);

  template<typename... Ts>
  struct type_list {};

  template<typename... Ts>
  struct std::tuple_size<type_list<Ts...>>
    : std::integral_constant<std::size_t, sizeof...(Ts)> {};

  template<std::size_t Idx, typename... Ts>
  struct std::tuple_element<Idx, type_list<Ts...>> { using type = Ts...[Idx]; };

  template<typename... Lists>
  struct concat_type_lists;

  template<typename A>
  struct concat_type_lists<A> {
    using type = A;
  };
  template<typename A, typename B, typename... Rest>
  struct concat_type_lists<A, B, Rest...>
    : concat_type_lists<type_list<A::[:]..., B::[:]...>, Rest...>
  {};

  template<typename HandledType, typename ErrorType>
  struct filter_exception {
    using type = type_list<ErrorType>;
  };
  template<typename HandledType, typename ErrorType>
  requires handler_for<HandledType, ErrorType>
  struct filter_exception<HandledType, ErrorType> {
    using type = type_list<>;
  };

  template<typename HandledType, typename... Errors>
  using ...filter_exceptions = concat_type_lists<typename filter_exception<HandledType, Errors>::type...>::type::[:]...;
#+end_src

Which could then be used as follows:
#+begin_src c++
  void example() throw(filter_exceptions<CaughtException, declthrow(some_expression)...>...);
#+end_src

One alternative would be to add a syntax that allowed the programmer to describe the intent
to filter the exception list directly in the language.

A strawman syntax for this could be to allow additional arguments to ~declthrow()~ to list types
to exclude from the list of types. i.e. ~declthrow(expr, filter-clauses...)~

For example: We could add additional ~catch(type)~ arguments after the first argument to ~declthrow()~
to list exception types from the expression that are caught and thus should be removed from the list.
#+BEGIN_SRC c++
  // Given.
  struct A : std::exception {};
  struct FooError : std::exception {};
  struct B : FooError {};
  struct C : FooError {};

  void foo() throw(A, B, C);

  void example1() throw(declthrow(foo())...);                        // -> throw(A, B, C)
  void example2() throw(declthrow(foo(), catch(A))...);              // -> throw(B, C)
  void example3() throw(declthrow(foo(), catch(A), catch(B))...);    // -> throw(C)
  void example4() throw(declthrow(foo(), catch(FooError))...);       // -> throw(A)
  void example5() throw(declthrow(foo(), catch(std::exception))...); // -> throw()
#+END_SRC

Note that listing the ~catch(FooError)~ base class removes both derived types from the list.

Despite the potential syntactic and compile-time benefits that might arise from adding such a syntax,
it's not clear whether the added complexity is worthwhile at this point. Usage experience is needed
to better understand how often such a feature would be needed.

For a lot of these cases, it is expected that the ~throw(auto)~ syntax will serve most of the
needs in this direction, and assuming that more generalised pack facilities become available,
users that really need to do such filtering would still be able to do this in library.

If we can specify the syntax of ~declthrow~ such that it reserves the right to be extended
in some way such that this capability could be added later, then we can take a wait-and-see
approach.

** Checked Exceptions

A function declaration that includes a /static-exception-specification/ must have a definition that
ensures that only exceptions of those types may exit the function.

To assist with this, the compiler looks at the exception-specifications of all expressions
within the body of the function and computes the set of possible exception types that could
potentially exit the current function. If this set of possible exception types is not a
subset of the set of exception types listed in the exception-specifications then the
program is ill-formed.

*** Computing the set of exception-types

When computing the set of exception types that might exit an expression, statement or function,
we idealy want a set of rules that can be reliably evaluated in a consistent way across all
conforming implementations, and that is not dependent on inlining, or compiler optimisations.
This is because the computation can be important for correctness and well-formedness of a program,
and can also affect the ABI of functions with deduced throw specifications.

The following algorithm describes such a set of rules for computing the
set of potentially-thrown-exception-types for each grammar term that
may appear within a /function-body/.

The descriptions here are not as precise as they would need to be for wording, but are hopefully
descriptive enough to understand the proposed semantics.

**** /function-body/ 

Let /A/ be the set of potentially-thrown exception types for the function body's
/compound-statement/.

If the function is for a constructor, then let /B/ be the set of potentially-thrown
exception types of the function call expressions of the constructors of the base-classes
and non-static data-members, otherwise let /B/ be the empty set.

Let /C/ be the union of the sets /A/ and /B/.

If the /function-body/ has a /function-try-block/, then;
- let /D/ be the subset of types in /C/ that would be caught by the handlers of the /function-try-block/.
  (see the /try-block/ description for more details about this); and
- for each potentially reachable handler, /Hi/, of the try-block, let /Ei/ be the set of potentially-thrown
  exception types corresponding to the /compound-statement/ of that handler.

Then the set of potentially-thrown exception types of the /function-body/ is the set
of types described by (/C/ - /D/)  /Ei/...

TODO: Talk about coroutines where execution may flow off the end of the function-body.
These need to consider the implicit ~co_return;~ statement at the closing curly-brace
of the function-body.

**** /compound-statement/

The set of potentially thrown exception types for a /compound-statement/ is the union of
the set of potentially-thrown exception types for each of the /statement/s in the
/statement-seq/ of the /compound-statement/.

Note that we do not attempt to do analysis of control-flow to eliminate exceptions that might
be thrown from unreachable statements in a /statement-seq/. e.g. ignoring a statement because a
preceding statement branched unconditionally to some other code-path via ~return~, ~break~,
~continue~, ~goto~, ~throw~ or calling a ~[[noreturn]]~ function.

For example: Assuming the following declarations:
#+begin_src c++
  void foo() throw(A);
  void bar() throw(B, C);
  void baz() throw(D);
#+end_src

The set of potentially-thrown-exceptions from the following compound-statement is still { ~A~, ~B~, ~C~, ~D~ }
#+begin_src c++
  {
    foo(); // might throw A
    goto label;
    bar(); // might throw B or C (note this is unreachable)
  label:
    baz(); // might throw D
  }
#+end_src

While this will be overly conservative in computing the set of potentially-thrown exception types for some
cases, it avoids some complications which make specifying more accurate behaviour difficult.

For example, let's say we wanted to avoid including any statements that appear after a statement that
unconditionally branches to some other location via some form of control-flow.
1. We'd first have to reliably define what statements/expressions contain unconditional branches.
2. We'd then need to consider all statements in a compound-statement after a statement with an
   unconditional branch as unreachable.
3. However, we also need to consider labels on some of those statements that might be jump targets
   for ~goto~ statements. So any statement in a compound-statement after a label is potentially
   reachable again (until the next unconditional branch statement).
4. Then there is the question of reachability of those labels.
   - What if there are no ~goto~ statements within the function that target that label?
     Should we still consider the label reachable?
   - What if there is a ~goto~ statement that targets the label, but the ~goto~ statement is not reachable
     because it has a preceding unconditional-branch statement?
   
This is a slippery slope that is difficult in general to analyze reliably.

It might be possible to specify this in some way at some stage in the future,
but for now this paper does not propose to exclude statements that occur
after some unconditional branching as

**** /statement/

A statement is one of the following cases:
- /expression-statement/ - Has the same set of potentially-thrown exception types as the contained /expression/.
- /compound-statement/ - Already handled above
- /selection-statement/
- /iteration-statement/
- /jump-statement/
- /declaration-statement/
- /try-block/

See the relevant section for a description of each.

**** /selection-statement/

Selection statements include both ~if~, ~if constexpr~, ~if consteval~ and ~switch~ statements.

***** ~if~ statements

The set of potentially-thrown exception types of an ~if~ statement is the
union of the exception types of the:
- /init-statement/ - if present
- /condition/
- /statement/ - the first substatement
- /statement/ - the second substatement (if the ~else~ part is present)

***** ~if constexpr~ statements

As the condition of a constexpr if statement is evaluated as part of constant evaluation
and constant evaluation is not permitted to throw exceptions, /condition/ part does not
contribute to the set of potentially-thrown exception types.

If the /selection-statement/ contains an /init-statement/ part, then let /I/ be
the set of potentially-thrown exception types of the /init-statement/,
otherwise let /I/ be the empty set.

If the value of the converted /condition/ expression is ~true~ then then set of
potentially-thrown exception types of the /selection-statement/ is the union of
/I/ and the set of potentially-thrown exception types of the the first substatement.
i.e. the body of the ~if~ /statement/.

Otherwise, if the ~else~ part of the selection statement is present, then the
set of potentially-thrown exception types of the /selection-statement/ is the union of
/I/ and the set of potentially-thrown exception types of the second substatement.
i.e. the body of the ~else~ /statement/.

Otherwise, the set of potentially-thrown exception types of the /selection-statement/
is /I/.

***** ~if consteval~

An if statement of the form ~if consteval /compound-statement/~ has a set of
potentially-thrown exception types that is the empty set.

Note that the /compound-statement/ is manifestly constant-evaluated and so is
not permitted to throw exceptions. Therefore it does not contribute to the
set of potentially-thrown exception types.

An if statement of the form ~if !consteval /compound-statement/~ has a set of
potentially-thrown exception types that is equal to the set of potentially thrown
exception types of the first substatement.

An if statement of the form ~if consteval /compound-statement/ else /statement/~ has
a set of potentially-thrown exception types that is equal to the set of potentially
thrown exception types of the second substatement.

An if statement of the form ~if ! consteval /compound-statement/ else /statement/~
has a set of potentially-thrown exception types that is equal to the set of potentially
thrown exception types of the first substatement.

***** ~switch~

A switch statement of the form ~switch ( /init-statement/ /condition/ ) /statement/~
or ~switch ( /condition/ ) /statement/~
has a set of potentially thrown exception-types equal to union of the sets of potentially
thrown exception types of the following parts:
- /init-statement/ (if present)
- /condition/
- /statement/

**** /init-statement/

An init-statement is either a:
- /expression-statement/ - Expression statements are already described above.
- /simple-declaration/ 
- /alias-declaration/ - These do not contain any executable code and thus do not contribute to the set of potentially-throw exception types.


If the statement is a /simple-declaration/ that is an object declaration,
the set of potentially-thrown exception types of that statement is the union
of the sets of potentially-thrown exception types of the /initializer/ expression,
the function call expression of the objects selected constructor and the
function call expression of the object's destructor.

**** /iteration-statement/

The following kinds of iteration-statement are possible:
- ~while (~ /condition/ ~)~ /statement/
- ~do~ /statement/ ~while (~ /expression/ ~) ;~
- ~for (~ /init-statement/ /condition/ ~;~ /expression/ ~)~ /statement/
- ~for (~ /init-statement/ /for-range-declaration/ ~:~ /for-range-initializer/ ~)~ /statement/

For all of these forms of iteration statement, the set of potentially-thrown exception types
of the iteration statement is the union of the sets of potentially-thrown exception types
from each of the relevant subexpressions or substatements:
- /condition/
- /statement/
- /expression/
- /init-statement/
- /for-range-declaration/
- /for-range-initiailizer/

Note that this includes exceptions that may be thrown from the body of the iteration statement,
even if the statement's /condition/ is such that the body will never be executed.

**** /jump-statement/

Jump statements include:
- ~break;~
- ~continue;~
- ~return~ /expr-or-braced-init-list/ ~;~
- /coroutine-return-statement/
- ~goto~ /identifier/ ~;~

Only the ~return~ and ~co_return~ statements can potentially affect the set of potentially-thrown
exception types here. The others are just pure control flow, and while they can potentially trigger
exceptions to be thrown when exiting scopes via that control-flow (if destructors are potentially-throwing),
those exceptions should be covered by the declaration statement for that variable.

***** ~return~ statements

A ~return~ statement has a set of potentially-thrown exception types equal to the
union of the set of potentially-thrown exception types of the operand expression,
and the set of potentially-thrown exception types from any implicit conversion
or constructor call required to initialize the return-value.

Note that there is an edge-case here that needs to be considered, where the operand
to the return statement is a prvalue which is returned with guaranteed copy-elision
and where the object has a potentially-throwing destructor. Normally, an expression
that creates a pr-value includes the potentially-throwing types of both the call to
the constructor, and the call to the destructor, as a statement containing that
expression will also call the destructor at the end of the full-expression.
However, for a return-value that is initialized with guaranteed copy-elision, the
destructor will be invoked by the caller of the function, rather than the local
function, and so the exception-specification of the return-value type should not
included in the calculation of the set of potentially-thrown exception types for
the return statement.

For example:
#+begin_src c++
  struct Foo {
    Foo() throw(A);
    Foo(Foo&&) throw(B);
    ~Foo() throw(C);
  };

  Foo f() throw(auto) { // deduces to throw(A)
    return Foo{}; // constructor called here but not destructor
  }

  Foo g() throw(auto) { // deduces to throw(A, B, C)
    Foo f; // declaration statement potentially throws A (from constructor) and C (from destructor)
    return f; // move-constructor potentially called here, even if copy is elided due to NRVO
  }
#+end_src

We also need to consider the case where the returned object is initialized using aggregate
initialization, where there may be a whole tree of sub-expressions that potentially initialize
sub-objects of the returned object.

Any expression in such a return-statement that directly initializes an object or sub-object of
the return-value that will be destroyed by the caller should not consider the exception-specification
of that sub-object's type's destructor when computing the set of potentially-thrown exceptions of
the ~return~ statement.

Note that, while it may be possible that the return-statement may execute the destructor of some
of these sub-objects in the case that initialization of a subsequent sub-object exits with an
exception, we do not need to consider this case for the purposes of computing the potentially-thrown
exceptions as these destructors will only be called in case there is an unwind due to another
exception - if these destructors then throw their own exceptions during unwind then this results
in an immediate call to ~std::terminate~.

***** ~co_return~ statements

A ~co_return~ statement of the form ~co_return;~ has a set of potentially-thrown exception types
equal to the set of potentially-thown exception types of the statement ~promise.return_void();~,
where /promise/ is the current coroutine's promise object.

A ~co_return~ statement of the form ~co_return~ /expr/ ~;~, where /expr/ has type ~void~ has
a set of potentially-thrown exception types equal to the union of the set of potentially-thrown
exception types of /expr/ and the set of potentially-thrown exception types of the statement
~promise.return_void()~, where /promise/ is the current coroutine's promise object.

A ~co_return~ statement of the form ~co_return~ /expr-braced-init-list/ ~;~, where the operand
is either an /expression/ of non-~void~ type or is a /braced-init-list/, has a set of potentially-thrown
exception types equal to the set of potentially thrown exception types of the statement
~promise.return_value(~ /expr-or-braced-init-list/ ~);~.

**** /declaration-statement/

A declaration statement consists of a /block-declaration/, which in turn consists of one of the following:
- /simple-declaration/
- /asm-declaration/
- /namespace-alias-definition/
- /using-declaration/
- /using-enum-declaration/
- /using-directive/
- /static_assert-declaration/
- /alias-declaration/
- /opaque-enum-declaration/
 
Other than the first to cases, the rest of the declarations do not introduce any executable code that
might throw exceptions.

Note that, while the /static_assert-declaration/ has a child expression, this expression is evaluated
as a manifestly constant expression, and therefore cannot throw an exception.

***** /simple-declaration/

A declaration statement that declares one or more block variables with automatic storage duration
has a set of potentially-thrown exception types equal to union of the sets of potentially
thrown exception types of any /initializer/ expressions and any calls to constructors or
conversion operators required to initialize the local variables, and any potentially thrown
exception types of calls to the destructors of the declared variables.

A declaration statement that declares one or more block variables with either static storage duration
or thread storage duration has a set of potentially-thrown exception types equal to the union
of the sets of potentiall thrown exception types of any /initializer/ expressions and any calls
to constructors of conversion operators required to initialize the local variables, but does _not_
include exception types of calls to the destructors of the declared variables.

We do not include the exceptions thrown by destructors of static/thread_local variables because
these destructors are not called from within the scope of a function that initializes these
variables.

Q. Initialization of variables with static storage duration needs to perform synchronization
in multi-threaded environments in order to guard against data-races initializing the
variable. Is it possible that operations on the synchronization primitives might fail with an
implementation-defined or unspecified exception (in which case we would need to include this
in the set of exception types) or can we assume that the synchronization will always succeed?

A declaration statement that declares a constant expression (i.e. is declared with the ~constexpr~
specifier) has an empty set of potentially-thrown exception types.

***** /asm-declaration/

The /asm-declaration/ has implementation defined behaviour and, while in theory, on some implementations,
an assembly declaration might be able to throw an exception, we cannot, in general, deduce anything about
the set of exception types that might be thrown in a portable way.

There are three possible options we take here:
- the /asm-declaration/ has implementation-defined behaviour, so the set of potentially-thrown exceptions
  from such a declaration should be implementation-defined.
- the /asm-declaration/ could potentially do anything (invoke a potentially-throwing function,
  implement some exception-throwing mechanics, etc.) so we should treat this as potentially throwing
  any type of exception.
- the vast majority of /asm-declaration/ usage is for implementing optimized, inline
- we could make it ill-formed to use an /asm-declaration/ in any context in which the
  exception-specification needs to be deduced.
  
This paper suggests treating an /asm-declaration/ statement as having an implementation-defined
set of potentially-thrown exceptions as this at least allows the possibility of the implementation
being able to analyse a declaration and deduce what exceptions might be thrown in an implementation-specific
way.

However, it would be worth a more detailed discussion within the Evolution sub-group about
what the desired semantics are here.

**** /try-block/

A /try-block/ statement has the form ~try~ /compound-statement/ followed by one or more
handlers of the form ~catch (~ /exception-declaration/ ~)~ /compound-statement/.

In addition, a /function-try-block/ statement for a constructor can also have the form
~try~ /ctor-initializer/ /compound-statement/ followed by one or more handlers of the
form ~catch (~ /exception-declaration/ ~)~ /compound-statement/.

Let /A/ be the set of potentially-thrown exception types of the try block's /compound-statement/.

If this is a function try block for a constructor then let /B/ be the union of /A/ and
the sets of potentially-thrown exceptions of initializer expressions and calls to
constructors of any base classes and non-static data-members.

Otherwise, let /B/ be the set /A/.

Let /E/ initially be the empty set.

For each type, /x/, in the set /B/
- if /x/ is ~std::any_exception~ then
  - add the set of potentially-thrown exception types of the /compound-statement/ of every reachable
    handler to /E/.
    NOTE: a handler is not reachable if the /exception-declaration/ for that handler names a type
    unambiguously derived from a base class type that is listed in an earlier handler's /exception-declaration/.
    NOTE: this does not include template handlers as those are only invoked from exceptions thrown
    from expressions that have a static exception specification.
  - if the list of handlers associated with this try-block does not include a handler with an /exception-declaration/ of ~...~
    then add ~std::any_exception~ to /E/.
- otherwise, if any handler is a match for an exception object of type /x/ then
  - add the set of potentially-thrown exception-types for the /compound-statement/
    associated with the first handler that matches an exception object of type /E/.
  - add the set of potentially-thrown exception-types of a function call expression
    that invokes the destructor of an object of type, /x/.
    Note: This is because exiting the handler's /compound-statement/ will potentiallly
    invoke the destructor of the exception object of type /x/.
- otherwise,
  - add /x/ to /E/
  
The set of potentially-thrown exception types of the try-block is the resulting set, /E/.

**** /expression/

There are many different types of expressions that need to be considered.

I am not going to list all of them here, but instead give some general rules that
apply to most expressions and then describe separately the rules for any expressions
that do not follow the general rules.

***** General rules for expressions

In general, an expression has a set of potentially-thrown exception types that is the
union of the sets of potentially-thrown exception types from all of the explicit
sub-expressions, as well as an implicit  

Expressions that have sub-expressions in general have a set of potentially-thrown exception
types that includes the union of the sets of potentially-thrown exception types of the
immediate-sub-expressions of that expression.

Operator expressions or conversions that resolve to calls to user-defined operator
functions have a set of potentially-thrown exception types of a function call expression to
that user-defined operator function. Built-in implicit conversions and operators
generally have an empty set of potentially-thrown exceptions.

***** Function call expressions

Function call expressions have a set of potentially-thrown exception types equal to the
union of the sets of potentially-thrown exception types of the following expressions:
- the expressions provided as arguments to the function, including any default argument expressions.
- any implicit conversion expression required to convert the argument to the corresponding parameter type, and
- the /postfix-expression/ immediately preceding the parenthesised argument-list
with the set of exception types listed in the /postfix-expression/'s function type's or function-pointer type's
exception-specification.

If the /postfix-expression/ has function type then the set of potentially-thrown exception types
is taken from the exception-specification of the function declaration.

If the /postfix-expression/ has function-pointer type then the set of potentially-thrown exception
types is taken from the exception-specification of the pointed-to function type.
Note that this may include a superset of the set of functions.

If the function or function-pointer has an dynamic exception-specification then the
set of potentially-thrown exception types is the set { ~std::any_exception~ },
otherwise, if it has a static exception-specification then the set of potentially
thrown exception types is the set of types listed in the exception specification.

Note that if any parameter types of the function or function-pointer being called have
a value category of prvalue then the set of potentially-thrown exception types will also
include the exception types listed in the type's destructor's exception-specification,
as per the next section.

***** prvalue expressions

If an expression has a prvalue value category then the set of potentially thrown exception
types of that expression includes the set of potentially thrown exception types of a
function call expression to that object's destructor, unless that expression is the operand
of a ~return~ statement of a function returning a prvalue of the same type as the operand
and the operand is used to initialize the result object via copy-initialization.

See the section on ~return~ statements for more details (in particular regarding aggregate
initialization of return values).

***** Standard conversions

The set of potentially-thrown exceptions from all standard conversions listed under
[conv.general] is the empty set.

***** Constant expressions

Any expression that is a manifestly constant expression has an empty set of potentially-thrown
exceptions. Note this includes expressions of the form ~sizeof(~ /expr/ ~)~ and ~alignof(~ /expr/ ~)~.

The intent here is that we only want to ignore exception specifications of expressions
that are guaranteed to be constant expressions, and not for expressions that are only
potentially constant evaluated.

For example:
#+begin_src c++
  constexpr int parse_integer(const char* s) throw(parse_error) {
    int result = 0;
    while (*s != '\0') {
      if (!std::isdigit(*s)) throw parse_error{};
      result = 10 * result  + (*s - '0');
    }
    return result;
  }

  int example_1() throw(auto) { // deduces to throw()
    constexpr int i = parse_integer("1234");
    return i;
  }

  int example_2() throw(auto) { // deduces to throw(parse_error)
    const int i = parse_integer("1234");
    return i;
  }
#+end_src

In ~example_2()~, even though a compiler could potentially evaluate the call to ~parse_integer()~
as a constant-expression, it is not required to do so and so could potentially have a runtime
call to a function that is potentially-throwing.

Also, if the function does happen to throw during a speculative constant execution of the function
then the compiler falls back to inserting a runtime call to the function instead, rather than
making the program ill-formed, like it would be if the invocation in ~example_1()~ were to throw.

For example, consider what the semantics should be if ~example_2()~ replaced the argument to
~parse_integer~ with ~"not-a-number"~ . In this case, we would expect that calling ~example_2~
would throw ~parse_error~ at runtime. Simply changing the value of the string literal passed
to ~parse_integer~ should not change the deduced exception-specification of the function.

***** Throw expressions

We need to consider both:
- ~throw <expr>~ expressions that throw new exception objects, and
- ~throw~ expressions that rethrow an existing exception.

****** ~throw <expr>~

A throw-expression constructs and throws new exception of type equal to the decayed type of the operand expression.

Some throw-expressions may require dynamic allocation of storage for the exception object,
which might fail due to resource exhaustion. In this case, the throw expression may instead
result in throwing an exception of type ~std::bad_alloc~.

Note that currently, the behaviour of a program that fails to allocate storage for a newly
thrown exception is unspecified. However, the behaviour for failure to allocate/rethrow
an exception_ptr is well-defined and so I would expect most implementations to do something
similar - i.e. throw ~std::bad_alloc~.

TODO: Update this pending the output of mailing list thread: https://lists.isocpp.org/core/2023/10/15012.php

This paper proposes defining some forms of throw expressions as not requiring dynamic memory
allocation, but instead requiring that implementations allocate the exception objects as
automatic storage duration objects. This is necessary to be able to provide the guarantee
to programs that particular throw expressions actually throw an exception of that type
and do not throw an expression of some other type (like ~std::bad_alloc~) and therefore
that the set of potentially-thrown exception types is limited to the 

******* Dynamic throw expressions

The function that contained the throw expression that created the exception object is
called the "originating function".

If the exception thrown by a throw-expression is either handled within the originating
function or if the exception escapes the originating function (possibly after a number
of catch/rethrow steps) and the function definition has a throw-specifier with a static
exception specification (note this implies the exception type is listed in the
throw-specification as otherwise the program would be ill-formed), then the throw
expression is considered a /static throw expression/. All other throw-expressions
are /dynamic throw expressions/.


Here is a rather extreme example:
#+begin_src c++
  void example() throw(X) {
    try {
      try {
        throw X{}; // original throw expression
      } catch (X) { // handler #1
        if (cond1)
          throw; // potential rethrow #1 - associated with handler #1
        try {
          throw; // potential rethrow #2 - associated with handler #1
        } catch (X) { // handler #2 for potential rethrow #2
          if (cond2)
            throw; // potential rethrow #3 - associated with handler #2
        }
      } // potential end-of-lifetime of exception object if cond2 was false
    } catch (X) { // handler #3 for potential rethrow #1 and #3
      try {
        throw; // potential rethrow #4
      } catch (X) { // handler #4 for potential rethrow #4
        try {
          if (cond3)
            throw; // potential rethrow #5 - associated with handler #4

          try {
            throw; // potential rethrow #6
          } catch (X) { // handler # 5 for potential rethrow #6
            throw; // potential rethrow #7 - associated with handler #5
          }
        } catch (X) { // handler #6 for potential rethrow #5 and #7
          try {
            throw; // potential rethrow #8
          } catch (Y) {
          }
        }
      }
    }
  }
#+end_src

In this case, there is no handler within this function for potential rethrow #8
and therefore the lifetime of the exception object escapes this function.

The storage for the exception object of a /deterministic throw expression/ has automatic
storage duration. Note this means that allocation of the storage for the exception object
is not performed dynamically and therefore cannot fail with a ~std::bad_alloc~ exception.



According to [except.throw] p4
#+begin_quote
The points of potential destruction for the exception object ar:
- when an active handler for the exception exits by any means other than rethrowing, immediately after
  the destruction of the object (if any) declared in the exception-declaration in the handler.
- when an object of type std::exception_ptr that refers to the exception object is destroyed, before
  the destructor of std::exception_ptr returns.

Among all points of potential destruction for the exception object, there is an unspecified last one
where the exception object is destroyed. All other points /happen before/ the last one.
#+end_quote

From this, we can deduce that, in the following snippet:
#+begin_src c++
  try {
  throw X{};
} catch (X) {
  try {
    throw;
  } catch (X) {
  } // #1

  try {
    throw;
  } catch (X) {
  } // #2
} // #3
#+end_src

That the exception object is destroyed at #3 since this is the later of all potential handlers
of the thrown exception object - #1 and #2 are sequenced before #3 and so #3 is the last point
at which the exception object may be destroyed.

Note that capturing the exception in a ~std::exception_ptr~ by calling ~std::current_exception()~
and ~std::rethrow_exception~ does not necessarily throw the same exception object. An implementation
is allowed to copy the current exception object into storage referenced by the returned ~std::exception_ptr~.

******* Rules for throw expressions

The set of potentially-thrown exception types of a throw expression is the union of
- the set of potentially-thrown exception types of the operand expression
- the type ~std::decay_t<decltype(<expr>)>~
- the set of potentially-thrown exception type of copy-initialization of the exception-object

Additionally, if the implementation fails to allocate storage for the exception

Additionally, if the throw expression exists within a function with a static exception specification, then
thrown exception objects are allocated in automatic-storage duration storage of either the
current function, or a calling function

If a throw expression exists within a function with a dynamic exception specification, then
thrown 


****** ~throw~ (rethrowing the currently handled exception)

If the rethrow expression occurs lexically within the body of a handler and is not nested within
a locally defined function body or a lambda expression body defined in the scope of that handler,
then we say that the rethrow expression is associated with the inner-most enclosing handler.

Otherwise, we say that the rethrow expression is unassociated with a handler.

For example:
#+begin_src c++

  void example() {
    throw; // unassociated - not inside handler

    try {
      throw; // unassociated - not inside handler
    } catch (A a) { // #1
      if (!can_handle(a)) {
        throw; // associated with #1
      }

      auto rethrow = [] {
        throw; // unassociated - inside lambda
      };

      struct LocalClass {
        static void Rethrow() {
          throw; // unassociated - inside nested function
        }
      };
    } catch (...) { // #2
      try {
        throw; // associated with #2
      } catch (B b) { // #3
        throw; // associated with #3
      }
    }
  }
#+end_src

If a rethrow expression is associated with a handler then we potentially have more static information about
the set of possible exception types that might be thrown by that expression than an unassociated rethrow
expression.

We can compute the set of exception types that might be thrown by such a rethrow exception
based on the set of exception-types that may propagate out of the try-block and based on the exception
types that may be handled by handlers earlier in the sequence of handlers for that try-block.

******* Unreachable handlers

One of the interesting cases to handle is when we can statically determine whether the handler is
unreachable. This can happen in one of two cases:
- When an earlier handler matches an unambiguous base-class of the later handler's exception-declaration type and
  will therefore preferentially match any exception types that would be handled by the later later handler.
- When the set of potentially thrown exception types of the try-block's /compound-statement/ is a finite set
  (i.e. does not contain contain ~std::any_exception~) and there are no types in that finite set that match
  this handler and that do not match any earlier handler.

In this case, there is the question of what the set of potentially-thrown exception types should be for
a rethrow expression that is associated with such an unreachable handler.

As the handler itself is statically determined to be unreachable, the body of the handler's compound-statement does
not contribute to the overall set of potentially-thrown exception types of the try-block,  so we might say
"it doesn't matter". However, if we consider the ability to query the set of potentially-thrown exception types
using ~declthrow()~ then a program might want to query within the context of the handler, what types might
be thrown by a rethrow expression. i.e. ~declthrow(throw)...~.

The ability to query whether or not a given handler is reachable can be useful in eliminating code that would
otherwise be ill-formed, or that we want to avoid instantiating to reduce compile-times.

For example: Code for implementing the P2300 ~std::execution::then()~ algorithm needs to determine whether invoking
the transformation function might throw and only if it does then invoke the receiver with ~set_error()~, otherwise
it should not form a call to ~set_error()~.

For example:
#+begin_src c++
  template<typename... Args>
  void then_receiver::set_value(Args&&... args) noexcept {
    try {
      if constexpr (std::is_void_v<decltype(this->func(std::forward<Args>(args)...)>) {
        this->func(std::forward<Args>(args)...);
        std::execution::set_value(this->receiver);
      } else {
        std::execution::set_value(this->receiver, this->func(std::forward<Args>(args)...));
      }
    } catch (...) {
      // Only want to instantiate the call to set_error() if there are actually
      // any errors possible.
      if constexpr (noexcept(this->func(std::forward<Args>(args)...)) {
        std::execution::set_error(this->receiver, std::current_exception());
      }
    }
  }
#+end_src

Note that here we need to repeat the essential parts of the body of the try-block in a
constexpr if condition noexcept clause to determine whether or not the catch(...) block
was reachable. And while, for this example, the body only has one such expression, it
is relatively easy to conceive of try-block logic that could be much more involved.

If, instead, we were able to query whether or not the handler was reachable by querying
the set of exception types that might be thrown by ~throw;~ within that handler, then
we could avoid having to duplicate the body expressions in the constexpr if condition.

For example:
#+begin_src c++
  template<typename... Args>
  void then_receiver::set_value(Args&&... args) noexcept {
    try {
      if constexpr (std::is_void_v<decltype(this->func(std::forward<Args>(args)...)>) {
        this->func(std::forward<Args>(args)...);
        std::execution::set_value(this->get_receiver());
      } else {
        std::execution::set_value(this->get_receiver(), this->func(std::forward<Args>(args)...));
      }
    } catch (...) {
      // Only want to instantiate the call to set_error() if there are actually
      // any errors possible.
      //
      // declthrow(throw)... will produce the empty pack if the try-block body
      // cannot emit an exception.
      if constexpr (sizeof...(declthrow(throw)...) != 0) {
        std::execution::set_error(this->get_receiver(), std::current_exception());
      }
    }
  }
#+end_src


******* Rethrow expression rules

If the rethrow expression is unassociated with a handler then the set of potentially-thrown exception types
for that rethrow expression is equal to the set { ~std::any_exception~ }.
This is because the expression could potentially be executed within the dynamic scope of any handler and
thus could rethrow any caught exception type.

Otherwise, if the rethrow expression is associated with a handler, /H/, then;

Let /E/ be the set of potentially-thrown exception types of the /compound-statement/ of the try-block associated with /H/.

Let /H-pre/ be the set of handlers associated with the same try-block as /H/ that precede /H/ in the try-block's /handler-seq/.

Let /X/ be initially the empty set.

For each type, ~e~, in the set /E/
- if ~e~ is ~std::any_exception~ then
  - if the /exception-declaration/ of /H/ is ~...~ then add ~std::any_exception~ to the set /X/
  - otherwise, let ~h~ be the type named in /H/'s /exception-declaration/
    - if any handler in /H-pre/ matches exceptions of type ~h~ then, do nothing (this handler is unreachable)
    - otherwise, if ~h~ is of non-class type or is a final class then add ~h~ to /X/
    - otherwise add ~std::any_exception~ to /X/ (it might handle an unbounded set of potential exceptions derived from ~h~)
- otherwise,
  - if any handler in /H-pre/ matches exceptions of type ~e~, then do-nothing
  - otherwise, if /H/ matches exceptions of type ~e~, then add ~e~ to /X/
  - otherwise, do nothing

The set of potentially-thrown exception types for a rethrow expression associated with /H/ is /X/.

Note that this algorithm can produce a set of potentially-thrown exception types that includes
a list of concrete exception types as well as ~std::any_exception~.

Note that these rules make the result of a ~declthrow(throw)~ expression context dependent.

******* Examples

Given the following declarations:
#+begin_src c++
  struct A {};
  struct B : A {};
  struct C : A {};
  struct D : B, C {};
  struct E final {};

  template<typename... Ts>
  void throws() throw(Ts...);
#+end_src

Example 1: static exception list, catch(...)
#+begin_src c++
  try {
    throws<A>();
  } catch (...) {
    throw; // declthrow -> { A }
  }
#+end_src

Example 2: static exception list, typed handler, unreachable catch (...)
#+begin_src c++
  try {
    throws<A>();
  } catch (A) {
    throw; // declthrow -> { A }
  } catch (...) {
    throw; // declthrow -> { }
  }
#+end_src

Example 3: multiple exceptions caught by single handler
#+begin_src c++
  try {
    throws<A, B>();
  } catch (A) {
    throw; // declthrow -> { A, B }
  } catch (...) {
    throw; // declthrow -> { }
  }
#+end_src

Example 4: multiple exceptions caught by multiple handlers
#+begin_src c++
  try {
    throws<A, B>();
  } catch (B) {
    throw; // declthrow -> { B }
  } catch (A) {
    throw; // declthrow -> { A }
  } catch  (...) {
    throw; // declthrow - > { }
  }
#+end_src

Example 5: ambiguous bases
#+begin_src c++
  try {
    throws<D>();
  } catch (A) {
    throw; // declthrow -> { } - empty because A is ambiguous base of D and so doesn't match
  } catch (B) {
    throw; // declthrow -> { D } - catch (B) unambiguously handles exceptions of type D
  } catch (C) {
    throw; // declthrow -> { } - already handled by catch (B)
  } catch (D) {
    throw; // declthrow -> { } - already handled by catch (B)
  }
#+end_src

Example 6: mixed static/dynamic
#+begin_src c++
  try {
    throws<A>();
    throws<std::any_exception>();
  } catch (A) {
    throw; // declthrow -> { std::any_exception, A }
  } catch (...) {
    throw; // declthrow -> { std::any_exception }
  }
#+end_src

Example 7: dynamic throw with final class
#+begin_src c++
  try {
    throws<std::any_exception>();
  } catch (E) {
    throw; // declthrow -> { E }
  } catch (...) {
    throw; // declthrow -> { std::any_exception }
  }
#+end_src

Example 8: mixed static/dynamic with final class
#+begin_src c++
  try {
    throws<E>();
    throws<std::any_exception>();
  } catch (E) {
    throw; // declthrow -> { E }
  } catch (...) {
    throw; // declthrow -> { std::any_exception }
  }
#+end_src

Example 9: template handler, single type
#+begin_src c++
  try {
    throws<A>();
  } template catch (auto e) { // Instantiated for types { A }
    throw; // -> declthrow -> { decltype(e) }
  }
#+end_src

Example 10: template handler, multiple types
#+begin_src c++
  try {
    throws<A, B, C, D>();
  } template catch (auto e) { // Instantiated for following types { D, B, C, A } - handlers for derived types before handlers for base types
    throw; // declthrow -> { decltype(e) }
  }
#+end_src

Example 11: template handler + non-template handler
#+begin_src c++
  try {
    throws<A, B, C, D>();
  } catch (B) {
    throw;  // declthrow -> { B, D }
  } template catch (auto e) { // Instantiated for { C, A } - handlers for derived types before handlers for base types
    throw; // declthrow -> { decltype(e) } - either A or C
  }
#+end_src

Example 12: template handler + non-template handler + dynamic throw
#+begin_src c++
  try {
    throws<A, B, C, D>();
    throws<std::any_exception>();
  } catch (B) {
    throw; // declthrow -> { B, D, std::any_exception }
  } template catch (auto e) { // Instantiated for { C, A }
    throw; // declthrow -> { decltype(e) }
  } catch (...) {
    throw; // declthrow -> { std::any_exception }
  }
#+end_src

Note that for example 12 the template handler is instantiated for
types A and C and rethrowing within the template handler only
rethrows those concrete types, despite the possibility of the
~throws<std::any_exception>()~ potentially being able to throw
exceptions of type derived from either ~C~ or ~A~.

Example 13: constrained template handler + non-template handler + dynamic throw
#+begin_src c++
  try {
    throws<A, B, C, D>();
    throws<std::any_exception>();
  } template catch (std::one_of<B, C> auto e) { // instantiated for { B, C }
    throw; // declthrow -> { decltype(e) }
  } catch (A) {
    throw; // declthrow -> { A, D, std::any_exception }
  } catch (...) {
    throw; // declthrow -> { std::any_exception }
  }
#+end_src

Note that with this example, the compiler tries to instantiate the template
handler for each of the static exception types, but substitution fails for
types A and D, succeeding only for types B and C.

The handler for A matches A and D and potentially also an unbounded set of other types derived from A.

The final handler matches an unbounded set of types not derived from A.

***** /yield-expression/

***** ~dynamic_cast~

***** ~typeid~


***** Name expressions

Expressions that simply name an object

These expressions include:
- /id-expression/
- ~this~
  
***** Lambda expressions




*** Ill-formedness of a function definition

TODO: Talk about functions being ill-formed if any exception may escape the function that
is not listed in the exception-specification.

**** 

** Template catch blocks

Add ~template catch (auto e)~ syntax to allow deducing the static type of an exception.
The catch-block is instantiated for every statically-known set of possible exception types
not already caught by preceding catch-blocks.

TODO: Describe this in more detail.

#+begin_src c++
  void do_something() throw(A, B, C);

  try {
    do_something();
  } template catch (auto e) {
    // catch-block instantiated for each unique type in the static-exception specification
    // In this case where 'e' has type A, B or C.
  }
#+end_src

or the more general syntax

#+begin_src c++
    try {
      do_something();
     }
     template<typename T>
     catch (T e) {
       //... do something with 'e'
     }

    template<typename Inner>
    struct MyException : std::exception {
      Inner inner;
    };

    try {
      do_something();
    }
    template<std::derived_from<std::exception> Inner>
    catch (MyException<T> err) {
      LOG("Failed with MyException because: {}", err.inner.what());
    }
#+end_src

#+begin_src c++
  template<typename T, typename Inner>
  struct NestedException : public T {
    Inner inner;
  };

  template<typename T>
  constexpr bool is_nested_v = false;
  template<typename T, typename Inner>
  constexpr bool is_nested_v<NestedException<T, Inner>> = true;

  void foo() throw(FooError,
                   NestedException<FooError, std::bad_alloc>,
                   NestedException<FooError, std::system_error>);

  try {
    foo();
  } template catch (std::derived_from<FooError> auto err) {
    // generic FooError handling
    if constexpr (is_nested_v<decltype(err)>) {
      if (err
    }
  }
#+end_src


- Edge-cases to consider
  - Deduced return-types - order of instantiation of catch-block templates
    may affect the return-type-deduction, which is specified to deduce to
    based on the lexically first ~return~ statement in the function body.
    But what if we have:
    #+begin_src c++
      decltype(auto) foo() throw(int, long);

      decltype(auto) bar() {
        try {
          foo();
        }
        template catch (auto err) {
          return err;
        }
      }
    #+end_src

    What is the return-type of this function?

** Virtual Functions

TODO: Describe implications for virtual functions

- Can overriding functions declare themselves with more restrictive sets of exceptions?
  - What would the calling convention look like for these functions?
  - Can we have two different functions - one for where the function is called directly vs
    where it is called through the vtable entry (and thus uses the base class calling convention).

** Concepts

TODO: Describe extension of requires clauses to allow checking the throw-specification of an expression.

For example, something like:
#+begin_src c++

  template<typename T>
  concept Foo = requires(const T& x) {
    { x.foo() } throw(A, B) -> std::same_as<int>;
  };
#+end_src

In this case, the concept passes only if the ~declthrow(x.foo())...~ expression evaluates to
a subset of the types listed in the throw specification.

Q. Should the ~throw(A,B)~ detect that the exception specification is exactly one of ~throw()~, ~throw(A)~, ~throw(B)~ or ~throw(A,B)~?
Or should it allow throwing exceptions that derive from ~A~ and ~B~.
i.e. such that if I call it inside a try/catch block with handlers for ~catch (A)~ and ~catch (B)~ then that's ok?

** Coroutines

Can we extend ~promise.unhandled_exception()~ to allow passing the concrete error types that
propagate out of the coroutine as arguments to allow them to process the error values
more efficiently/store them in variants, etc.



** Code Evoluation

- How do we evolve a function to add new exception types?
- How do we evolve a function to remove exception types from throw-specification?
- What about changing from dynamic to static?
- Or from static to dynamic?


** Interaction with Pattern Matching

TODO: Look into what this might look like.

** Avoiding overhead implied by ~std::current_exception()~ and ~throw;~

TODO: Explore this more.

- ideally we make catch-blocks in function definitions with ~throw()~ specifications
  not support ~throw;~ outside of the immediate lexical context of the catch-block.
  i.e. no "Lippincott Functions".
- consider adding a ~catch(...)~ form where the ~std::exception_ptr~ is passed as
  a parameter, rather than being implicitly available.


** Avoiding overhead implied by ~std::unhandled_exceptions()~

TODO: Supporting ~std::unhandled_exceptions()~ behaviour requires that exception handling of
static exceptions still increments/decrements the count of unhandled exceptions at the
appropriate location.

TODO: Suggest that if we want to avoid this that we need to introduce a destructor overload
that is called during unwind path destruction.


** Implementation Strategies

*** Multiple return-paths/return-addresses

*** Multiple return-value-slots

*** Tail Calls

*** Interop between static-exception functions and dynamic-exception functions

*** Virtual function calls


* Abstract
* Motivation

- Performance
  - runtime overhead of exceptions can be large (1000x in some cases)
  - uses heap allocations to store exceptions
  - exception_ptr uses ref-counting / atomic ops
  - current_exception() / unhandled_exceptions() / throw; relies on thread-locals
- Correctness
  - Declaring a function noexcept can be dangerous
    - Can lead to unexpected calls to std::terminate() if there is actually an unhandled exception.
    - This can happen at runtime.
    - The compiler often has no ability to help you identify when this is the case
      - Many existing functions are not declared noexcept, yet do not throw exceptions.
        Warning about calling a noexcept(false) function from a noexcept(true) function
        would lead to too many false positives to be useful in practice.
    - Unexpected calls to terminate() are usually undesirable, e.g. an application with a user-interface suddenly disappears,
      and can even be unsafe, e.g. if you have a safety-critical embedded system controlling a car travelling at 100km/h.
    - Exception paths are hidden - difficult to see from calling code whether there are expressions that might throw.


- Workarounds
  - Alternative error handling mechanisms
    - Error-codes
    - std::expected
    - std::optional
    - std::variant
  - Optimising exceptions
    - Gor's paper shows that exception-handling can be optimised in some cases,
      but relies a lot on being able to inline all functions in-scope, and being
      able to see throw/catch sites in same function.

* Background

** Prior Work

*** Midori

TODO: Read up about Midori error-handling experiements.

*** Throw specifications and noexcept

- [[https://wg21.link/N2855][N2855]] - Rvalue References and Exception Safety (2009)
  - Discusses the problem with move-constructors and providing strong exception-safe guarantee,
    which motivates some way for the library to check whether an expression/move-ctor can throw.
  - Proposes introducing the ~noexcept~ specifier
  - Originally proposed to have ~noexcept~ functions be ill-formed if any exception could
    potentially escape the function.
  - Proposed to use syntax ~throw(...)~ to mean "this function can throw any exception."
    This eventually became ~noexcept(false)~.
  - Proposes making destructors ~noexcept~ by default.
  - Proposes adding a ~noexcept~ block that allows telling the compiler to assume that no
    exceptions will propagate out of this block. e.g. where exceptions are a dynamic property
    that is guarded against by other means.
    #+BEGIN_SRC c++
      double sqrt(double);

      noexcept void f(double& x) {
        if (x > 0) {
          noexcept { x = sqrt(x); } // okay: if sqrt(x) throws, invokes undefined behaviour
        }
      }
    #+END_SRC
    - Would need something similar to make it easy to suppress errors about unhandled exceptions.
      #+BEGIN_SRC c++
        void f(double& x) throw() {
          if (x > 0) {
            try { x = sqrt(x); }
            catch (...) { std::unreachable(); /* or std::terminate(); */ }
          }
        }
      #+END_SRC

  - Proposes that exception specifications are deprecated
    - Lack of static checking has limited usability and ocnfused users
    - Provide few benefits for compilers
    - Not useful in generic code, where functions need to know whether an exception can the thrown or not, but don't know (or care) what kind of exceptions can be thrown.
    - In fact, the noexcept specifier---along with the ability to detect whether an operation is noexcept via concepts---provides precisely the statically-checked exception specifications that are required in C++ code.

- N2983 Allowing Move Constructors to Throw (2009)
  - Proposes use of ~std::move_if_noexcept()~ in move-constructors that require strong exception-safety guarantee.
  - Proposes new ~noexcept(<expr>)~ expression.
  - Proposes a parameterised ~noexcept(<bool-expr>)~ function specifier.
  - Suggests making destructors ~noexcept~ by default.

- [[https://wg21.link/N3051][N3051]] - Deprecating exception specifications
  - Talks about shortcoming of original throw-specifications
    - Run-time checking
      - Offers programmer no guarantees all exceptions have been handled.
      - ~std::unexpected()~ does not lend itself to recovery.
    - Run-time overhead
      - Run-time checking requires compiler to generate extra code, which hampers optimisations.
    - Unusable in generic code
      - Not generally possible to know what types of exceptions may be thrown from operations on template arguments, so precise exception specification cannot be written.
  - Claims that there are only two useful exception-specifications: throws-something and throws-nothing.
  - Proposes deprecation of ~throw()~ specifications as ~noexcept~ covers the two useful cases.
  - Also proposed that ~noexcept~ was equivalent to ~throw()~ on a declaration, but differed
    in semantics when it was placed on the definition.

- [[https://wg21.link/N3103][N3103]] - Security impact of noexcept
  - Says that a program that continues after noexcept function exits with an exception can
    lead to undefined/unexpected-behaviour that can be exploited by a malicious user to bypass
    security restrictions and/or cause denial-of-service attacks.
  - Proposes mandating that the program should terminate if there is ever an unhandled exception
    that is about to exit a noexcept function.

- [[https://wg21.link/N3248][N3248]] - noexcept prevents library validation (2011)
  - The "Lakos Rule" paper
    - don't put noexcept on functions with narrow contracts
    - so we can test assertions/preconditions
  - The risk from overly aggressive use of noexcept specifications is that programs with hidden terminate calls are produced
  - The risk of under-specifying noexcept specifications is that they become difficult to add in a later
    revision of the standard, as the noexcept operator becomes an observable part of the ABI.
  - Long list of library changes to roll back use of noexcept.

- [[https://wg21.link/N3279][N3279]] - Conservative use of noexcept in the Library (2011)
  - Summary of N3248 that just describes the guidelines for use of noexcept

- N4133 - Cleanup for exception-specification and throw-expression
  - N4285 - Cleanup for exception-specification and throw-expression
  - Editorial wording cleanup
  - Introduces "exception specification" semantic concept separate from the grammar term exception-specification.
  - Wording changes from "throws an exception" to "exits via an exception"

- N4320 - Make exception specifications be part of the type system (2014)
- N4518 - Make exception specifications be part of the type system, version 2 (2015)
- N4533 - Make exception specifications be part of the type system, version 3 (2015)
- P0012R0 -     Make exception specifications be part of the type system, version 4 (2015)
- P0012R1   Make exception specifications be part of the type system, version 5

- P0003R0 -         Removing Deprecated Dynamic Exception Specifications (2015)
- P0003R2   Removing Deprecated Dynamic Exception Specifications from C++17 (2016)
- P0003R5   Removing Deprecated Exception Specifications from C++17 (2016)



*** Deducing exception specifications
:PROPERTIES:
:ID:       02f589c7-b738-439d-a886-ed5ccdf08a72
:END:

- N3202 - To which extent can noexcept be deduced (Bjarne) (2010)
  - Summarises N3227
    - "almost every  statement in function tempaltes leak into the noexcept declaration"
    - "a user-maintained noexcept increases the likelihood that the specification is not
      correct. In turn this implies (a) an increased chance that client code terminates
      unexpectedly, or (b) that optimization opportunities are lost. (Note tha providing
      correct warnings is also undecidable.)
    - client code can still change (fail to compile, different runtime behaviour) if
      noexcept is added or removed from a library.
    - Questions of consistency of deducing noexcept declarations:
      #+BEGIN_QUOTE
      The idea of noexcept is to allow code to be written to take
      advantage of knowing that code will not throw. The key observation is that if we fail to deem a
      function noexcept even though it doesnt throw the worst that can happen is that sub-optimal,
      but still correct, code will be executed. In other words, as long as we dont mistakenly deem a
      throwing function noexcept, not serious harm is done.      
      #+END_QUOTE
    - Walks through some cases where there might be inconsistencies in deducing the noexceptness
      in different contexts.
      - This seems to be based on the assumption that it needs to be an implicit deduction rather
        than explicit opt-in for each function.

- [[https://wg21.link/N3207][N3207]] - noexcept(auto) (2010)
  - Highlights issues with implicit deduction in N3202
    - Easy to accidentally introduce ODR violations
    - Issues with eager function template instantiation to determine function signature/noexceptness
      (not SFINAE friendly).
  - Proposes ~noexcept(auto)~ as in-between compromise between having to duplicate body in noexcept declaration, and fully implicit, which has issues
  - Doesn't let mutually recursive functions all have their noexcept-specification deduced
    #+BEGIN_SRC c++
      struct A {
        void f(int i) noexcept(auto)
          { if (i > 1) g(i-1); } // call to g()  is ill-formed as it's noexcept specifier is incomplete.
        void g(int i) noexcept(auto)
          { if (i > 1) f(i-1); }
      };
    #+END_SRC
  - Also mentions this example as being ill-formed, but it looks ok to me:
    #+BEGIN_SRC c++
      template<bool> struct M;
      template<> struct M<true> { int large[100]; };
      template<> struct M<false> { char small; };
      struct B {
        template<bool> void maybe_throw();
        template<> void maybe_throw<true>() noexcept(auto) { throw 0; } // deduced noexcept(false)
        template<> void maybe_throw<false>() noexcept(auto) { } // deduced noexcept
        void f() noexcept(auto) { maybe_throw<(sizeof(B) > 10)>(); };
        M<noexcept(f())> data; // ill-formed because the noexcept-specification for f() is not yet deduced.
      };
      // Definition of f() isn't available until the end of the class-definition, here.
    #+END_SRC
  - Recursion is also interesting:
    #+BEGIN_SRC c++
      int f(int i) noexcept (auto) 
      {
        if (i == 0)
          return i;
        else
          return f(i-1)+i;
      }
    #+END_SRC
    Should in theory be deducible, but similar to mutually recursive functions
    - What about the following:
      #+BEGIN_SRC c++
        int f(int i) noexcept (auto) {
          if constexpr (noexcept(f(i-1))) {
            throw X{};
          } else {
            return i;
          }
        }
      #+END_SRC
      Such a function is self-contradicting.
      - Could allow calls to ~f()~ but is ill-formed if you query ~noexcept(f())~?

    - Minutes:
      - dislike of noexcept(auto) with SFINAE on exception-specifications; having only the latter without the former is ok
      - you can't overload on exception-specifications, why do you want to SFINAE on it?
      - can delay determining exception-specification until the function was selected in overload resolution
      - Issue with non-template deduced member inside class template
        #+BEGIN_SRC c++
          template<class T1, class T2>
          struct C {
            C(C&& other) noexcept(auto)
              : first(std::move(other)), second(std::move(other))
            { }

            T1 first;
            T2 second;
          };

          C<int, int> x;  // will instantiate the body of C::C(&&) right here
        #+END_SRC
        The implicit instantiation of the body of the move constructor should only be performed if ODR-used.
        This would make noexcept(auto) more like explicitly enumerating the expressions.
        Ideally, the noexcept specification shoud only be deduced if overload selected.
        May need to be deduced even if used in unevaluated operand - e.g. ~noexcept(f())~
      - Issue with debug builds w/ assertions that throw in move-ctor with deduced noexcept meaning that std::vector copies instead of throwing and never calls move ctor.
    - Paper was struck from core motions in 2010-11 Batvia meeting
      - Why?

    - Presentation Notes
      https://wiki.edg.com/pub/Wg21batavia/Documents/noexcept_auto.pdf
      - Lists two perils
      - Adding print statements changes the deduced exception-specification (e.g. using cout)
        Can workaround by adding try/catch.
      - Adding assertions can change deduced exception-specification.
        - An issue if assertion macro throws.
          Not an issue if it terminates.
        
      
- N3227 - Please reconsider noexcept (2010)
  - Draft: https://wiki.edg.com/pub/Wg21batavia/EvolutionWorkingGroup/reconsider_noexcept.html
  - https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3227.html
  - Suggests that we should support deducing ~noexcept~-ness of a function
  - Talked about avoiding use of flow-analysis to determine noexceptness of a function (undecidable/hard problem - Rice's theorem).
  - Concerns about inconsistencies across compiler with flow-analysis leading to some programs being well-formed on some compilers but ill-formed on others based on whether they deduced the noexcept the same way.
  - Not a problem if you ignore flow-analysis and just look at whether there are any potentially-throwing expressions that do not catch exceptions.
  - Has some expected objections and some counter-arguments

- N3204 -  Deducing "noexcept" for destructors (2010)
  - Short paper
  - Wording for  default exception-specification to be the same as for an implicit destructor.
    i.e. deduced from the exception-specifications of the data-members/base-classes.

- N3386 - return type deduction for normal functions (2012)
  - N3638 - Return-type deduction for normal functions (2013)
  - maybe relevate to noexcept(auto) deduction?
  - talks about deduced return types for recursive functions
    - works if there is a prior recursion-breaking return-statement by the
      time we get to the use of the recursive call.
  - Talks about instantiation of function templates even if they are not odr-used
    e.g. if you use it in a non-evaluated context such as ~decltype(f(1))~.
  - Proposes adding ~decltype(auto)~ as well.

- [[https://wg21.link/N4473][N4473]] - noexcept(auto), again (2015) Ville
  - Tries to open up the discussion about adding ~noexcept(auto)~ again.
  - Not a lot of detail here, other than this is something that is oft-requested, and is a big pain point for some people.
  - [[https://wiki.edg.com/bin/view/Wg21lenexa/N4473][Minutes]]
    - Jason M had some proposed wording (not found/attached)
    - Had consensus in EWG in Lenexa
- [[https://wg21.link/P0133R0][P0133R0]] -  Putting noexcept(auto) on hold, again
  - Abandoned noexcept(auto) upon realising that you still need to duplicate the expressions
    for SFINAE cases.
    - Seems like there still would have been value in adding this.

*** Faster Exceptions

- N4049 - 0-overhead-principle violations in exception handling (2014)
- N4234 - 0-overhead-principle violations in exception handling - part 2 (2014)

- low-latency SG
  - N4456 - Towards improved support for games, graphics, real-time, low latency, embedded systems
    - Mentions wanting guaranteed support for -fno-exceptions, -fno-rtti
      No detail on why/motivation/issues.
  - 

- P0709 Zero-overhead deterministic exceptions (Herb Sutter) 
  - Intro sections have a lot of good motivation for fixing exceptions.
  - Makes the claim that the overheads of dynamic exceptions cannot be avoided by a better
    implementation strategy.
  - Section 4.1 contains EWG polls indicating that exception-handling is something that they want to improve
  - Marking function with ~throws~ turns return type into a union of R + E with a bool flag to indicate whether it's a result/error.
    - Basically baking std::expected into the language
    - Requires a new function-call ABI.
  - ~throws(cond)~ can be a bool value, or an ~except_t~ value (no_except, static_except, dynamic_except)
  - std::error type
    - Tries to map error values to exception type when propagating out of a function.
      e.g. std::errc::ENOMEM <-> std::bad_alloc
    - For types where there is no obvious standard mapping, it would just wrap an exception_ptr
    - This mapping seems like it would be complicated, and difficult to specify/extend.
  - At call sites (that propagate or handle an error), a potential downside of the if-error-goto-handler
    implementation model is that it injects branches that can interfere with optimizations.
    - Claims that you can still use table-based handling.
      But not sure what this would look like.
  - Catching ~std::error~ then requires you to do further conditional branches
    to determine which of the many possible error-conditions it might be.
    - The callee knew which error they returned with, yet this information has
      been type-erased in the ~std::error~ object, and the type information
      now needs to be extracted again.

  - try expression / statement
    - Require every potentially throwing expressions/statement to be covered by a ~try~ expression.

    - Also proposes a ~catch(E) { ... }~ without an opening ~try { ... }~ block.
      Instead, could have ~try~ expressions scattered throughout code between
      enclosing open-brace and ~catch~ clause.
      - This would have issues with the programmer determining what variables are in-scope inside
        the ~catch~ block. Every variable whose scope beings after the first ~try~ expression
        would potentially  not exist and not be available in the ~catch~ block.

  - Suggests adding a ~throws{E}~ syntax for specifying a single error type that would be thrown
    instead of ~std::error~.


*** Freestanding


*** Alternative Error-handling mechanisms

**** std::expected

- N4015 - A proposal to add a utility class to represent expected monad (2014)
- N4109 - A proposal to add a utility class to represent expected monad - Revision 1 (2014)


**** std::variant

- N4450 - Variant: a typesafe union (v2) 
- N4542 - Variant: a type-safe union (v4) (2015)
- P0129R0   We cannot (realistically) get rid of throwing moves
  - Talks about std::variant and support for types with throwing move ctor/assignment
- P0087R0   Variant: a type-safe union without undefined behavior (v2)
- P0088R0   Variant: a type-safe union that is rarely invalid (v5) (2015)
- P0088R1   Variant: a type-safe union that is rarely invalid (v6) (2015)
- P0239R0   valueless_by_exception (2015)
- P0088R2           Variant: a type-safe union for C++17 (v7) (2016)
- P0095R0   The case for a language based variant
  
**** std::optional


** Paper notes


- Previous papers relating to exceptions
  - 2004
    - N1664 - Toward Improved Optimization Opportunities in C++0x
      - Describes type-effects of ~throwing()~ / ~nothrow~ qualifier on a function as part of the function's type.
  - 2003
    - N1462 	03-0045 	Safe Exceptions and Compiler Security Checks
  - 2004
    - N1725 	04-0165 	Copy Elision in Exception Handling
  - 2005
    - [[https://www.stroustrup.com/fast_dynamic_casting.pdf][Fast dynamic casting]] (Gibbs, Stroustrup)
      - Talks about fast dynamic casting using integer ids and the Chinese Remainder Theorem.
        Assigns each type in the hierarchy a prime number.
        Type id for each type is the product of the prime numbers of all base classes.
        Can test for castability by checking if concrete type id is divisible by base-class type id.
      - Referenced in Bjarne's paper from 2019 P1947R0.

    - N1825 	05-0085 	Addressing Exception Specifications for Next Generation of C++
      - talks about making exception specifications similar to contract post-conditions
        - std::bad_exception - exception thrown when exception-specification violated
          - inherits from std::broken_contract, which inherits from std::exception
  - 2006
    - N2061 	06-0131 	Library Exception Propagation Support
    - N2089 	06-0159 	Asynchronous Exceptions for Threads
    - N2096 	06-0166 	Transporting Values and Exceptions between Threads
    - N2106 	06-0176 	Cloning and Throwing Dynamically Typed Exceptions
    - N2107 	06-0177 	Exception Propagation across Threads
    - 
  - 2007
    - N2309 	07-0169 	Error-handling and Exception-related library changes for C++0x
    - 
  - 2008
    - N2509 	08-0019 	Nesting Exceptions
    - N2538 	08-0048 	Removal of System error support
    - N2559 	08-0069 	Nesting Exception Objects (Revision 1)
    - N2636 	08-0146 	Error Handling Specification for Chapter 30 (Threads)
    - N2678 	08-0188 	Error Handling Specification for Chapter 30 (Threads)
    - N2809 	08-0319 	Library Support for hybrid error handling
    
        
  - 2009
    - [[https://wg21.link/N2815][N2815]] - Improving the standard library's exception specifications
      - Proposes adding "no-fail" guarantees to certain container methods
    - [[https://wg21.link/N2838][N2838]] - Library support for Hybrid Error Handling
      - Proposes adding ~void foo(error_code& ec = throws())~ as a way to avoid doubling the number
        of overloads when an ~error_code~ and exception-throwing version both exist.
      - Doesn't look like it was accepted.
    - N2952 - Accessing current exception during unwinding
      - Talks about the use-case of wanting to log an in-flight exception in the destructor
  - 2010
    - N3114 - throw() becomes noexcept
      - Library changes that search/replace ~throw()~ with ~noexcept~.
    - N3148 - throw() becomes noexcept (Version 2)
    - N3149 - From Throws: Nothing to noexcept
      - Library specification changes to use ~noexcept~ in more places.
    - N3150 - Removing non-empty dynamic exception specifications from the library
      - Removes ~throw(std::bad_alloc)~ from allocation functions
    - N3155 - More on noexcept for the language support library
      - Adding ~noexcept~ to more library bits.
    - N3156 - More on noexcept for the diagnostics library
    - N3157 - More on noexcept for the General Utilities Library
    - N3166 - Destructors default to noexcept
    - N3167 - Delete operators default to noexcept
    - N3180 - More on noexcept for the Strings Library
    - N3187 - More on noexcept for the Containrs Library
    - N3195 - From Throws: Nothing to noexcept (version 2)
    - N3199 - More on noexcept for the General Utilities Library (version 2)

      

    - N3205 - Delete operators default to noexcept

    - 2011
      - N3251 - noexcept for the ATomics Library
      - N3252 - A review of noexcept in the threads library
      - N3263 - More on noexcept for the Containers Library (revision)
      - N3267 - A review of noexcept in the threads library (revised)
    - 2012
      - N3441 - Call Stack Utilities and std::exception extension proposal
    - 2013
      - N3614 - unwinding_exception
      - N3757 - Support for user-defined exception information and diagnostic information in std::exception
      - N3758 - standard exception information types for std::exception
    - 2014
      - N4002 - Cleaning-up noexcept in the LIbrary
      - N4055 - Ruminations on (node-based) containers and noexcept
      - N4152 - uncaught_exceptions (2014)
        - N4259 - Wording for std::uncaught_exceptions (2014)
      - N4157 - Relaxing Packaging Rules for Exceptions Thrown by Parallel Algorithms
      - N4227 - Cleaning-up noexcept in the Library (Rev 2)
      - N4258 - Cleaning up noexcept in the Library (Rev 3)
      - N4274 - Relaxing Packaging Rules for Exceptions Thrown by Parallel Algorithms - Proposed Wording (Revision 1)
    - 2015
      - N4526 - Towards improved support for games, graphics, real-time, low latency, embedded systems
        - Talks about supporting version with exceptions disabled (-fno-except, -fno-rtti)
      - P0043R0 -         Function wrappers with allocators and noexcept
      - P0044R0 -         unwinding_state: safe exception relativity
      - P0172R0   Abominable Function Types
    - 2016
      - P0333R0   Improving Parallel Algorithm Exception Handling
      - P0394R4   Hotel Parallelifornia: terminate() for Parallel Algorithms Exception Handling
      - P0509R1   Updating "Restrictions on exception handling"
        - Allows library functions to throw exceptions derived from the ones listed in the Throws: paragraph.
    - 2017
      - P0568R0   Towards Better Embedded programming support for C++ and an update on the status of SG14, two years later
      - P0619R1   Reviewing Deprecated Facilities of C++17 for C++20
        - Covers proposed removal of throw specifications
      - P0640R0   User-defined exception information and diagnostic information in exception objects
      - P0762R0   Concerns about expected<T, E> from the Boost.Outcome peer review
      - P0779R0   Proposing operator try() (with added native C++ macro functions!)
      - P0797R0   Exception Handling in Parallel STL Algorithms
      - P0829R0   Freestanding proposal
      - P0619R2   Reviewing Deprecated Facilities of C++17 for C++20
    - 2018
      - P0323R5   std::expected
      - P0824R1   Summary of SG14 discussion on <system_error>
      - P0829R1   Freestanding Proposal
      - P0881R0   A Proposal to add stack trace library
      - P0884R0   Extending the noexcept Policy
      - P0938R0   SG14: Low Latency Meeting Minutes 2017/12/13-2018/01/10
      - P0939R0   Direction for ISO C++
        - Lists "Exception and error returns" as one of the medium-term aims (3-10 years)
      - P0323r6   std::expected
      - P1002R0   Try-catch blocks in constexpr functions
      - P0132R1   Non-throwing container operations
      - P0709R0   Zero-overhead deterministic exceptions: Throwing values
      - P0933R0   Runtime type introspection with std::exception ptr
      - P1028R0   SG14 status_code and standard error object for P0709 Zero-overhead deterministic exceptions
      - P1066R0   How to catch an exception_ptr without even try-ing
      - P1071R0   SG14: Low Latency Meeting Minutes 2018/04/11- 2018/05/02
      - P0323r7   std::expected
      - P0095R2   Language Variants
      - P0709R2   Zero-overhead deterministic exceptions: Throwing values
      - P0933R1   Runtime type introspection with std::exception_ptr
      - P1028R1   status_code and standard error object for P0709 Zero-overhead deterministic exceptions
      - P1066R1   How to catch an exception_ptr without even try-ing
      - P1095R0   Zero overhead deterministic failure - A unied mechanism for C and C++
      - P1105R1   Leaving no room for a lower-level language: A C++ Subset
        - talks about freestanding and exceptions that just terminate on throw
      - P1195R0   Making <system_error> constexpr
      - P1196R0   Value-based std::error_category comparison
      - P1197R0   A non-allocating overload of error_category::message()
      - P1198R0   Adding error_category::failed()
      - P1273R0   86 The Absurd (From Exceptions)
      - P1002R1   Try-catch blocks in constexpr functions
      - P0788R2 Standard Library Specification in a Concepts and Contracts World
    - 2019
      - P0829R4   Freestanding Proposal
      - P1377R0   Summary of Dec 2018 SG14 freestanding discussions
      - P0323R8   std::expected
      - P0709R3   Zero-overhead deterministic exceptions: Throwing values
      - P0797R2   Handling Concurrent Exceptions with Executors
      - P1028R2   SG14 status_code and standard error object for P0709 Zero-overhead deterministic exceptions
      - P1640R0   Error size benchmarking
      - P1641R0   Freestanding Library: Rewording the Status Quo
      - P1642R0   Freestanding Library: Easy [utilities]
      - P1656R0   "Throws: Nothing" should be noexcept
      - P1667R0   Concept-aware noexcept specifiers
      - P1675R0   rethrow_exception must be allowed to copy
      - P1676R0   C++ Exception Optimizations. An experiment.
      - P1736R0   SG14: Low Latency Meeting Minutes 2019/04/17-2019/06/12
      - P0323R9   std::expected
      - P0709R4   Zero-overhead deterministic exceptions: Throwing values
      - P1675R1   rethrow_exception must be allowed to copy
      - P1640R1   Error size benchmarking: Redux
      - P1641R1   Freestanding Library: Rewording the Status Quo
      - P1642R1   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P1888R0   Executors without exception handling support
      - P1909R0   SG14: Low Latency Meeting Minutes 2019/08/14-2019/09/11
      - P1947R0   C++ exceptions and alternatives (Bjarne)
        - 
      - P1028R3   SG14 status_code and standard error object
    - 2020
      - P1642R2   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P1706R2   Programming Language Vulnerabilities for Safety Critical C++
      - P1641R3   Freestanding Library: Rewording the Status Quo
      - P2013R1   Freestanding Language: Optional ::operator new
      - P2170R0   Feedback on implementing the proposed std::error type
      - P1642R4   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P2013R2   Freestanding Language: Optional ::operator new
      - P2013R3   Freestanding Language: Optional ::operator new
      - P1642R5   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P2268R0   Freestanding Roadmap
    - 2021
      - P2232R0   Zero-Overhead Deterministic Exceptions: Catching Values
      - P2338R0   Freestanding Library: Character primitives and the C library
      - P0323R10          std::expected
      - P1706R3   Programming Language Vulnerabilities for Safety Critical C++
      - P2376R0   Comments on Simple Statistical Functions (p1708r4): Contracts, Exceptions and Special cases
      - P2381R0   Pattern Matching with Exception Handling
      - P1642R6   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P2370R0   Stacktrace from exception
      - P2338R1   Freestanding Library: Character primitives and the C library
      - P2392R0   Pattern matching using is and as 
      - P2392R1   Pattern matching using "is" and "as"
      - P2411R0   Thoughts on pattern matching
      - P2410R0   Type-and-resource safety in modern C++
      - P2370R1   Stacktrace from exception
      - P1642R7   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P0323R11          std::expected
      - P2490R0   Zero-overhead exception stacktraces
    - 2022
      - P2370R2   Stacktrace from exception
      - P2517R0   Add a conditional noexcept specification to std::apply
      - P2524R0   SG14: Low Latency/Games/Embedded/Finance/Simulation 2020/12/09-2022/01/12
      - P0323R12          std::expected
      - P2505R1   Monadic Functions for std::expected
      - P2544R0   C++ exceptions are becoming more and more problematic
      - P2549R0   std::unexpected should have error() as member accessor
      - P1642R8   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P2490R3   Zero-overhead exception stacktraces
      - P2517R1   Add a conditional noexcept specification to std::apply
      - P2392R2   Pattern matching using is and as
      - P2505R5   Monadic Functions for std::expected
      - P2561R1   An error propagation operator
      - P2683R0   SG14: Low Latency/Games/Embedded/Finance/Simulation virtual meeting minutes 2022/02/09-2022/10/12
      - P2687R0   Design Alternatives for Type-and-Resource Safe C++
      - P2688R0   Pattern Matching Discussion for Kona 2022
      - P1028R4   SG14 status_code and standard error object
      - P2602R2   Poison Pills are Too Toxic
      - P2698R0   Unconditional termination is a serious problem
    - 2023
      - P1028R5   SG14 status_code and standard error object
      - P2887R0   SG14: Low Latency/Games/Embedded/Finance/Simulation virtual meeting minutes to 2023/05/11
      - P2833R1   Freestanding Library: inout expected span
      - P2966R0   Making C++ Better for Game Developers -- Progress Report
      - P2966R1   Making C++ Better for Game Developers -- Progress Report
      - P2976R0   Freestanding Library: algorithm, numeric, and random 
      
      
- Other references for exceptions
  - https://gcc.gnu.org/legacy-ml/libstdc++/2008-06/msg00001.html
    Implementation of exceptions in libstdc++ (std::exception_ptr)
  - A Pragmatic Look at Exception Specifications (2002) - Herb Sutter
    http://www.gotw.ca/publications/mill22.htm
    - Throw specifications could not be included in a typedef of a function-pointer type.
      But they could be included in the type of a function-pointer variable declaration
      #+BEGIN_SRC c++
        void f() throw(A, B);
        
        typedef void (*PF)() throw(A,B); // syntax error

        void (*pf)() throw(A,B); // ok
        pf = f; // ok
      #+END_SRC
    - You can convert from a more-restrictive function-pointer type to a less-restrictive function-pointer type.
      i.e. where the  target variable throw specification is a strict superset of the source function-pointer.
    - If a function does throw an exception not listed in the throw-specification then it calls ~std::unexpected()~
      - This function could rethrow a different exception, but:
        - It was global so was unlikely to be able to choose a suitable alternative exception type.
    - Compiler has to generate more code to ensure at runtime that only those exceptions that match
      the exception-specification are actually thrown.
    - Compiler can insert calls to ~std::unexpected()~ which by default calls ~std::terminate()~.
    - Removing an exception from a throw-specification in a base-class virtual method declaration is a breaking change.
    - Microsoft compiler did not generate code to enforce ~throw()~ specifications, but had optimisations that relied on the stated behaviour.
      - This turned throw-specifications from a request to the compiler to enforce the throw specification
        to a promise to the compiler that you won't throw anything other than these exceptions, which the
        compiler relies upon and optimises. Leading to UB if you do actually end up throwing something
        out-of-specification.
    - Boost guidelines on excpetion specifications basically say "don't use throw-specifications", except maybe "throw()" and even then, you should probably avoid that.
  - The sad history of the C++ throw(...) exception specifier
    https://devblogs.microsoft.com/oldnewthing/20180928-00/

  - https://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf
    Technical report on performance
    - Section 5.4 talks about exception handling
      - 
        #+BEGIN_QUOTE      
        With exceptions, once a problem is identified, it cannot be ignored  failure to catch and
        handle an exception results in program termination.
        #+END_QUOTE
      - 
        #+BEGIN_QUOTE
        In some embedded and resource-constrained environments, use of exceptions was deliberately excluded
        either because of fear of overheads or because available exception implementations could not
        meet a projects requirements for predictability.
        #+END_QUOTE
      - 
        #+BEGIN_QUOTE
        Enforcing exception specifications - Conformance of the thrown types to the
        list of types permitted in the exception-specification must be checked. If a mismatch
        is detected, the unexpected-handler must be called.
        #+END_QUOTE
      - 
        #+BEGIN_QUOTE
        A run-time cost is associated with checking the throw-specifications of the functions
        that are called.
        #+END_QUOTE
      - 
         #+BEGIN_QUOTE
         For some programs, difficulty in predicting the time needed to pass control from a throw-
         expression to an appropriate catch clause is a problem. This uncertainty comes from the
         need to destroy automatic objects and  in the table model  from the need to consult
         the table. In some systems, especially those with real-time requirements, it is important
         to be able to predict accurately how long operations will take.
        
         For this reason current exception handling implementations may be unsuitable for some
         applications.  
         #+END_QUOTE
  - Design and Evolution of C++ (Stroustrup)
    - Chapter 16 - Exceptions
    - Aims and Assumptions (selected points)
      - Exception handlers are rare compared to function definitions.
      - Exceptions occur infrequently compared to function calls.
      - Exceptions are a language-level concept
    - Ideals
      - Type-safe transmission of arbitrary amounts of information from a throw-point to a handler
      - No added const (in time or space) to code that does not throw an exception
      - A guarantee that every exception raised is caught by an appropriate handler.
      - A way of grouping exceptions so that handlers can be written to catch groups of exceptions as well as individual ones.
      - A mechanism that allows cooperation with other languages, especially with C.
      - Easy to use.
      - Easy to implement.
    - Quotes
      - To some, the most important aspect of exceptiosn is that they provide a general
        mechanism for reporting errors detected in a constructor.
        - Workarounds include putting object into an invalid state, leaving return-value indicators
          in agreed-upon variables (global/thread_local/out-parameters).
      - In a mixed-language environment, it is not possible to require a specific  action
        of a function because that function may be written in another language.
        In particular, a C++ function throwing an exception may be called by a C function that was
        called by a C++ function willing to catch the exception.
      - In effect, writing this:
        #+BEGIN_SRC c++
          void f() throw (e1, e2) {
            // stuff
          }
        #+END_SRC
        is equivalent to writing this:
        #+BEGIN_SRC c++
          void f() {
            try {
              // stuff
            }
            catch (e1) { throw; }
            catch (e2) { throw; }
            catch (...) { unexpected(); }
          }
        #+END_SRC
      - The most important advantage is that the function /declaration/ belongs to an interface
        that is visible to its callers. Function /definitions/ on the other hand, are not
        universally available and even if we do have access to the source code of all our
        libraries, we strongly prefer not to have to look at it very often.
      - "Another advantage is that it may still be practical to detect many uncaught exceptions during compilation" - Koenig, 1990
      - Ideally, exception specifications woudl be checked at compile time, but that would
        require that every function cooperate in the scheme, and that isn't feasible.
      - Such static checking could esily become a source of much recompilation.
        Worse, such recompilation would only be feasible for users who had all the source code to recompile.
        #+BEGIN_QUOTE
        For example, a function must potentially be changed and recompiled if a function it calls
        (directly or indirectly) changes the set of exceptions it catchs or throws. This could
        lead to major delays in the production of software produced (partly) by composition of
        libraries from different sources. Such libraries would /de facto/ have to agree on a
        set of exceptions to be used. For example, if subsystem X handles exceptions from subsystem Y
        and the supplier of Y introduces a new kind of exception, then X's code will have to be
        modified to copy. A user of X and Y will not be able to upgrade to a new version of Y until
        X has been modified. Where many subsystems are used this can cause cascading delays.
        Even where the 'multiple supplier problem' does not exist, this can lead to cascading
        modifications of code and to large amounts of recompilation.
        Such problems would cause people to avoid using the exception specification mechanism
        or else subvert it [Koenig, 1990]
        #+END_QUOTE

  - Java Checked Exceptions
    - [[https://medium.com/javarevisited/its-2022-should-we-give-up-using-checked-exception-176429e05d4b][The exception mechanism of Java has been controversial. | by lance | Javarevisited | Medium]]

    - [[http://articles.vconst.com/2009/08/error-handling-and-exceptions-in-java.html][Constantine's Column: Error Handling and Exceptions in Java]]

    - [[https://www.oracle.com/technical-resources/articles/enterprise-architecture/effective-exceptions-part1.html][Effective Java Exceptions]]
      - 
         #+begin_quote
         After all, compiler-imposed constraints on data types encouraged rigorous coding and precise thinking.
         Compile-time type checking helped prevent nasty surprises at run-time.
         Compile-time exception checking would work similarly, reminding developers that a method had potential
         alternate outcomes that needed to be addressed.
         #+end_quote
      -
        #+begin_quote
        To programmers, it seemed like most of the common methods in Java library classes declared checked exceptions
        for every possible failure. For example, the ~java.io~ package relies heavily on the checked exception ~IOException~.
        At least 63 Java library packages issue this exception, either directly or through one of its dozens of subclasses.

        An I/O failure is a serious but extremely rare event. On top of that, there is usually nothing your code can do
        to recover from one. Java programmers found themselves forced to provide for ~IOException~ and similar unrecoverable
        events that could possibly occur in a simple Java library method call. Catching these exceptions added clutter to
        what should be simple code because there was very little that could be done in a catch block to help the situation.
        Not catching them was probably worse since the compiler required that you add them to the list of exceptions your
        method ~throws~. This exposes implementation details that good object-oriented design would naturally want to hide.

        This no-win situation resulted in most of the notorious exception handling anti-patterns we are warned about today.
        It also spawned lots of advice on the right ways and the wrong ways to build workarounds.

        Some Java luminaries started to question whether Java's checked exception model was a failed experiment.
        Something failed for sure, but it had nothing to do with including exception checking in the Java language.
        The failure was in the thinking by the Java API designers that most failure conditions were the same and could be
        communicated by the same kind of exception.
        #+end_quote
      - Talks about two classes of errors: contingency and fault
        - contingencies are expected failures that the caller should be able to handle
        - faults are generally programming bugs / pre-condition failures
      - Contingencies are usually handled relatively close to where they are thrown
        they are part of the return-value / result of a given function call
        - "A contingency represents an alternative method result that is just as important as the principal return result."
      - Faults are usually handled with a high-level "Fault Barrier" that simply logs the
        fault and continues.
      - Recommendation is that contingencies use checked exceptions, while faults use unchecked exceptions
        - Programmers don't want to have to document in the API of all callers that there might be an
          exception thrown due to a programmer bug in the implementation which the caller won't
          have any idea how to handle.

      - Rules for use:
        - The fault barrier method must reside at the head of a graph of method calls that traverses the participating classes.
        - They must all use unchecked exceptions to signify fault contiditions.
        - They must all use the specific unchecked exception types that the fault barrier is expecting to receive.
        - They all must catch and translate checked exceptions from lower methods that are deemed to be faults in their execution context.
        - They must not interfere with the propagation of fault exceptions on their way to the barrier.

    - [[https://markonovakovic.medium.com/checked-exceptions-vs-either-6468ce94c0c9][Checked exceptions vs Either. Exploring the pros and cons of Javas | by Marko Novakovic | Medium]]

    - [[https://softwareengineering.stackexchange.com/questions/420898/why-do-checked-exceptions-i-e-value-or-error-return-values-work-well-in][language design - Why do "checked exceptions", i.e., "value-or-error return values", work well in Rust and Go but not in Java? - Software Engineering Stack Exchange]]

    - [[https://stackoverflow.com/questions/613954/the-case-against-checked-exceptions][java - The case against checked exceptions - Stack Overflow]]
      - checked exceptions are about being able to communicate errors between layers

      - 

    - [[https://www.artima.com/articles/the-trouble-with-checked-exceptions][artima - The Trouble with Checked Exceptions]] (Bill Venners, Bruce Eckel, Anders Hejlsberg)
      - Versioning
        - Adding a new exception is a breaking change for client code in many cases.
          - Would need to add a new method with a wider exception specification.
          - Without checked exceptions you are breaking the client code silently anyway
            - In lots of cases people don't care - they want to let most errors propagate up to some top-level handler.

      - Scalability
        - In small, checked exceptions are enticing, dealing with small numbers of errors.
        - At scale, high-level ends up with an unwieldy list of exceptions it might throw
          - e.g. code that calls into 4-5 different subsystems that each throw 4-10 exception types can easily end up with 40 exceptions they might need to list
            in their throw-specification
            - Also, adding a new exception to a leaf API you then need to update all caller throw specifications to add this
              new exception.
          - so people end up just writing ~throws Exception~ which then circumvents the benefits of checked exceptions
          - or they end up writing ~try { ... } catch(Exception) {}~ and just suppressing the errors - leading to worse outcomes
            
    - [[https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html][Unchecked Exceptions  The Controversy (The Java Tutorials > Essential Java Classes > Exceptions)]]
      - Inheritance hierarchy:
        - ~Object~
          - ~Throwable~
            - ~Error~ - serious problems that a resonable application should not try to catch (e.g. VM error, assertion failure)
            - ~Exception~
              - ~RuntimeException~ - 
                - all user unchecked exceptions go here
              - all user checked exceptions go here
      - RuntimeException, Error and their subclasses are "unchecked exceptions"
        - language doesn't require unchecked exceptions to be listed in the throw specification, or caught
      - "Any Exception that can be thrown by a method is part of the method's public programming interface."
        "Those who call a method must know about the exceptions that a method can throw so that they can decide what to do about them."
        "These exceptions are as much a part of that method's programming interface as its parameters and return value."
      - Unchecked exceptions represent problems that are the result of a programming problem, and as such, the API client
        code cannot reasonably be expected to recover from them or to handle them in any way.
        e.g. divide by zero, null-pointer dereference, out-of-bounds index
        - In C++ these would be undefined-behaviour / pre-condition failures.
      - "If a client can reasonably be expected to recover from an exception, make it a checked exception.
         If a client cannot do anything to recover from the exception, make it an unchecked exception."
        - These broadly break down to pre-condition violations and recoverable errors.

    - 

  - Rust error handling
    - [[https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html][To panic! or Not to panic! - The Rust Programming Language]]
      -
        #+begin_quote
        You could call ~panic!~ for any error situation, whether theres
        a possible way to recover or not, but then youre making the
        decision that a situation is unrecoverable on behalf of the
        calling code. When you choose to return a ~Result~ value, you
        give the calling code options. The calling code could choose
        to attempt to recover in a way thats appropriate for its
        situation, or it could decide that an ~Err~ value in this case
        is unrecoverable, so it can call ~panic!~ and turn your
        recoverable error into an unrecoverable one. Therefore,
        returning ~Result~ is a good default choice when youre defining
        a function that might fail.
        #+end_quote



  - Previous papers relating to customisation points / overload-sets / ADL
   - N2216 	07-0076 	Report on language support for Multi-Methods and Open-Methods for C++ (2007)
    - P0119R1   Overload sets as function arguments
    - P0084R1   Emplace Return Type (Revision 1)
      - Might be relevant to call-with-return-value-slot() function idea I had for fibers/coroutines
    - P0534R0   call/cc (call-with-current-continuation): A low-level API for stackful context switching 
    - P0536R0   Implicit Return Type and Allowing Anonymous Types as Return Values
    - P0551R0   Thou Shalt Not Specialize std Function Templates!
    - P0923R0   Modules: Dependent ADL
    - P0934R0   A Modest Proposal: Fixing ADL
  - 2018
    - P0923R1   Modules:Dependent ADL   Nathan Sidwell
    - P1170R0   Overload sets as function parameters
  - 2019
    - P1347R1   Modules: ADL & Internal Linkage
    - P1601R0   Recommendations for Specifying Hidden Friends
    - P1665R0   Tag Based Customization Point Functions
    - P1772R0   Variadic overload sets and overload sequences
    - P1779R0   ABI isolation for member functions
    - P1772R1   Variadic overload sets and overload sequences
    - P1779R2   ABI isolation for member functions
    - P1787R3   Declarations and where to find them
    - P1965R0   Blanket Wording for Specifying "Hidden Friends"
    - P2123R0   interfaces: A Facility to Manage ABI/API Evolution
    - P2191R0   Modules: ADL & GMFs do not play together well (anymore)
    - P2279R0   We need a language mechanism for customization points
    - P2538R1   ADL-proof std::projected
    - P2600R0   A minimal ADL restriction to avoid ill-formed template instantiation
    - P2602R0   Poison Pills are Too Toxic
    - P2602R1   Poison Pills are Too Toxic
    - P2893R0   Variadic Friends
    - 

      
  - Previous papers relating to contracts
    - 2013
      - N3604 - Centralized Defensive-Programming Support for Narrow Contracts
      - N3753 - Centralized Defensive-Programming Support for Narrow Contracts (Revision 1)
      - N3818 - Centralized Defensive-Programming Support for Narrow Contracts (Revision 2)
    - 2014
      - N3877 - Centralized Defensive-Programming Support for Narrow Contracts (Revision 3)
      - N3997 - Centralized Defensive-Programming Support for Narrow Contracts (Revision 5)
      - N4075 - Centralized Defensive-Programming Support for Narrow Contracts (Revision 5)
      - N4110 - Exploring the design space of contract specifications for C++
    - 2015
      - N4378 - Language Support for Contract Assertions 
      - N4379 - FAQ about N4378, Language Support for Contract Assertions
      - N4435 - Proposing Contract Attributes       
      - P0147R0         The Use and Implementation of Contracts
      - P0166R0         Three interesting questions about contracts
    - 2016
      - P0380R0         A Contract Design
      - P0380R1         A Contract Design
    - 2017
      - P0542R0         Support for contract based programming in C++
      - P0542R1         Support for contract based programming in C++
      - P0542R2         Support for contract based programming in C++
    - 2018
      - P0542R3         Support for contract based programming in C++
      - P0542R4         Support for contract based programming in C++
      - P1320R0         Allowing contract predicates on non-first declarations
      - P1321R0         UB in contract violations
      - P1323R0         Contract postconditions and return type deduction
    - 2019
      - P1290R1         Avoiding undefined behavior in contracts
      - P1323R1         Contract postconditions and return type deduction
      - P1426R0         Pull the Plug on Contracts? 
      - P1429R0         Contracts That Work
      - P1443R0         SG14: Low Latency Meeting Minutes 2018/07/11 - 2019/01/09
      - P1429R1         Contracts That Work
      - P1606R0         Requirements for Contract Roles
      - P1607R0         Minimizing Contracts
      - P1625R0         Contracts: why the house is not on fire (i.e. why the status quo is tolerable)
      - P1486R0         United Amendment to Contracts Facility for C++20
      - P1486R1         United Amendment to Contracts Facility for C++20
      - P1487R0         User Experience with Contracts That Work
      - P1670R0         Side Effects of Checked Contracts and Predicate Elision
      - P1671R0         Contract Evaluation in Constant Expressions
      - P1680R0         Implementing Contracts in GCC
      - P1704R0         Undefined functions in axiom-level contract statements
      - P1710R0         Adding a global contract assumption mode
      - P1711R0         What to do about contracts?
      - P1728R0         Preconditions, axiom-level contracts and assumptions -- an in depth study
      - P1730R0         Adding a global contract assumption mode
      - P1743R0         Contracts, Undefined Behavior, and Defensive Programming
      - P1744R0         Avoiding Misuse of Contract-Checking
      - P1769R0         The "default" contract build-level and continuation-mode should be implementation-defined
      - P1773R0         Contracts have failed to provide a portable "assume"
      - P1774R0         Portable optimisation hints
      - P1782R0         Local contract restrictions
      - P1786R0         Adding a global contract assumption mode
      - P1429R3         Contracts That Work
      - P1607R1         Minimizing Contracts
      - P1807R0         An Overview of Contracts Papers for Cologne
      - P1812R0         Axioms should be assumable: a minimal fix for contracts
      - P1823R0         Remove Contracts from C++20
      - P1995R0         Contracts - Use Cases
      - P2064R0         Assumptions
      - P1995R1         Contracts - Use Cases
      - P2032R0         Contracts - What Came Before
      - P2114R0         Minimial Contract Use Cases
      - P2176R0         A different take on inexpressible conditions
      - P2185R0         Contracts Use Case Categorization
      - P2053R1         Defensive Checks Versus Input Validation
      - P2339R0         Contract violation handlers
      - P2358R0         Defining Contracts
      - P2388R0         Abort-only contract support
      - P2388R1         Minimum Contract Support: either Ignore or Check_and_abort
      - P2388R2         Minimum Contract Support: either Ignore or Check_and_abort
      - P2388R3         Minimum Contract Support: either No_eval or Eval_and_abort
      - P2466R0         The notes on contract annotations
      - P2659R0         A Proposal to Publish a Technical Specification for Contracts
      - P2660R0         Proposed Contracts TS
      - P2661R0         Miscellaneous amendments to the Contracts TS
    - 2023
      - P2831R0         Functions having a narrow contract should not be noexcept
      - P2834R0         Semantic Stability Across Contract-Checking Build Modes
      - P2837R0         Planning to Revisit the Lakos Rule 
      - P2852R0         Contract violation handling semantics for the contracts MVP
      - P2853R0         Proposal of std::contract_violation
      - P2858R0         Noexcept vs contract violations
      - P2861R0         The Lakos Rule: Narrow Contracts And `noexcept` Are Inherently Incompatible
      - P2521R4         Contract support -- Record of SG21 consensus
      - P2487R1         Is attribute-like syntax adequate for contract annotations?
      - P2811R5         Contract-Violation Handlers
      - P2811R6         Contract-Violation Handlers
      - P2811R7         Contract-Violation Handlers
      - P2877R0         Contract Build Modes and Semantics
      - P2834R1         Semantic Stability Across Contract-Checking Build Modes
      - P2885R0         Requirements for a Contracts syntax
      - P2920R0         Library Evolution Leadership's Understanding of the Noexcept Policy History
      - P2947R0         Contracts must avoid disclosing sensitive information
      - P2949R0         Slides for P2861R0: Narrow Contracts and `noexcept` are Inherently Incompatable
      - P2521R5         Contract support -- Record of SG21 consensus
      - P2885R1         Requirements for a Contracts syntax
      - P2890R0         Contracts on lambdas
      - P2894R0         Constant evaluation of Contracts
      - P2896R0         Outstanding design questions for the Contracts MVP
      - P2935R0         An Attribute-Like Syntax for Contracts
      - P2954R0         Contracts and virtual functions for the Contracts MVP
      - P2957R0         Contracts and coroutines
      - P2932R0         A Principled Approach to Open Design Questions for Contracts
      - P2935R2         An Attribute-Like Syntax for Contracts
      - P2961R0         A natural syntax for Contracts
      - 
        


