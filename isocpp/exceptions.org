# -*- mode: org; org-html-htmlize-output-type: css -*-
#+TITLE: D3166R0: Static Exception Specifications
#+AUTHOR: Lewis Baker
#+EMAIL: lewissbaker@gmail.com
#+DATE: 2024-03-01
#+OPTIONS: html5-fancy
#+OPTIONS: tasks:nil
#+EXPORT_FILE_NAME: D3166R0
#+EXPORT_EXCLUDE_TAGS: noexport,todo

| Document | *D3166R0*                             |
| Date     | *2024-03-01*                          |
| Reply To | *Lewis Baker <lewissbaker@gmail.com>* |
| Audience | *EWG*, *SG21*, *SG14*                 |

* Abstract

Exceptions are the C++ language's primary tool for communicating errors to callers.
However, the dynamic exceptions we have today come with runtime overheads that
cause many people to avoid using, or even completely disable exceptions in domains
that are performance-sensitive.

This paper proposes adding new language features for annotating functions with
additional type information, in the form of static exception specifications,
that should allow exception objects to be returned on the stack with performance
similar to that of normal return-paths.

These features include:
- Adding the ability to add ~throw()~ specifiers to function declarations as a way of
  declaring the complete set of exception types that the function may exit with.
- Allow declaring a function as ~throw(auto)~ to deduce the set of exception types
  that may be thrown based on the body of the function.
- Add a new ~declthrow()~ syntax for querying the set of exceptions that an expression
  may exit with.
- Add a ~template catch~ syntax to allow writing exception handlers that are templates
  which are instantiated based on the set of exception types that may be thrown from the
  associated try-block.
- Enable static checking of exception specifications for function definitions with
  a static ~throw()~ specifier to ensure that they can not exit with exceptions not listed
  in their throw specification. Functions definitions with a ~throw(auto)~, ~throw(...)~
  or ~noexcept~ specifier are not checked, even if they call functions with static
  exception specifications.

This paper has the following main goals:
1. Eliminate the performance-related reasons for not using exceptions
   in embedded and other performance critical code.
2. Enable the use of exception-based error handling in freestanding environments
   by enabling exceptions to be thrown/caught without a need for heavy-weight
   runtime components or dynamic allocation.
3. Eliminate classes of bugs relating to unhandled exceptions and error code-paths
   by making it possible to identify at compile-time code that is failing to
   handle some exception-types that might be thrown and make it ill-formed.

This proposal is still in the early stages and is being published to solicit feedback
on direction and also on potential interaction with other in-flight papers, such
as contracts and discussions around ~noexcept~ policy in the standard library.

* Synopsis

Example 1: Explicit throw specifications
#+begin_src c++
void throws_nothing() throw(); // empty static exception specification - equivalent to noexcept
void throws_a_b() throw(A, B); // static exception specification
void throws_any() throw(...);  // dynamic exception specification - equivalent to noexcept(false)
#+end_src

Example 2: Deduced throw specifications
#+begin_src c++
  template<std::ranges::range R, typename F>
  requires std::invocable<F&, std::ranges::range_reference_t<R>>
  void for_each(R rng, F func) throw(auto) {
    for (auto&& x : rng) {
      func(static_cast<decltype(x)>(x));
    }
  }
#+end_src

Example 3: Querying the potentially-thrown exception types + use of template handlers
#+begin_src c++
std::variant<std::monostate, declthrow(throws_a_b())...> err; // variant<monostate, A, B>
try {
  throws_a_b();
} template catch (auto& e) { // instantiated for each static exception type { A , B }
  err.template emplace<decltype(auto(e))>(std::move(e));
}
#+end_src

Example 4: Checked exception specifications - Calling ~throw(A,B)~ function from ~throw()~ function
#+begin_src c++
  void nothrow_caller() throw() {
    throws_a_b(); // Ill-formed: A and B not handled locally and not listed in throw specification

    try {
      throws_a_b(); // Ill-formed: A not handled locally and not listed in throw specification
    }
    catch (B) {}

    try {
      throws_a_b(); // OK: all potentially-thrown exceptions are handled locally
    }
    catch (A) {}
    catch (B) {}
  }
#+end_src

Example 5: Checked exception specifications - Calling ~throw(...)~ function from ~throw()~ function
#+begin_src c++
  void nothrow_caller() throw() {
    throws_any(); // Ill-formed: dynamic exception not handled locally

    try {
      throws_any(); // OK
    }
    catch(...) {}
  }
#+end_src

Example 6: Checked exception specifications - Calling ~throw(A,B)~ function from ~throw(A)~ function
#+begin_src c++
  void caller() throw(A) {
    throws_a_b(); // Ill-formed: B not handled locally and not listed in throw specification

    try {
      throws_a_b(); // OK
    }
    catch (B) {}

    try {
      throws_a_b(); // OK
    }
    catch (A a) {
      if (!can_handle(a)) throw; // OK: rethrows A, which is allowed
    }
    catch (B) {}
  }
#+end_src

Example 7: Checked exception specifications - Calling ~throw(...)~ function from ~throw(A)~ function
#+begin_src c++
  void caller() throw(A) {
    throws_any(); // Ill-formed: dynamic exception not handled locally

    try {
      throws_any(); // OK - all exceptions handled
    }
    catch (const A&) {
      throw; // Ill-formed: Might rethrow type derived from A (unless A is final)
    }
    catch(...) {}

    try {
      throws_any(); // OK - exceptions handled
    }
    catch(const A& a) {
      throw a; // OK - only throws A - slices types derived from A
    }
    catch(...) {}
  }
#+end_src

Example 8: Simpler alternative to ~std::expected~ / ~std::variant~ code
#+begin_src c++
std::expected<X, E1> get_x() noexcept;
std::expected<Y, E2> get_y() noexcept;

std::expected<Z, std::variant<E1, E2>> make_z() noexcept {
  auto x = get_x();
  if (!x) return {std::unexpect, std::move(x).error() };
  
  auto y = get_y();
  if (!x) return {std::unexpect, std::move(y).error() };
  
  return {std::in_place, std::move(x).value(), std::move(y).value());
}

std::expected<Z, std::variant<E1, E2>> make_z_p2561() {
  return {std::in_place, x??, y??}; // ?? error-propagation operator from P2561
}

void consumer() noexcept {
  auto result = make_z();
  if (!result) {
    std::visit(overload(
      [&](E1& e) noexcept { /* handle E1 */ },
      [&](E2& e) noexcept { /* handle E2 */ }),
      result.error());
    return;
  }
  
  Z& z = result.value();
  // use z
}
#+end_src
can instead be written using static exceptions, with equivalent or better performance:
#+begin_src c++
  X get_x() throw(E1);
  Y get_y() throw(E2);

  Z make_z() throw(E1, E2) {
    return Z{get_x(), get_y()}; // allows aggregate initialization
  }

  void consumer() throw() {
    try {
      Z z = make_z();
      // use z
    }
    // Note: Mutable reference is safe since static exception objects are not shared.
    catch (E1& e) { /* handle E1 */ }
    catch (E2& e) { /* handle E2 */ }
  }
#+end_src

Example 9: Guarantees deterministic local throw/catch
#+begin_src c++
  void example(std::vector<std::vector<std::string>> vec) {
    struct InvalidString {};
    try {
      for (auto& strings : vec) {
	for (auto& string : strings) {
	  if (!is_valid(string))
	    throw InvalidString{}; // cost equivalent to local goto
	  // process string...
	}
      }
    }
    catch (InvalidString) {
      // handle invalid input
    }
  }
#+end_src

* Overview

This paper proposes introducing /static exception specifications/, repurposing the
~throw()~ specification syntax which was removed in C++17, to provide additional
type-information about the closed-set of possible exception types that might be
thrown from a function. The proposed design tries to avoid the shortcomings of the
previous design of throw-specifications by requiring that checks are performed
at compile-time instead of at runtime.

Function definitions with a ~throw()~ specification are checked by the
compiler at compile-time to ensure that there are no code-paths that might allow
an exception to exit the function that would violate the declared throw-specification,
rather than dynamically check this at runtime and terminate.
Functions that fail this static exception specification check are ill-formed.

While we are yet to gain implementation experience for this proposal, the design
for static exception specifications should permit implementation strategies that
can achieve efficiency of throwing exceptions close to that of normal return values,
with exception objects able to be returned on the stack or in registers using
similar conventions to normal return-values.

The proposed design is also similar in many ways to the design proposed in
[[https://wg21.link/P0709R4][P0709R4 - Zero-overhead deterministic exceptions: Throwing values]].
However, it differs in a number of key areas:
- It allows users to specify a list of multiple exception types they might throw
  in the ~throw()~ specifier rather than limiting them to throwing only ~std::error~ or,
  in the proposed extension, a single error type.
- It does not require the introduction of a special ~std::error~ type
  that must be used to wrap all exceptions-as-values. Such a type could
  potentially be used in conjunction with this proposal via ~throw(std::error)~,
  but would require explicit conversion between exception types at function boundaries.
- It does not require falling back to dynamic-allocation when propagating
  exception types that do not fit in the small-object optimisation built into P0709's proposed
  ~std::error~ type. All static exception objects are passed in automatic storage duration
  storage so can be as large or as small as you like. Throwing an empty exception object
  does not need to consume a register, throwing a large object does not require dynamic
  allocation.
- It provides the ~template catch~ facility to allow generically handling multiple
  static exception types - something P0709 does not provide as it expects you to
  just be propagating a single static exception type, ~std::error~.

This design does not change the semantics of existing C++23 code. It can be
incrementally adopted throughout a code-base by annotating functions with
static exception specifications using the ~throw()~ syntax where appropriate
in much the same way that code-bases could incrementally adopt ~noexcept~
specifiers in their code-base when they were introduced.

This proposal aims to enable use of static exception specifications in freestanding
environments which were traditionally unable to use exceptions. Static exception-specifications
provide enough type-information to the compiler to allow exceptions to be thrown, propagated,
caught and rethrown with minimal runtime machinery - without need for dynamic-allocation,
runtime type information, or dynamic_cast.

If you can avoid using facilities that require dynamic exceptions, such as
~std::current_exception()~ and ~throw;~ expressions that appear outside of the lexical
scope of handlers, then the only dependency on thread-local storage is ~std::uncaught_exceptions()~,
which is not required in a lot of projects and could potentially be omitted from freestanding environments.
See the section on [[id:58f857b8-ec19-4dd5-ac5d-2efa62ebac55][Avoiding dependencies on thread-locals]] for more details.

The ability to enable compile-time checking that all exceptions are handled and that
there are no hidden calls to ~std::terminate()~ inserted by the compiler due to unhandled
exceptions helps to ensure that programs do not unknowingly leave certain error conditions
unhandled.

This may also help to remove some barriers to C++ exceptions being used in environments
for which termination should only be performed in the presence of unrecoverable errors.
Authors of functions that have checked exception specifications can still explicitly catch
exceptions that represent fatal error conditions and insert an explicit call to ~std::terminate()~
to get the same behaviour as the dynamic ~noexcept~ behaviour - only now these calls to
~std::terminate()~ appear in source code and so can be more easily audited than the implicit
ones the compiler was inserting.

This paper is structured into the following sections:
- *[[id:1bf2ccdf-cee6-4226-beec-3de59d57472d][Motivation]]* - motivation for addition of this feature
- *[[id:200309b8-49c7-4497-a071-bee17689dd2d][Proposal]]* - describes the design of the features this paper is proposing
- *[[id:62c9aff2-91ea-4bb4-a3f4-b01c3ab593ef][Prior Work]]* - a comparison of this work to prior-art in this area. e.g. to Java, Midori, C++98
- *[[id:e6228e14-fde7-4217-b0c8-a9b7fb781ac5][Design Discussion]]* - further discussion of important design points, alternatives, future work, etc.
- *[[id:01aa3390-7ae3-4f75-831e-d7f22c40d5ae][Implementation Strategies]]* - discusses potential strategies implementations could use to implement this design efficiently

* Motivation
:PROPERTIES:
:ID:       1bf2ccdf-cee6-4226-beec-3de59d57472d
:END:

*************** TODO Add better motivation that calls out the benefits of this design
- Enables exceptions to be returned:
  - with similar performance to normal return values
  - without need for dynamic allocation - either on stack or in registers
  - without need for run-time type information and dynamic handler matching
  - without need for exception-tables in the binary
  - with deterministic runtime performance
- This enables exception use in environments that traditionally have had to
  disable exceptions due to the overhead
  - Safety-critical embedded systems
  - Real-time systems such as games
- Enables ability to check that all exceptions thrown are handled and that
  there are no unhandled exceptions 
*************** END

The paper [[https://wg21.link/P0709][P0709]] "Deterministic exceptions: throwing values" by Herb Sutter
contains detailed motivation for improving exceptions, and covers the background
and history of exceptions in C++ better than I could do here.

I agree with much of the philosophy and motivations expressed in P0709 and have
used them as inspiration for the design for this paper. However, this paper takes
a different approach to solving the issues raised - hopefully one that is more
closely aligned with the goals and principles of C++.

Key points:
- Exceptions are expensive on many platforms for error-handling that is not rare.
  - In some cases, taking the exceptional path is 100-1000x slower than the normal
    return-path.
  - This leads to people using alternative error-handling mechanisms.
    e.g. ~std::error_code~, ~boost::outcome~, ~std::expected~, ~std::optional~, etc.
  - These alternative error-codes aren't universally usable in all places
    e.g. constructors, overloaded operators
  - Some don't force users to handle the errors - making their use error-prone.
  - The growing number of error-handling mechanisms in use means it is harder to
    integrate components that use different error-handling techniques.
  - The alternatives can also incur runtime overhead
    - The result is type-erased, e.g. in a variant-like type, and requires branching
      to the code-path to handle each of the cases.
    - They inhibit copy-elision of returned results
      - Results must be packed in a container (like ~std::expected~) and then unpacked by
	the caller.
      - This can result in many extra copies/moves of both success-results and error-results
	compared to returning the value itself and using exceptions.
    - They can require objects to have an invalid state.
      e.g. a constructor with an ~error_code~-out-parameter, or a subsequent query to
      ask if the object construction succeeded.
      This may require additional state to be stored in the object, or additional
      pre-conditions to be added to methods on that object.

- Exceptions often have non-deterministic overhead which makes them unsuitable for use in
  environments that need to provide real-time guarantees.
  - There are some workarounds for this, but they are not widely used / have some
    limitations.
    e.g. see Gibbs and Stroustrup's paper on "Fast Dynamic Casting" which assigns prime numbers
    to each unique exception-type and uses integer division to determine castability.
    
- Exceptions have hidden control-flow that makes it hard to know if you have handled
  all possible error-cases.
  - Adding a new exception that might be thrown from a function is potentially a breaking
    change, but there is no guarantee that existing code calling this function will stop
    compiling - you may just end up with a runtime error that then goes unhandled.

This paper explores language changes that should allow exceptions to be several
orders of magnitude faster on error-paths than major existing implementations -
performance of the order of that of a normal return-value, without overly penalising
execution cost of the success path.
- Exceptions may be returned on the stack or in registers as part of the
  calling convention.
- Exiting a function with an exception can directly return to the caller's
  handler/unwind code-path instead of to a switch. There is no need to lookup
  exception tables and dynamically find the right handler.
  
* Proposal
:PROPERTIES:
:ID:       200309b8-49c7-4497-a071-bee17689dd2d
:END:

** Overview

The key components of this proposal are as follows:

It proposes (re)adding ~throw()~ specifiers which can be used to declare a function
as having either a static exception specifier or dynamic exception specifier.

It proposes adding the ~throw(auto)~ syntax for deducing the throw-specification of a
function from its definition, which must be visible before use of the function.

It proposes rules for statically checking at compile-time that the bodies of function
definitions with ~throw()~ specifiers do not violate their exception specification.
Failure to handle all such cases or declare that you forward on the exception are
ill-formed.

It proposes adding the ~declthrow(expr)~ syntax for querying what set of exception
types might be thrown from a particular exception.

It proposes adding the ~template catch~ syntax to allow catching static exceptions
thrown from the associated try-block, allowing a way to use the same handler template
to handle different types, without the need for type-erasing the exception.

** (Re)Adding ~throw()~ specifiers

The original design of exceptions in C++ included a throw-specification that allowed
the programmer to declare a list of exception types that a function might exit with, by
specifying the ~throw(E1, E2, E3)~ specifier after the function parameter list.

For example:
#+begin_src c++
  void Example(const std::string_view& path)
       throw(std::bad_alloc, std::system_error);
#+end_src

The throw-specification, as originally designed, had a number of issues that limited
its usability and utility, and in time most people came to avoid the feature as its
pitfalls outweighed the benefits of using it.

The following is a summarized list of the issues:
- The runtime/code-size overhead cost due to need to dynamically-check for unhandled
  exception types.
- The ~std::unexpected()~ notification mechanism did not lend itself to recovery from
  unhandled exceptions.
- MSVC (at the time) did not enforce the contract - a function with a ~throw()~
  specification could still throw exceptions of types other than those mentioned in the
  throw-specification, but the compiler would optimise based assumptions that it did not.
  This made the feature dangerous to use as it would result in undefined behaviour if
  the programmer failed to adhere to the throw-specification.

In C++11, we introduced ~noexcept~, initially as a tool needed to restore the strong
exception-safety guarantee to types like ~std::vector~ after the introduction of
move-constructors.

The original throw-specifications were deprecated along with the introduction of
~noexcept~ and, in C++17, were removed from the C++ language. This frees up the syntax
for being reused for a similar purpose, albeit with an improved design that tries to
avoid the pitfalls of the original design.

** Static exception specifications

A /static exception specification/ is an exception specification that lists a finite
list of possible exception types that a function may exit with.

A /non-empty static exception specification/ is a static exception specification that
contains one or more exception types listed in the throw specification.

A /dynamic exception specification/ is an exception specification that allows the function
to exit with any exception type.

A /throw-specifier/ can be used to declare a function with either a static or dynamic
exception specification.

For example:
#+BEGIN_SRC c++
   void f() throw();    // static-exception-specification with empty exception type list
			// equivalent to noexcept(true)

   void g() throw(...); // dynamic-exception-specification
			// equivalent to noexcept(false)

   void g() throw(std::any_exception); // equivalent to throw(...)
                                       // see section on declthrow for rationale

   void h() throw(E1);     // throws only E1  (static-exception-specification)
   void i() throw(E1, E2); // throws either E1 or E2
   void j() throw(Es...);  // throws one of the types in pack Es...

   void k() throw(auto);   // set of exceptions it could throw is deduced from body of function,
			   // much like using decltype(auto) to deduce the return-type.
#+END_SRC

A declaration signature of ~void foo() throw();~ is equivalent to ~void foo() noexcept;~.
However, a function definition with a ~throw()~ specification differs from one with ~noexcept~
in that the definition is ill-formed if an exception can possibly escape the function,
whereas ~void foo() noexcept~ detects such a failure to fulfil its contract at runtime and terminates.
i.e. throw-specifications are statically checked/enforced rather than dynamically checked/enforced.

Similarly, ~void bar() throw(E1, E2)~ is ill-formed if any exception types other than ~E1~ or ~E2~
can possibly escape the body of the function. The aim is to avoid the compiler inserting any hidden
calls to ~std::terminate~ in the body of the function.

It is permitted to declare a function with the specifier ~noexcept(true)~ and define it with
the specifier ~throw()~, and vice versa. Doing so allows you to have the compiler statically
check that there are no unhandled exceptions exiting the function body that might implicitly
result in a call to ~std::terminate~.

Similarly, it is permitted to declare a function with the specifier ~noexcept(false)~ and define
it with the specifier ~throw(...)~, and vice versa. However, there are no differences in semantics
of the definition between these two syntaxes - they are pure aliases for each other.

A forward declaration of a function with a non-empty static exception specification on its
definition must have an equivalent static exception specification on the declaration.

*** Types in a throw-specification form an unordered set

The order of the types in the throw-specification is not significant. The throw-specification
declares an unordered set of types that may be thrown, rather than an ordered list of types.

Two throw-specifications are equivalent if they contain the same set of types, regardless
of the order in which those types are listed in the source code.

It is valid to list a type multiple times in a throw-specification.
Any duplicates are ignored/eliminated by the compiler.

Eliminating duplicates is helpful when composing lists of exception types
from multiple ~declthrow~ expressions that have overlap in the set of exceptions
they may throw - see the section "Querying the throw-specification".

For example, the following functions all have the same exception specification:
#+BEGIN_SRC c++
void f() throw(E1, E2);
void g() throw(E2, E1);
void h() throw(E1, E1, E2);
#+END_SRC

The rationale for making the set of exceptions an unordered set rather than an ordered list is
to reduce the chance of annoying incompatibilities when casting a function to a function-pointer.

For example:
#+begin_src c++
  // declared in lib1
  void f() throw(E1, E2);

  // declared in lib2
  void g() throw(E2, E1);


  void (*func)() throw(E1, E2) = &f;
  if (cond) {
    func = &g; // It would be annoying if this was ill-formed because the throw-specification had a different order.
  }
#+end_src

*** Handling of ~std::any_exception~ in the throw-specifier

The ~std::any_exception~ type is a type that is handled specially by throw specifications.
See the section "~declthrow~ of a ~throw(...)~ expression" below for a definition of this type.

If the list of types passed as arguments to the ~throw~ specifier contains the type
~std::any_exception~ then the overall exception-specification is evaluated to be
~throw(...)~. i.e. that it can throw any exception type.

For example:
#+begin_src c++
  void a() throw(std::any_exception);       // -> throw(...)
  void b() throw(A, B, std::any_exception); // -> throw(...)
#+end_src

The use of a type ~std::any_exception~ allows template metaprogramming libraries to be
able to conditionally compute a throw-specification that can evaluate as either a static exception specification
or a dynamic exception specification.

For example: Computing a throw-specification to either be ~throw(...)~ or
a static exception specification, depending on a template parameter.
#+begin_src c++
  template<typename... Ts>
  using ...pack = Ts...; // P1858R2 pack alias syntax

  // Generic case
  template<typename T>
  struct _compute_foo_throw_types {
    using ...types = pack<std::any_exception>...; // P1858R2 pack alias syntax
  };

  // When T satisfies the Foo concept, we know it will only
  // fail with two possible exceptions.
  template<typename T>
    requires Foo<T>
  struct _compute_foo_throw_types<T> {
    using ...types = pack<FooError, std::bad_alloc>...;
  };

  template<typename T>
  void foo(const T& x) throw(_compute_foo_throw_types<T>::types...); // P1858R2 pack expansion syntax
#+end_src

Here, the function ~foo<T>~ has an exception specification that is either ~throw(FooError, std::bad_alloc)~ or ~throw(...)~,
depending on the type, ~T~.

*** The types in the throw specification describe all concrete types that may be thrown

One of the prime motivations behind re-adding throw-specifications is to provide the compiler
with enough static type information for it to be able to allocate storage for exceptions that
may be thrown on the stack of the caller, rather than the runtime having to dynamically-allocate
storage for them on the heap. It also allows the compiler to statically dispatch to the appropriate
handler for each possible exception that might be thrown, without requiring dynamic type-matching
or run-time type information.

For this to be possible, the compiler needs to know the size/alignment of all exception types so
that it can reserve storage in the stack-frame for any exception-types which cannot be passed
back to the caller in registers. Similarly, it needs to know which exception types may be passed
back in registers.

This means that we cannot just list an exception base-class in the throw-specification and then
leave the set of possible exception types open to include any type derived from that base-class,
as this would not allow callers to reserve space for any such exception on the stack-frame caller.

For example, a declaration with a throw-specification of ~throw(std::exception)~ does not declare
that the function may throw an exception derived from ~std::exception~, it instead states that
the function may throw an instance of ~std::exception~ (e.g. as if via ~throw std::exception{};~)
and does not exit with any other type of exception.

The implication of this restriction, however, is that any changes to the set of exception-types
that may be thrown by a function is a potential ABI break for that function, requiring, at a minimum,
recompilation of all callers of that function.

This is no different to changing the return-type of a function.
e.g. when adding a new entry to a ~std::variant~-returning function.

This places some interesting constraints on the evolution of such functions, which are discussed
in detail in a later section.

*************** TODO Put a link to the section where evolution of functions is discussed.
*************** END

*** Exception types may not be references, cv-qualified, or void

Types listed in the throw-specification may not be references, cv-qualified, or ~void~.

Static-exception types are returned by-value to callers, so it does not make sense to
support throw-specifications that are references or cv-qualified.

*** Static exception specifications are part of the function type
:PROPERTIES:
:ID:       d0523c1d-8c67-4876-a4f7-183a3fa451f7
:END:

The throw-specification is part of the function type, much like ~noexcept~ specifier is
part of the function type.

In general, a function-pointer with a non-empty static-exception-specification cannot be cast to a
function-pointer type with a different exception-specification. This is because the calling-convention
between such functions may be different, as the list of exceptions that may be thrown forms part of the
ABI of such a function.

Note that it is possible to cast a function directly to a function-pointer type with a wider exception
specification than the function was declared with as the compiler is able to then generate
a thunk that can implement the ABI for the wider specification in terms of the function's native ABI.

Once the identity of the function has been erased as a function-pointer, it is no longer possible for
the compiler to know how to generate such a thunk.

For example:
#+BEGIN_SRC c++
  void f() throw();
  void g() throw(E1);
  void h() throw(E1, E2);
  void i() throw(...);

  void(*pf)() throw() = f; // OK
  pf = g; // ERROR - can't cast g() to a function-ptr with narrower throw-specification
  pf = h; // ERROR - can't cast h() to a function-ptr with narrower throw-specification
  pf = i; // ERROR - can't cast i() to a function-ptr with narrower throw-specification

  void(*pg)() throw(E1) = g; // OK
  pg = f; // OK - points either to f or to thunk that calls f
  pg = h; // ERROR - can't cast h() to a function-ptr with narrower throw-specification
  pg = i; // ERROR - can't cast i() to a function-ptr with narrower throw-specification

  void(*ph)() throw(E1, E2) = h; // OK
  ph = f;  // OK - ph points to f or to a thunk that calls f
  ph = g;  // OK - ph points to a thunk that calls g
  ph = i;  // ERROR - can't cast i() to function-ptr with narrower throw-specification

  void(*pi)() throw(...) = i; // OK
  pi = f; // OK - ph points to f (same as casting noexcept(true) function-ptr to a noexcept(false) one)
  pi = g; // OK - ph points to a thunk that calls g and translates static-exceptions into dynamic-exceptions
  pi = h; // OK - ph points to a thunk that calls g and translates static-exceptions into dynamic-exceptions

  // The same casts are not all valid when casting function-pointers to other function-pointer
  // types instead of functions to function-pointer types.
  pf = pg; // ERROR: Can't cast function-ptr with static throw specification to another function-ptr type
  pf = ph; // ERROR: (same)
  pf = pi; // ERROR: Can't cast throw(...) function-ptr to throw() function-ptr

  pg = pf; // MAYBE?: In some ABIs the calling convention may be compatible.
	   // Do we want to restrict the options here?
  pg = ph; // ERROR: Can't cast to function-ptr with narrower throw-specification
  pg = pi; // ERROR: Can't cast to function-ptr with narrower throw-specification

  ph = pf; // MAYBE?: In some ABIs the calling convention may be compatible.
  ph = pg; // ERROR: Can't cast function-ptr with static exception specification to function-ptr with a
	   // different exception specification. Compiler is unable to generate the necessary thunk here.
  ph = pi; // ERROR: Can't cast to function-ptr with narrower throw-specification.

  pi = pf; // OK: this is same as casting function-ptr with noexcept(true) to function-ptr with noexcept(false)
  pi = pg; // ERROR: Can't cast function-ptr with static exception specification to function-ptr with
	   // different exception specification. Compiler is unable to generate the necessary thunk here.
  pi = ph; // ERROR: Can't cast function-ptr with static exception specification to function-ptr with
	   // different exception specification.
#+END_SRC

The existing type-conversions from pointers to a function with a ~noexcept(true)~ exception specification
to a pointer to a function with a ~noexcept(false)~ exception specification are unchanged.

*** Deducing throw-specifications from a function signature

It is permitted to allow template arguments to be deduced from the throw-specification
in a function-signature.

For example:
#+begin_src c++
  template<typename Ret, typename... Args, typename... Errors>
  void Call(Ret(*func_ptr)(Args...) throw(Errors...));

  void a() throw();
  void b() throw(int);
  void c() throw(std::bad_alloc, std::system_error);
  void d() throw(...);

  Call(&a); // deduces Errors to be the empty pack.
  Call(&b); // deduces Errors to be the pack: int
  Call(&c); // deduces Errors to be the pack: std::bad_alloc, std::system_error   (in some unspecified order)
  Call(&d); // deduces Errors to be the pack: std::any_exception
#+end_src

This is similar to the ability to deduce whether a function signature is ~noexcept~ or not.

*** ~throw(auto)~ - Deducing exception-specifications from the body of a function

Often, when writing forwarding functions, or function templates, you just want the function to be
transparent to exceptions. i.e. any unhandled exceptions should be propagated to the caller.

In these cases, ideally the function's exception-specification should mirror the set of
exceptions that the body of the function may throw.

With the current facilities available with ~noexcept~, this typically means that you need to
repeat every expression in the body of the function in the ~noexcept~ specifier for that function.

For simple functions this is manageable, although tedious. However, for more complicated function bodies,
or for function-bodies that include conditionally-executed logic guarded by an ~if constexpr~ branch,
the expression needed to compute the ~noexcept~ specifier argument quickly becomes unwieldy.

**** Prior work on deducing exception specifications

This usability issue was identified as a problem back when ~noexcept~ was originally proposed for C++11:
- [[https://wg21.link/N3227][N3227]] - Please reconsider ~noexcept~ (Ottosen, 2010)

There have since been multiple papers exploring the idea of deducing the exception-specification:
- [[https://wg21.link/N3202][N3202]] - To which extent can ~noexcept~ be deduced? (Stroustrup, 2010)
- [[https://wg21.link/N3207][N3207]] - ~noexcept(auto)~ (Merrill, 2010)
- [[https://wg21.link/N4473][N4473]] - ~noexcept(auto)~, again (Voutilainen, 2015)
- [[https://wg21.link/P0133R0][P0133R0]] - Putting ~noexcept(auto)~ on hold, again (Voutilainen, 2015)

It is worth noting that the rationale given in P0133R0 for putting on hold the pursuit of
~noexcept(auto)~ was mainly because it did not solve the whole problem of having to duplicate
the function-body in the declaration - the expressions of the body still needed to be duplicated
in the return-type for SFINAE purposes - and therefore it was not good use of committee time
to pursue a partial solution.

Since this paper was written, we have gained support for concepts in C++20, which goes some way
to simplifying the code needed to write function-templates that eliminates overloads with SFINAE.
However, this only applies when there are existing concepts defined that can be used to constrain
the function. For many cases you still need to duplicate the expressions of the function body
in a ~requires~ clause.

Despite this limitation, I feel there is still benefit to enabling deduced exception specifications
as there are often case that are either covered by concepts or that do not require SFINAE, but that
do need to compute accurate exception specifications.

**** ~throw(auto)~

With the (re)introduction of throw-specifications, the task of computing a correct throw-specification
from a set of sub-expressions becomes even more onerous than for ~noexcept~, as you need to compute
lists of types, not just a boolean expression.

This paper therefore proposes the addition of the ~throw(auto)~ specifier on a function declaration,
as a way of declaring that the compiler should compute the set of exception types that may exit the
function from the definition of the body of the function and use that as the exception-specification
for the function.

For example, consider a hypothetical ~for_each~ function that invokes a function for each
element of a range. If we wanted this function to have the same exception-specification as its
body, it would need to be written with ~noexcept~ specifiers, something similar to the following:
#+begin_src c++
  template<
    std::ranges::range Range,
    typename Func>
  requires std::invocable<Func&, std::ranges::range_reference_t<Range>>
  void for_each(Range&& range, Func&& func)
    noexcept(noexcept(std::ranges::begin(range)) &&
             noexcept(std::ranges::end(range)) &&
             noexcept(++std::declval<std::ranges::iterator_t<Range>&>()) &&
             noexcept(std::declval<std::ranges::iterator_t<Range>&>() != std::declval<std::ranges::sentinel_t<Range>&>()) &&
             noexcept(func(*std::declval<std::ranges::iterator_t<Range>&>()))) {
    auto iterEnd = std::ranges::end(range);
    auto iter = std::ranges::begin(range);
    while (iter != iterEnd) {
      func(*iter);
      ++iter;
    }
  }
#+end_src

And with the ~throw()~ specifier proposed by this paper, in conjunction with the ~declthrow()~ expression
(described in detail in the following section), we would need to write:
#+begin_src c++
  template<std::ranges::range Range, typename Func>
  requires std::invocable<Func&, std::ranges::range_reference_t<Range>>
  void for_each(Range&& range, Func&& func)
    throw(declthrow(std::ranges::begin(range))...,
          declthrow(std::ranges::end(range))...,
          declthrow(++std::declval<std::ranges::iterator_t<Range>&>())...,
          declthrow(std::declval<std::ranges::iterator_t<Range>&>() != std::declval<std::ranges::sentinel_t<Range>&>())...
          declthrow(func(*std::declval<std::ranges::iterator_t<Range>&>()))...)  {
    auto iterEnd = std::ranges::end(range);
    auto iter = std::ranges::begin(range);
    while (iter != iterEnd) {
      func(*iter);
      ++iter;
    }
  }
#+end_src

Having to repeat the body in a different way in the ~noexcept~ or ~throw~ specification like
this is tedious and error-prone. It can be easy to miss an expression, or to later modify the
body of the function and forget to update the throw-specification.

Instead, if we use the proposed ~throw(auto)~ syntax, then the function definition simply becomes:
#+begin_src c++
  template<std::ranges::range Range, typename Func>
  requires std::invocable<Func&, std::ranges::range_reference_t<Range>>
  void for_each(Range&& range, Func&& func) throw(auto) {
    auto iterEnd = std::ranges::end(range);
    auto iter = std::ranges::begin(range);
    while (iter != iterEnd) {
      func(*iter);
      ++iter;
    }
  }
#+end_src

This is much more concise, and is now impossible for the throw-specification to be
inconsistent with the function body.

This facility will greatly simplify the definition of function-templates, in particular the
function-templates that are defined as "expression-equivalent to" some expression.

**** Further motivation for ~throw(auto)~ from P2300 ~std::execution~

One place where having accurate exception specifications (whether ~noexcept~ or ~throw()~ specifications)
is when using the ~std::execution~ facility proposed in P2300.

There are generic async algorithms that can potentially have more efficient implementations if
they know that a given operation cannot fail with an error.

For example ~when_all()~ when passed a collection of senders that cannot complete with an error
the implementation can avoid introducing expensive stop-token synchronization required
for cancelling other child operations if one of them fails. It can also avoid having to reserve
storage for a ~std::exception_ptr~ (or other error type) in the operation-state in order to be
able to stash the error while waiting for the other operations to stop.

So throughout the design of P2300, the specification tries to ensure that, as much as possible, the
noexcept-ness of expresses are passed-through. An unnecessarily conservative ~noexcept(false)~
can result in additional overhead that the compiler cannot inline away like it can for normal
functions.

The ~noexcept~-ness of operations on arguments passed to ~std::execution~ algorithms can influence
the return-type of functions, whether particular overloads of template ~set_error()~ functions
are instantiated, etc. and so can influence the ABI and whether a program is well-formed.

For users using the ~std::execution~ algorithms, using the ~throw(auto)~ syntax would be beneficial
for cases where they are passing lambdas as parameters to these algorithms and they either:
1. Don't care whether or not the expressions could throw, but if they can then just do the right
   thing by having those expressions transparently propagate exceptions, and if they don't then
   do the fast thing.
2. The do care, but they are writing generic code which may or may not be noexcept depending on
   the types it is instantiated with.

For example:
#+begin_src c++
  template<std::execution::sender S>
  auto sender_example(S source) throw(auto) {
    return std::move(source)
      | std::execution::then([](const auto& data) throw(auto) {
	  // do something with data that might throw or might not throw depending on 'data'
	  return some_computed_value;
	})
      | std::execution::let_value([](auto& computed_value) throw(auto) {
	  return std::execution::when_all(
	      sub_operation_1(computed_value),
	      sub_operation_2(computed_value))
	    | std::execution::then([&](auto op_1_result, auto op_2_result) throw(auto) {
	        // ... combine results
		return some_expr;
	      });
	});
  }  
#+end_src

If we want this expression to produce a sender that is no-fail when the lambdas within it
are guaranteed not to throw exceptions then currently you'd have to duplicate the body of
each of the lambdas in the noexcept/throw-specifier. This greatly affects the readability of
this sort of code. Most people are probably not going to bother and so the sender algorithm
will have to pessimistically choose a less-efficient implementation to handle the possibility
that some of those expressions might throw. If the author of the lambdas had access to
~throw(auto)~ then users would probably annotate their lambdas as a matter of course so that
their sender/receiver code runs faster when appropriate.

*** Forward declarations of ~throw(auto)~ functions

The use of ~throw(auto)~ on a forward-declaration of the function requires that the definition
of the function is visible before the use of the function, in the same way that a function
declared with a deduced-return-type requires that the function definition is available before
it's ODR-used. This is consistent with the behaviour of functions with deduced return-types.

For example:
#+begin_src c++
   void example() throw(auto);

   void caller1() {
     example();  // ill-formed. cannot be ODR-used before the definition is seen
   }

   auto* example_ptr = &example; // ill-formed. Type of example() is not known until definition is seen.

   void caller2() throw(declthrow(example())...); // ill-formed. Cannot query the exception specification
                                                  // of example() before it's definition is seen.
   void caller3() noexcept(noexcept(example())); // ill-formed. For same reason.

   void example() throw(auto) {
     if (foo()) {
       do_thing1();
     } else {
       try {
	 do_thing2();
       } catch (Thing2Failure) {
	 do_backup_thing2();
       }
     }
   }

   // Now that the definition is visible and the exception-specification
   // can be deduced, the following things are well-formed.

   void caller4() throw(declthrow(example())...) { // OK
     example(); // OK
   }

   auto* example_ptr2 = &example; // OK
#+end_src

The restriction that the function definition with a deduced exception specification needs to be visible before
it can be used has implications for recursive functions, however.

*** Deduced exception-specifications and recursive functions

Supporting deduced exception-specifications for recursive functions is a challenge.

In theory we could define some language rules that would allow some kinds of recursive
functions to be able to deduce their exception-specification.

For example:
#+begin_src c++
  struct Tree {
    Tree* left;
    Tree* right;
    int value;
  };

  void process_value(int value) throw(InvalidValue);

  void process_tree(Tree& tree) throw(auto) {
    if (tree.left != nullptr)
      process_tree(*tree.left);

    process_value(tree.value); // recursive-call

    if (tree.right != nullptr)
      process_tree(*tree.right);
  }
#+end_src

In this case, the only call that is made that is not recursive is the call to ~process_value()~
which can throw ~InvalidValue~. Therefore, we could in theory deduce that the overall throw
specification is ~throw(InvalidValue)~.

However, it is relatively easy to construct examples where such rules would not work.

Consider:
#+begin_src c++
  void contradiction(int arg) throw(auto) {
    if constexpr (noexcept(contradiction(arg)) {
        throw X{};
    } else {
        if (arg > 0)
             return contradiction(arg - 1);
    }
  }
#+end_src

If the throw-specification is deduced to be ~throw()~ then it throws an exception,
otherwise if it is potentially throwing, it calls itself but no longer contains
any statements that might throw an exception except the call to itself, leading
to a contradiction.

The key feature of this example that makes it problematic is that it is attempting
to query the exception specification before the exception specification has been deduced.

There are also other cases that can directly or indirectly require the exception specification to be known.
Including:
- Calling the function within a ~try { ... } template catch (auto e) { ... }~ block.
  The template catch block needs to know the types that might be thrown in order to
  instantiate the catch-block with the correct types.
- Passing a pointer to the function to an algorithm.
  Constructing the function-pointer type to pass requires knowing the exception specification.
- Forming a call to the function as a sub-expression passed to ~declthrow()~.

There are also further challenges with defining mutually-recursive functions that both
have deduced exception specifications.

*************** TODO Add example of mutually recursive functions with deduces throw specifications
*************** END

While we may be able to eventually define rules that may allow a subset of recursive
function use-cases to have deduced exception specifications, this seems like a relatively
niche case and so this paper proposes that it be left ill-formed for now.

*** Delayed computation of deduced throw specifications

The throw-specification of a function or function-template with a deduced throw specification
need only be computed when the function is selected by overload resolution, or is otherwise ODR-used.

This allows the compiler to avoid instantiating function-templates that are part of an overload
set but that are never selected for overload resolution in order to compute the throw specification.

Taking the address of a function with a deduced throw-specification will also force the compiler
to compute the throw-specification so that the function-pointer type is known.

*** Do we also need ~noexcept(auto)~?

We could also consider adding support for the ~noexcept(auto)~ syntax, in addition to ~throw(auto)~.

The primary semantic difference between these two would be that ~noexcept(auto)~ would only deduce
to either ~noexcept(true)~ or ~noexcept(false)~, (equivalent to ~throw()~ or ~throw(...)~, respectively),
whereas ~throw(auto)~ could also deduce to a non-empty static-exception-specification.

While, in most cases, it would be preferable to use ~throw(auto)~, as that allows the exception-specification
to deduce to the more-efficient static-exception-specification, where possible, there may be some scenarios
where deducing to either ~noexcept(true)~ or ~noexcept(false)~ could be preferable.

The one use-case I can think of is where you want to have the exception-specification deduce to a function
whose signature allows a pointer to that function to be assigned to a function-pointer variable that has a
~noexcept(false)~ exception-specification.

However, this use-case is somewhat tenuous as it would still be possible to directly cast any function
to a signature-compatible function-pointer with a ~noexcept(false)~ exception-specification, it's just
not possible to cast first to a function-pointer with a non-empty static exception specification and
then cast that function-pointer to a function-pointer with a ~noexcept(false)~ exception-specification.

For example:
#+begin_src c++
  void a() throw(A);
  void b() throw(B);

  void c() throw(auto) { // deduces to throw(A, B)
    a();
    b();
  }

  void d() noexcept(auto) { // deduces to noexcept(false)
    a();
    b();
  }

  void execute(void(*func)());

  void example() {
    auto* c_ptr = &c;
    execute(c_ptr); // ill-formed: no conversion from 'void(*)() throw(A,B)' to 'void(*)()'

    auto* d_ptr = &d;
    execute(d_ptr); // OK: 'void(*)() noexcept' implicitly convertible to 'void(*)()'.
  }

  void workaround() {
    execute(static_cast<void(*)()>(c)); // OK: explicit cast to noexcept(false) function-pointer from function
    execute(&d); // OK: Explicit cast not needed
  }
#+end_src

It is an open question whether adding support for ~noexcept(auto)~ in addition to ~throw(auto)~ is
worth the extra complexity/specification effort.

However, in the author's opinion, it is probably not necessary to add in the initial version.
It can be added later if usage experience shows that it would have sufficient value.

** Querying the throw-specification

Once we have the ability to specify static-exception-specifications on functions, there
will inevitably be cases where we want to be able to know what that set of exception
types is in library code.

This paper proposes adding ~declthrow(expr)~ syntax as a way of querying what the list of exceptions
that ~expr~ may exit with.

As the ~declthrow(expr)~ needs to be able to produce a list of types, it is proposed that this
form names a pack of types, which can be expanded as needed using ~declthrow(expr)...~.

Note that the pack of types produced by ~declthrow()~ does not contain any duplicate types.

One of the common expected use-cases is in computing a derived throw-specification
for a function composing other functions such that if their exception specifications change
then so does the exception specification of the function composing them.

For example:
#+begin_src c++
  // Header file
  void PartA() throw(OutOfWidgets);
  void PartB() throw(ProtocolError, Timeout);

  void ComposedOperation() throw(declthrow(PartA())...,
                                 declthrow(PartB())...);

  // ... out-of-line definition in .cpp file

  void ComposedOperation() throw(declthrow(PartA())...,
                                 declthrow(PartB())...) {
    PartA();
    PartB();
    try {
      PartC();
    } catch (...) {
      NothrowFallbackPart();
    }
  }
#+end_src

*** ~declthrow~ of a call to a ~throw(...)~ function

If the expression may exit with a dynamic-exception (i.e. one of the sub-expressions has an exception specification of ~noexcept(false)~ or ~throw(...)~)
then the result of this is a compiler-generated type, much like ~decltype(nullptr)~.

An alias for this type is made available as ~std::any_exception~ in the header ~<exception>~.

#+name: <exception>
#+begin_src c++
  namespace std {
    // NOTE: using pack indexing syntax proposed in P2662R2
    using any_exception = declthrow(static_cast<void(*)()throw(...)>(nullptr)())...[0];
  }
#+end_src

The ~std::any_exception~ type is not constructible or usable as a value.
It is only intended for use as a placeholder/marker for throw-specifications to indicate
a dynamic exception specification.

An alternative design worth considering is having the special type that indicates a
dynamic exception specification to instead be the type ~std::exception_ptr~.

This would be useful in cases where you want to store the exception results in a
~std::variant~. However, it would mean that you could not have an exception specification
that allowed throwing a ~std::exception_ptr~ object itself (instead of rethrowing the
exception object contained within the ~std::exception_ptr~).

This is explored in more detail in the design discussion section.

*************** TODO Insert link to design discussion section about using ~std::exception_ptr~ as ~any_exception~
*************** END

*** Mixed dynamic and static exception specifications

When the operand to ~declthrow()~ contains multiple sub-expressions, some of which have
non-empty static exception specifications and some of which have dynamic exception specifications,
there is the question of what the result of the ~decthrow()~ expression should be.

For example:
#+begin_src c++
  // Given the following
  struct X;
  struct Y;
  int foo() throw(X, Y);
  void bar(int x) throw(...);

  // What types are in the following type-list?
  using types = type_list<declthrow(bar(foo()))...>;
#+end_src

There are two viable options to consider here:
- We say that the overall expression could emit any exception, so the deduced exception
  specification of a function containing this expression would be ~throw(...)~, and so
  the resulting type list should contain only ~std::any_exception~; or
- We list the union of all of the types listed in static exception specifications and
  also list ~std::any_exception~ in the result.

This paper proposes to have the result include both ~std::any_exception~ and the types
from any static exception specifications, for the following reasons:
- It can be used to determine what types might be used to instantiate a ~template catch~
  block (see section on this below) associated with a try-block that contains this expression.
- It is not necessary to reduce the result to ~std::any_exception~ in the ~declthrow()~
  expression if it is being used as the argument to a ~throw~ specifier - the ~throw~
  specifier will do the reduction for you. Reducing the result early is just throwing away
  type information.

For example: With this behaviour we can write the following code
#+begin_src c++
  template<typename T, typename... Ts>
  concept one_of = (std::same_as<T, Ts> || ...);

  template<typename... Es>
  using err_variant = std::variant<std::monostate,
                                   std::conditional_t<std::same_as<std::any_exception, Es>,
                                                      std::exception_ptr, Es>...>;

  err_variant<declthrow(do_foo())...> error;
  try {
    do_foo();
  } template catch (auto e) {
    error.emplace<decltype(e)>(std::move(e));
  } catch (...) {
    if constexpr (one_of<std::any_exception, declthrow(do_foo())...>) {
      error.emplace<std::exception_ptr>(std::current_exception());
    }
  }
#+end_src

*** Order of the exception types

In the section on throw-specifications above it noted that the order of types listed in the throw
specification was not significant, and that the types in the throw-specification formed an
unordered set for the purposes of function-type-equivalence.

However, when querying the types in the throw-specification, we need to return the types in /some/
order, and so we need to specify what the constraints of that order are.

At the very least, the order of the types returned needs to be deterministic and consistent across
different queries of the same expression, across all translation-units. This is because code may
compute types that have different layouts or ABIs based on the order of the types produced by the
~declthrow~ expression, and having the same computation produce the results in different orders
is a sure-fire way to introduce ODR-violations.

There are a few other questions around the ordering of the exception types:
- Should the order be some ordering of all types?
  i.e. if ~E1~ appears before ~E2~ in some ~declthrow()~ query, then ~E1~ appears before ~E2~ in /all/ ~declthrow()~ queries.
  - This would effectively provide a built-in facility for sorting types in type-lists.
    Note that [[https://wg21.link/P2830][P2830]] "Standardized Type Ordering" is also exploring the design space for sorting of types.
- Should the order be specified by the standard? or should it be unspecified/implementation-defined?
  - It might be difficult to specify an ordering of all types in a portable way.
  - Doing so may improve portability/compatibility of code across compilers.
  - Standard library implementations do not necessarily define all types with portable canonical names.
    e.g. some implementations place some ~std::~ library types inside inline ABI-version namespaces, which would give those
    types different names to the same types defined in other standard library implementations, which would
    negate some of the portability benefit.
- Should the order of the exceptions from a ~declthrow()~ query be consistent with the order of exception
  types deduced from the throw-specification of a function type?
  For example:
  #+begin_src c++
    // Given the following.
    void foo() throw(A, B);

    template<typename T>
    struct throw_specifier;

    template<typename Ret, typename... Args, typename... Es>
    struct throw_specifier<Ret(Args...) throw(Es...)> {
      using ...types = Es...;
    };

    template<typename... Ts>
    struct type_list {};

    // Should the following static_assert be guaranteed to hold on all conforming implementations?
    static_assert(std::same_as<type_list<declthrow(foo())...>,
                               type_list<throw_specifier<decltype(foo)>::types...>>);
  #+end_src
- Should the ~std::any_exception~ type appear in a specific location within the types returned
  by ~declthrow()~ if it is present? e.g. as the first or last type in the pack.
  - This might make it easier/more compile-time efficient to write metafunctions that want to
    detect whether there is a dynamic exception that may be thrown.
    e.g.
    #+begin_src c++
      // If std::any_exception is always first type
      template<typename... Es>
      concept DynamicException = sizeof...(Es) > 0 && std::same_as<std::any_exception, Es...[0]>; // P2662R2 pack indexing

      // vs

      // If std::any_exception could appear anywhere
      template<typename... Es>
      concept DynamicException = (std::same_as<std::any_exception, Es> || ...);
    #+end_src
  - Doing so might be inconsistent with rules for sorting types, however, if we decide that
    the type list produced by a ~declthrow()~ query must produce types in a sorted order
    consistent with the sorting order described in P2830.
- Do exception types need to be complete when used in throw specifications and
  subsequently queried via ~declthrow()~?
  - This may be somewhat limiting.
  - It would open the possibility of sorting types based on their ABI properties like size/trivial-copyability, etc.
    e.g. so that all error-types that might be returned by register appear earlier in the list
  - The exception types need to be complete anyway when a function that might throw them is invoked, just like
    the return-type needs to be complete.
  - The syntax proposed below for filtering exception types would need the exception types
    to be complete so that it can determine whether they would match a given ~catch~ handler.
    
Implementations may choose to sort exception types in the throw-specification by their mangled names,
or by their fully-scoped names.

*** Exception specifications of defaulted special member functions

See [dcl.fct.def.default].

The following functions may have defaulted definitions
- special member functions
  - default ctor
  - move ctor
  - copy ctor
  - move assignment
  - copy assignment
  - destructor
- comparison operators
  - equality
  - three-way-comparison

For defaulted functions:
- implicitly defaulted functions have an implicit exception specification
- explicitly defaulted functions which are defaulted on first declaration have an implicit exception specification
  if they don't explicitly specify an exception specification.
- explicitly defaulted functions which are defaulted on first declaration that have an explicit exception specification
  use that explicit exception specification.

This paper proposes changing the implicit exception specifications of defaulted functions
to be equivalent to a throw-specification of ~throw(auto)~.

This should have no semantic effect on existing types / existing programs as
all existing types will have either a ~noexcept(true)~ or ~noexcept(false)~
member function and thus the deduced exception specification will either
deduce to ~noexcept(false)~ or ~noexcept(true)~. The rules for deduction of
the exception specification via ~throw(auto)~ are consistent with the pre-existing
rules of deduction for defaulted member functions.

However, it would ideally have an effect on types that compose new types that
are defined with static exception specifications for these special
member functions.

For example: Defining a struct that composes two types with static exception
specifications on their special member functions.
#+begin_src c++
  struct A {
    A() throw(std::bad_alloc);
    A(const A&) throw(std::bad_alloc);
    A(A&&) throw();
    ~A();
  };

  struct B {
    B() throw(std::system_error);
    B(const B&) throw(std::system_error);
    B(B&&) throw();
    ~B();
  };

  struct C {
    A a;
    B b;

    // C has implicitly defaulted special member functions.
  };

  template<typename... Ts>
  struct type_list;

  template<typename Func>
  struct throw_specification;

  template<typename Ret, typename... Args, typename... Es>
  struct throw_specification<Ret(Args...) throw(Es...)> {
    using types = type_list<Es...>;
  };

  // Sorts the list of types in the canonical order for a throw-specification
  template<typename... Ts>
  using throw_specification_t = typename throw_specification<void() throw(Ts...)>::types;

  // The following static_asserts will always pass for conforming implementations.
  
  static_assert(std::same_as<throw_specification_t<declthrow(C{})...>,
                             throw_specification_t<std::bad_alloc, std::system_error>>);
  static_assert(std::same_as<throw_specification_t<declthrow(C{std::declval<const C&>()})...>,
                             throw_specification_t<std::bad_alloc, std::system_error>>);
  static_assert(std::is_nothrow_move_constructible_v<C>);
#+end_src

It would also be ideal if the same approach could be applied to special member
functions of certain standard library types.

For example: Constructing a ~std::tuple~ of types with default-constructors with
static exception specifications would ideally result in the ~std::tuple~ type
having a static exception specification.
#+begin_src c++
  // Ideally the following would hold true for all implementations.
  // i.e. the throw-specification of the default constructor of std::tuple is the union
  // of the throw-specifications for all of the tuple member default constructors.
  static_assert(std::same_as<throw_specification_t<declthrow(std::tuple<A, B>{})...>,
                             throw_specification_t<std::bad_alloc, std::system_error>>);
#+end_src

It's worth noting that, as currently specified, the default constructor of ~std::pair~ or
~std::tuple~ is not required to be declared ~noexcept~ if all of its member default constructors are
declared ~noexcept~, so making this work would require a change to the exception-specification of
the default constructors.

The copy/move constructors are, however, declared as either implicitly or explicitly defaulted,
which therefore implies that the exception specification for these functions is deduced from the
exception specifications of the members.

A more in-depth analysis of standard library types is required to determine where this kind
of defaulting exception specifications can be applied.

*** Introducing a pack outside of a template

The introduction of a ~declthrow(expr)~ syntax that can introduce a pack of types at an arbitrary
point within the program.

It may be problematic for some compilers to support arbitrary use of anonymous packs outside
of templates.

If this is a restriction we want to maintain in the language, then it's possible we can
restrict, for now, the ~declthrow(expr)~ syntax to having to be immediately expanded in-place
to the list of types. i.e. ~declthrow(expr)~ must be immediately followed by a ~...~ to
expand the pack.

While this would be somewhat restrictive, it would still allow some basic common usage
within ~throw()~ specifiers, and can be used to expand into the template arguments of
variadic class templates, or concepts.

For example:
#+begin_src c++
    template<typename... Ts> class type_list {};

    // Can pass the result as template arguments to a class-template.
    using error_types = type_list<declthrow(foo(a,b,c))...>;

    template<typename T, typename... Ts>
    concept one_of = (std::same_as<T, Ts> || ...);

    // Can pass the result as template-arguments to a concept.
    constexpr bool throws_bad_alloc =
       one_of<std::bad_alloc, declthrow(foo(a,b,c))...>;

    // Can use it to compute the type of a variant that can hold all
    // possible exception types that might be thrown.
    std::variant<std::monostate, declthrow(foo(a,b,c))...> error;
    try {
        foo(a,b,c);
    } template catch (auto e) {
      error.template emplace<decltype(e)>(std::move(e));
    }

    // Can use it in the throw-specification of a function that wants to transparently
    // throw whatever exceptions foo() throws, plus errors that it throws itself.
    void example(int a, int b, int c) throw(std::system_error, declthrow(foo(a,b,c))...);
#+end_src

However, it wouldn't be able to support things like the following:
#+begin_src c++
  void foo() throw(A, B);

  template<typename Nested>
  struct BarError {
    Nested nested;
  };

  void bar(int count) throw(BarError<declthrow(foo())>...) {
    try {
      for (int i = 0; i < count; ++i) { 
        foo();
      }
    } template catch(auto e) {
      throw BarError<decltype(e)>{std::move(e)};
    }
  }

#+end_src

As that requires using the pack in way that is not immediately expanding the pack.

Further, if we do not have the ability to generate a pack in a non-template then we
will not be able to take a type-list computed by some meta-programming and then expand
that type-list into elements of the ~throw()~ specification.

#+begin_src c++
  template<typename... Ts>
  struct compute_new_exception_types {
    using type = type_list< /* template magic goes here */>;
  };

  template<typename T>
  void algorithm(const T& obj)
     throw(typename compute_new_exception_types<
             declthrow((obj.foo(), obj.bar()))...>::type /* how to expand this to a pack here? */);

#+end_src

While additional workarounds could be added to the ~throw()~ specification to make this
work, I think doing this would needlessly complicate the design. I am hopeful that we
can instead make progress on improving general pack-manipulation facilites to make
some of these cases possible. See P1858R2, P2632R0.

*** Packs of ~declthrow~ packs

One common use-case of ~declthrow~ is to compute throw-specifications for other functions.

For example, say we have a user pass an invocable that we will call with elements of a span,
the ~throw()~ specification might be defined as follows:
#+begin_src c++
  template<typename T, typename Func>
      requires std::invocable<Func&, T&>
  void for_each(std::span<T> values, Func&& func) throw(declthrow(func(std::declval<T&>()))...);
#+end_src

However, if we were to, say, try to do something similar with a ~std::tuple~, where the function
may be evaluated with multiple different argument types, each argument type represented by a
pack element, then the throw-specification effectively needs to become a concatenation of the
~declthrow~ packs, one pack for each element of the tuple.

Ideally we'd be able to write something like the following:
#+begin_src c++
  template<typename... Ts, typename Func>
      requires (std::invocable<Func&, Ts> && ...)
  void for_each(std::tuple<Ts...>& values, Func&& func) throw(declthrow(func(std::declval<Ts&>()))... ...);
#+end_src

However, there are known issues with expanding a pack of packs (see P2632R0 - section "Single level of packness").

As a workaround, we could instead write this with a single ~declthrow~ expression that
contains a compound expression using ~operator,~.
For example:
#+begin_src c++
  template<typename... Ts, typename Func>
      requires (std::invocable<Func&, Ts> && ...)
  void for_each(std::tuple<Ts...>& values, Func&& func) throw(declthrow((func(std::declval<Ts&>()), ...))...);
#+end_src

This way the ~Ts~ pack is expanded inside the argument to ~declthrow~ and it is no longer problematic
expanding the ~declthrow~ expression.

The other alternative for function templates / inline functions that wish to be transparent in the set
of exceptions they may throw is to just use ~throw(auto)~ to deduce the throw-specification
from the body, rather than having to duplicate the relevant parts of the body in the ~throw()~-specification.

*** Availability of the ~declthrow~ keyword

A search of GitHub public repositories yielded no direct matches for the identifier ~declthrow~,
although it is worth noting that it did yield instances of a macro named ~DECLTHROW(X)~ which
was used to conditionally define throw-specifications if available in the target C++ language/compiler.

A search of https://codesearch.isocpp.org/ yielded no matches for ~declthrow~.

*** Alternative Syntaxes Considered

Another alternative syntax considered was the reuse of the ~throw~ keyword in a
~throw...(expr)~ that would expand to the pack of types that could potentially be
thrown by that expression.

However, this syntax would have a potential inconsistency with ~sizeof...(pack)~
which takes an unexpanded pack and returns a single value. Whereas ~throw...(expr)~
needs to take a single expression and produce a pack.

The ~throw...(expr)~ syntax may also be more easily confused with ~throw (expr)~ which
throws an exception instead of querying what exception types it might throw.

The ~declthrow~ keyword also has the benefit of association/similarity with ~decltype~ which is
used to query the value-type of an expression.

*** Filtering the set of exceptions

Sometimes we want to build a throw-specification that indicates that we throw any exception
that some other expression throws, but that we handle some number of errors within the function
and so we want to exclude those from the list. This way if the exception-specification of the
other expression changes, then the expression-specification of our function changes to
include the new set of exceptions.

While this could, in theory, be done with some template metaprogramming on packs, which would
become possible with the introduction of more pack-manipulation facilites described in P2632R0,
the resulting code is still onerous, and compile-time expensive compared to not filtering
the exceptions.

For example: Using ~throw(auto)~ and P3115R0 generalized pack facilities, we can define a helper ~filter_exceptions~
#+begin_src c++
  template<typename ErrorType>
  [[noreturn]] _throws() throw(ErrorType);

  template<typename HandledType, typename ErrorType>
  void _handle() throw(auto) {
    if constexpr (not std::same_as<HandledType, std::any_exception>) {
      try { _throws<ErrorType>(); } catch(HandledType) {}
    }
  }

  // P3115R0 pack alias syntax
  template<typename HandledType, typename... Errors>
  using ...filter_exceptions = declthrow((_handle<HandledType, Errors>(), ...));
#+end_src

Which could then be used as follows:
#+begin_src c++
  void example() throw(filter_exceptions<CaughtException, declthrow(some_expression)...>...);
#+end_src

One alternative would be to add a syntax that allowed the programmer to describe the intent
to filter the exception list directly in the language.

A strawman syntax for this could be to allow additional arguments to ~declthrow()~ to list types
to exclude from the list of types. i.e. ~declthrow(expr, filter-clauses...)~

For example: We could add additional ~catch(type)~ arguments after the first argument to ~declthrow()~
to list exception types from the expression that are caught and thus should be removed from the list.
#+BEGIN_SRC c++
  // Given.
  struct A : std::exception {};
  struct FooError : std::exception {};
  struct B : FooError {};
  struct C : FooError {};

  void foo() throw(A, B, C);

  void example1() throw(declthrow(foo())...);                        // -> throw(A, B, C)
  void example2() throw(declthrow(foo(), catch(A))...);              // -> throw(B, C)
  void example3() throw(declthrow(foo(), catch(A), catch(B))...);    // -> throw(C)
  void example4() throw(declthrow(foo(), catch(FooError))...);       // -> throw(A)
  void example5() throw(declthrow(foo(), catch(std::exception))...); // -> throw()
#+END_SRC

Note that listing the ~catch(FooError)~ base class removes both derived types from the list.

Despite the potential syntactic and compile-time benefits that might arise from adding such a syntax,
it's not clear whether the added complexity is worthwhile at this point. Usage experience is needed
to better understand how often such a feature would be needed.

For a lot of these cases, it is expected that the ~throw(auto)~ syntax will serve most of the
needs in this direction, and assuming that more generalised pack facilities become available,
users that really need to do such filtering would still be able to do this in library.

If we can specify the syntax of ~declthrow~ such that it reserves the right to be extended
in some way such that this capability could be added later, then we can take a wait-and-see
approach.

** Checking the throw-specification of a function

A function declaration that includes a /static-exception-specification/ must have a definition that
ensures that only exceptions of those types may exit the function.

To assist with this, the compiler looks at the body of the function to compute the set
of potentially-thrown exception types that may exit the body of the function.

If this set of possible exception types is not a subset of the set of exception types listed
in the exception-specification then the program is ill-formed.

For example:
#+begin_src c++
  int other() throw(A);
  
  // OK: set of potentially-thrown exceptions is {A, B}, all of which are
  // listed in the function's throw-specification.
  void example1() throw(A, B) {
    int x = other();
    if (x < 0) throw B{};
  }

  // Ill-formed: call to other() can potentially throw exception A
  // which is not listed in example2()'s throw-specification.
  void example2() throw(B) {
    int x = other();
    if (x < 0) throw B{};
  }
#+end_src

Note that for functions with a throw-specification of ~throw(auto)~ the check
always passes as the compiler computes the throw-specification to be exactly the
set of potentially-thrown exception types and thus every exception type is, by-definition,
listed in the throw-specification.

For functions with a throw-specification of ~throw(...)~ or ~noexcept(false)~, the
function is permitted to throw an exception of any type and so this check is not
required to be performed.

** Computing the set of potentially-thrown exception types

The ability to check the throw-specification of a function, compute the results of a ~declthrow~
query, instantiate a template-handler with the appropriate types, or deduce the set of exception
types that may be thrown from a function with a ~throw(auto)~ throw-specification all depend on
the ability to compute the set of potentially-thrown exception types for expressions and statements.

When computing the set of exception types that might exit an expression, statement or function,
we ideally want a set of rules that can be reliably evaluated in a consistent way across all
conforming implementations, and that is not dependent on inlining, or compiler optimisations.
This is because the computation can be important for correctness and well-formedness of a program,
and can also affect the ABI of functions with deduced throw specifications.

Computing the set of potentially thrown exception types, therefore, needs to be computable locally
for each function, from looking only at the function body and the signatures of any functions
called from that function, since we cannot assume that the definitions of called functions will
be available.

The following sections describe such a set of rules for computing the
/set of potentially-thrown exception types/ for each grammar term that
may appear within a /function-body/.

The descriptions here are not as precise as they would need to be for wording, but are hopefully
descriptive enough to understand the proposed semantics.

*** Statement Reachability

When computing the set of exceptions that may the thrown from some constructs, there are cases
where we need to determine whether execution can potentially flow off the end of a /compound-statement/
as these can affect the set of exceptions that can potentially be thrown.

For example:
- If execution flows off the end of a coroutine, it implicitly evaluates ~co_return;~.
  This calls ~promise.return_void()~ which may have a non-empty throw specification.
- If execution flows off the end of a handler of a /function-try-block/ for a constructor
  or destructor then the exception is implicitly rethrown as if there was a ~throw;~
  statement inserted at the end of the handler's /compound-statement/.

Therefore, we need to first define some rules around defining the reachability of certain
statements. These rules will need to be somewhat conservative as computing an accurate
sense of reachability is equivalent to solving the halting problem, and thus intractable.

The rules below carefully use the terminology /potentially reachable statement/ to
indicate that the computation is conservative.

A /compound-statement/ evaluates a sequence of /statements/. There are some statements/expressions
for which it is never possible to execute the next statement, however, as they unconditionally
divert control-flow elsewhere.

**** Interrupted-flow statements

An /interrupted-flow statement/ is a statement for which execution cannot flow to the next statement
from this statement.

The following statements are /interrupted-flow statements/:
- A /jump-statement/ - i.e. ~break;~, ~continue;~,  ~goto;~,  ~return expr-or-braced-init-list[opt];~ or /coroutine-return-statement/.
- A /compound-statement/ where execution cannot flow off the end of the block (see below)
- An if or if-else /selection-statement/ where either;
  - the /init-statement/, if any, is an /interrupted-flow statement/; or
  - the /condition/ is an /interrupted-flow expression/.
- An if-else /selection-statement/ where the first and second sub-statements are both /interrupted-flow statements/.
  Note: this includes ~if consteval~ selection-statements.
- A constexpr if or if-else /selection-statement/ where the condition evaluated to true and the first sub-statement is an /interrupted-flow statement/.
- A constexpr if-else /selection-statement/ where the condition evaluated to false and the second sub-statement is an /interupted-flow statement/.
- A /try-block/ where the /compound-statement/ is an /interrupted-flow statement/ and the /compound-statement/ of every
  reachable handler (see section on /try-block/ below) of the /try-block/'s /handler-seq/ is an /interrupted-flow statement/.
- A switch /selection-statement/ where either;
  - the /init-statement/, if any, is an /interrupted-flow statement/; or
  - the /condition/ is an /interrupted-flow expression/; or
  - all of the following are true;
    - the body /statement/ is an /interrupted-flow statement/; and
    - the body /statement/ has a ~default:~ label associated with the switch; and
    - there is no potentially-reachable ~break;~ statement associated with the switch.
- A do-while /iteration-statement/ where both the following are true;
  - the loop body /statement/ does not enclose any potentially-reachable ~break;~ statements associated with the loop; and
  - either;
    - both of the following are true;
      - the loop body statement does not enclose any potentially-reachable ~continue;~ statements associated with the loop; and
      - the loop body /statement/ is an /interrupted-flow statement/; or
    - the loop /expression/ is an /interrupted-flow expression/
- A for or while /iteration-statement/ where either;
  - the /init-statement/, if present, is an /interrupted-flow-statement/; or
  - the /condition/ expression is an /interrupted-flow expression/;
- A range-based for /iteration-statement/ where either;
  - the /init-statement/ is an /interrupted-flow statement/; or
  - the /for-range-initializer/ expression is an /interrupted-flow expression/; or
  - the /begin-expr/ is an /interrupted-flow expression/; or
  - the /end-expr/ is an /interrupted-flow expression/.
- An expression-statement where the expression is an /interrupted-flow expression/.
- A declaration-statement that is an object declaration where the initializer expression is an /interrupted-flow expression/.

**** Interrupted-flow expressions

An /interrupted-flow-expression/ is a potentially evaluated expression that is one of the following:
- A /throw-expression/
- A /postfix-expression/ that evaluates a call to a function marked ~[[noreturn]]~.
- A /conditional-expression/ (ternary ~?:~ operator) where either;
  - the first sub-expression is an /interrupted-flow-expression/; or
  - the second and third sub-expressions are both /interrupted-flow-expressions/.
- A built-in logical AND or logical OR expression where the first sub-expression is an /interrupted-flow expression/.
- A prvalue expression of class type whose destructor is marked ~[[noreturn]]~.
- Any other compound expression that has a sub-expression that is an /interrupted-flow-expression/.

**** Potentially-reachable statements

A /potentially-reachable statement/ is a statement of a function that the compiler determines
can potentially be executed based on a local analysis of the control-flow of the function.
It does not consider the values of any expressions which are semantically computed at runtime.

***** Reachability of compound-statements

A sub-statement of a /compound-statement/ is a /potentially-reachable statement/ if:
- it is the first sub-statement of the /compound-statement/ and the /compound-statement/ is reachable; or
- the immediately preceding statement is a /potentially-reachable statement/ and was not an /interrupted-flow-statement/; or
- the statement was immediately preceded by a label
  (Note: this does not include the implicit labels mentioned in the definition of a ~while~ statement)
Otherwise a sub-statement of a /compound-statement/ is considered an /unreachable-statement/.

A /compound-statement/ that is the top-level /compound-statement/ of a function body or lambda body is a /potentially reachable statement/.

***** Reachability of components of an if-statement

In an if-statement of the form ~if ( /condition/ ) /statement/~ or ~if ( /init-statement/ /condition/ ) /statement/~ with or without the ~else /statement/~ then;
- The /init-statement/, if present, is a potentially-reachable statement if the if-statement is a potentially-reachable statement.
- The /condition/ expression is a potentially reachable statement if;
  - The if-statement is potentially reachable; and
  - The /init-statement/ is either not present, or if present, is not an /interrupted-flow statement/.
- The first or second (if present) /statement/ is a potentially reachable statement if the /condition/ expression
  is a potentially-reachable expression and the /condition/ expression is not an /interrupted-flow expression/.

In a constexpr if statement;
- the first substatement is potentially reachable if and only if the if-statement is potentially reachable and the /condition/ evaluates to ~true~;
- the second substatement, if present, is potentially reachable if and only if the if-statement is potentially reachable and the /condition/
  evaluates to ~false~.

***** Reachability of components of a switch statement

In a switch-statement of the form ~switch ( /condition/ ) /statement/~:
- the /condition/ expression is potentially reachable if the switch-statement is potentially reachable

And, in a switch-statement of the form ~switch ( /init-statement/ /condition/ ) /statement/~:
- the /init-statement/ is potentially reachable if the switch-statement is potentially reachable
- the /condition/ expression is potentially reachable if the switch-statement is potentially reachable;
  and the /init-statement/ was not an interrupted-flow statement.

In both cases, the /statement/ is not potentially-reachable.
Execution can only enter /statement/ via a jump to a label enclosed by /statement/.

Any ~case~ and ~default~ labels associated with the switch statement are potentially
reachable if and only if the /condition/ expression is potentially reachable and is
not an /interrupted-flow expression/.

For example:
#+begin_src c++
  void f(int x) {
    switch (x) {
      a; // not-reachable
    case 0:
      b; // reachable - appears after a label
      break;
      c; // not reachable - appears after a jump-statement
    default:
      d; // reachable - appears after a label
    }
  }
#+end_src

***** Reachability of components of an iteration-statement

In an iteration-statement of the form ~while ( /condition/ ) /statement/~
- The /condition/ is a potentially reachable expression if the while-statement is a potentially reachable statement
- The /statement/ is a potentially reachable statement if the /condition/ expression is potentially
  reachable and the /condition/ expression is not a /flow-interrupted expression/.

In an iteration-statement of the form ~do /statement/ while ( /expression/ ) ;~
- The /statement/ is potentially reachable statement if the do-statement is potentially reachable
- The /expression/ is a potentially reachable expression if do-statement is potentially reachable
  and either;
  - the /statement/ is not a /flow-interrupted statement/; or
  - the /statement/ encloses a potentially reachable ~continue;~ statement associated with the do-statement

In an iteration-statement of the form ~for ( /init-statement/ /condition/ ; /expression/ ) /statement/~
- The /init-statement/ is potentially-reachable if the for-statement is potentially-reachable
- The /condition/ expression (if present) is potentially-reachable if the for-statement is potentially-reachable
  and the /init-statement/ is not an /interrupted-flow statement/
- The /statement/ is a potentially-reachable statement if the /init-statement/ is a potentially-reachable statement
  and is not an /interrupted-flow statement/ and either the /condition/ expression is not present or the
  /condition/ expression is not an /interrupted-flow expression/.
- The /expression/ is a potentially-reachable statement if either;
  - The /statement/ is a potentially-reachable statement and is not an /interrupted-flow statement/; or
  - There is a potentially-reachable ~continue;~ statement enclosed by /statement/ that is associated with the for-loop.

***** Reachability of identifier labels

These rules treat all identifier labels as potentially-reachable and does not do any analysis to
determine whether there is any jump-statement that could potentially jump to that label.

For example, we could potentially look elsewhere in the function to determine whether there
are any ~goto~ statements that target a particular label.

However, requiring this prevents doing analysis of reachability in a single pass as you may need
to look later in the function in order find a ~goto~ statement that targets a label earlier in
the function.

For example: When the compiler reaches the ~retry:~ label it has not yet seen the ~goto retry;~
statement and so does not yet know whether ~retry:~ label is reachable.
#+begin_src c++
  int foo(int x) {
    {
      auto result = try_fast(x);
      if (!result) {
	goto slow;
      }

      return result.value();
    }

   retry:
    reset_slow();

   slow:
    auto result = try_slow(x);
    if (!result) {
      goto retry;   // only know that 'retry:' label is reachable after processing this statement
    }

    return result.value();
  }
#+end_src

And even then, a more sophisticated approach would then need to consider the potential
reachability of the ~goto~ statement targeting a label itself.

There may be cycles of reachability of ~goto~ statements which are not themselves reachable
from the function entry-point.

For example: In the following function there is a ~goto~ statement targeting each of the
labels in this function, but none of those ~goto~ statements are themselves reachable
from the function entry-point.
#+begin_src c++
  void foo(int x) {
    if constexpr (false) {
      goto foo;
    }

    return x;

   foo:
    if (x < 0)
      throw negative_error{};
    goto baz;

   bar:
    --x;
    goto foo;

   baz:
    goto bar;
  }
#+end_src

It is not difficult to imagine such code occuring in practice in function templates where
there are ~goto~ statements in ~if constexpr~ branches that are either discarded or not
discarded, depending on the types the function template was instantiated with.

The rules could potentially be extended to consider a label as potentially reachable
only if there is a potentially reachable ~goto~ statement that targets the label.

Computing the reachability in this case would basically require the compiler to hold
the control-flow graph of the entire function in memory and then walk that graph,
marking statements as reachable or not.
This may be incompatible with the architecture of some compiler implementations.

The proposed design chooses a more conservative algorithm that treats all labels as reachable
in order to permit implementations that can compute a more conservative concept of
reachability in a single pass.

It is not clear whether or not handling such cases in a more accurate way would be
worth the additional complexity it would place on implementations.

**** Flowing off the end of a compound-statement

Execution may flow off the end of a /compound-statement/ if either;
- the /compound-statement/ is a /potentially-reachable statement/ and has an empty sequence of sub-statements; or
- both;
  - the last sub-statement of the /compound-statement/ is potentially-reachable and is not an /interrupted-flow-statement/
    (Note: This includes any null sub-statement implicitly inserted after a trailing label immediately before the closing brace);
    and
  - There are no object declarations declared in the scope of the /compound-statement/ that
    have destructors that have the attribute ~[[noreturn]]~.

**** Flowing off the end of a switch statement

The rules for determining that a switch statement is an /interrupted-flow statement/ require
that the body of the switch statement has a ~default:~ label associated with the switch.

This approach is somewhat conservative, as it may be possible that all of the potential
cases are already covered by ~case~ labels and that, therefore, it is not possible for
the switch statement to jump over the statement body and flow onto the next statement.

For example: The rules above result in the following
#+begin_src c++
    void example(bool x) {
      // Not an interrupted-flow statement - no default: case
      switch (x) {
      case true: throw X{};
      case false: throw Y{};
      }
      // The following statement is considered potentially-reachable.

      // An interrupted-flow statement - has a default: case
      switch (x) {
      case true: throw X{};
      default: throw Y{};
      }

      // Not potentially-reachable.
      // Prior statement is an interrupted-flow statement.
      // Control cannot flow off the end of the function's compound-statement.
    }
#+end_src

The rationale here is that trying to determine whether every possible value for the
switch expression is covered by a case label is non-trivial and/or probably doesn't
do what you want.

For example: Consider switching on an enum where all enum members have case labels.
#+begin_src c++
  enum class state_t { stopped = 0, starting = 1, running = 2 };

  int example(state_t state) {
    switch (state) {
    case state_t::stopped: return 0;
    case state_t::starting: return 1;
    case state_t::running: return 2;
    }

    foo(); // should this statement be considered "potentially-reachable"?
  }

  // Consider the following call.
  example(static_cast<state_t>(3));
#+end_src

If, instead, we just look for a ~default:~ label then we know that every
possible case is handled.

If we are willing to define rules for determining whether all possible cases are
listed as ~case~ labels then we could potentially relax the rule requiring the use
of a ~default:~ label here.

**** Use of ~[[noreturn]]~ for normative semantics

The rules above treats calls to functions marked as ~[[noreturn]]~ as being interrupted-flow expressions
and the interpretation as such can potentially affect the computation of the set of potentially-thrown
exceptions, which in turn can affect the semantics and well-formedness of a program.

The use of an attribute in this way is novel and would no longer have optional semantics,
which would go against the intent of the following note in [dcl.attr.grammar] p6

#+begin_quote
[Note : The attributes specified in [dcl.attr] have optional semantics: given a well-formed program,
        removing all instances of any one of those attributes results in a program whose set of
	possible executions ([intro.abstract]) for a given input is a subset of those of the original
	program for the same input, absent implementation-defined guarantees with respect to that attribute.
 end note]
#+end_quote

The statement reachability computation dedpends on the ability to determine whether a function can
return normally and flow to the next statement or not. For example, programs may insert calls to
~std::terminate()~ or ~std::unreachable()~ before the end of a compound-statement to indicate that
control should not flow off the end (e.g. after a loop that is never expected to exit except by
~return~).

If we do not wish to give the ~[[noreturn]]~ attribute normative semantics, then perhaps we
should explore defining an alternative normative mechanism for annotating functions as never
returning normally.

*************** TODO Add examples of iterrupted-flow statements and expressions
*************** END

*** /function-body/ 

The computation of the set of exception types of a /function-body/ is used for two main purposes:
- checking that exception types that can potentially exit the function are listed in a function's /throw-specifier/.
- deducing the throw-specification for a function with a ~throw(auto)~ specifier.

The following steps are used to compute the set of potentially-thrown exception types for a function body.

Let /A/ be the set of potentially-thrown exception types for the function body's
/compound-statement/.

If the function is a coroutine and ~return_void~ is found in the scope of
the coroutine's ~promise_type~ then flowing off the end of the coroutine is
equivalent to evaluating ~co_return;~. If this implicit ~co_return;~ statement
is potentially reachable (see above definition), then the computation of /A/
takes into account any potentially-thrown exceptions that may result from the\
evaluation of the ~co_return;~ statement.

If the function is a constructor, then
- Let /B/ be the set of potentially-thrown exception types of the function
  call expressions of the constructors of the base-classes and non-static data-members.
Otherwise, if the function is a destructor, then
- Let /B/ be the set of potentially-thrown exception types of the function
  call expressions of the destructors of the base-classes and non-static data-members.
Otherwise,
- Let /B/ be the empty set.

Let /C/ be the union of the sets /A/ and /B/.

If the /function-body/ has a /function-try-block/, then;
- let /D/ be the subset of types in /C/ that would be caught by the handlers of the /function-try-block/.
  (see the /try-block/ description for more details about this); and
- for each potentially reachable handler, /Hi/, of the try-block, let /Ei/ be the set of potentially-thrown
  exception types corresponding to the /compound-statement/ of that handler.
  For the purposes of computing the set of potentially-thrown exception types, if the function-body is
  of a constructor or destructor then the /compound-statement/ of /Hi/ should be considered to have an
  implicit ~throw;~ statement inserted immediately prior to the closing brace.
  Note: This implicit ~throw;~ statement may or may not be potentially-reachable and therefore may or
  may not contribute to the set of potentially-thrown exception types computed for /Ei/.
- Let /E/ be the union of the sets /Ei/.
Otherwise, let /D/ and /E/ both be the empty set.

Then the set of potentially-thrown exception types of the /function-body/ is the set
of types described by (/C/ - /D/)  /E/...

*************** TODO Add examples of function-body potentially-thrown exception types
*************** END

*** /statement/

A statement is one of the following cases:
- /expression-statement/
- /compound-statement/
- /selection-statement/
- /iteration-statement/
- /jump-statement/
- /declaration-statement/
- /try-block/

See the relevant section for a description of each.

*** /expression-statement/

An /expression-statement/ has a set of potentially-thrown exception types equal to
the set of potentially-thrown exception types of the /expression/.

See section on /expression/ handling below.

*** /compound-statement/

The set of potentially thrown exception types for a /compound-statement/ is the union of
the set of potentially-thrown exception types for each of the /potentially-reachable statements/ in the
/statement-seq/ of the /compound-statement/.

Note that this takes into account some basic control-flow analysis to eliminate potentially-thrown
exceptions from statements in the /statement-seq/ that are determined to be unreachable.
e.g. ignoring a statement because a preceding statement branched unconditionally to some other
code-path via ~return~, ~break~, ~continue~, ~goto~, ~throw~ or calling a ~[[noreturn]]~ function.

For example: Assuming the following declarations:
#+begin_src c++
  void foo() throw(A);
  void bar() throw(B, C);
  void baz() throw(D);
#+end_src

The set of potentially-thrown-exceptions from the following compound-statement is { ~A~, ~D~ }
#+begin_src c++
  {
    foo(); // might throw A
    goto label;
    bar(); // might throw B or C (note this is an unreachable-statement)
  label:
    baz(); // might throw D
  }
#+end_src

*** /selection-statement/

Selection statements include ~if~, ~if constexpr~, ~if consteval~ and ~switch~ statements.

**** ~if~ statements

The set of potentially-thrown exception types of an ~if~ statement is the
union of the potentially-thrown exception types of the:
- /init-statement/ - if present
- /condition/ expression
- /statement/ - the first substatement
- /statement/ - the second substatement (if the ~else~ part is present)

Note that the computation of potentially-thrown exception types does not consider
whether or not the /condition/ is a constant expression or not - both branches of
sub-statements are always considered when computing the set of potentially-thrown
exception-types.

For example: The following if-statement has a set of potentially-thrown exception types equal to { ~X~ },
despite the condition being a constant
#+begin_src c++
  if (false) {
    throw X{};
  }
#+end_src

If you want to force the branching decision to be performed at compile-time then
use the ~if constexpr~ form of selection-statement (see below).

***** Reachability of if-statement components

With if-statements there is the question of whether we should consider the set of potentially-thrown
exceptions of the first or second sub-statements if either the /init-statement/ is a
/interrupted-flow statement/, or if the /condition/ is an /interrupted-flow expression/.

For example: Should the following function, ~f()~ deduce to a throw-specification of ~throw(X)~ or
to ~throw(X, Y, Z)~?
#+begin_src c++
  [[noreturn]] bool throws_something() throw(X);

  void f() throw(auto) {
    if (throws_something()) {
      throw Y{};
    } else {
      throw Z{};
    }
  }
#+end_src

The rules above do not try to compute the individual reachability of the substatements and
applying the rules as written would result in a deduced exception specification for ~f()~
of ~throw(X, Y, Z)~.

While it would be relatively straight-forward to extend the rules to, instead, compute
a deduced exception specification of ~throw(X)~, it is not clear that this would bring
significant value, as this kind of code is expected to be relatively rare, and could
be straight-forwardly rewritten in a form that separates the /interrupted-flow expression/
into a separate statement.

For example: The following code is equivalent but deduces the throw-specification to ~throw(X)~
according to the above rules since the if-statement is not a reachable statement.
#+begin_src c++
  void f() throw(auto)  {
    bool cond = throws_something();
    // The if-statement is unreachable as prior statement was an interrupted-flow statement.
    if (cond) {
      throw Y{};
    }  else {
      throw Z{};
    }
  }
#+end_src

**** ~if constexpr~ statements

As the condition of a constexpr if statement is evaluated as part of constant evaluation
and constant evaluation is not permitted to throw exceptions, /condition/ part does not
contribute to the set of potentially-thrown exception types.

If the /selection-statement/ contains an /init-statement/ part, then let /I/ be
the set of potentially-thrown exception types of the /init-statement/,
otherwise let /I/ be the empty set.

If the value of the converted /condition/ expression is ~true~ then then set of
potentially-thrown exception types of the /selection-statement/ is the union of
/I/ and the set of potentially-thrown exception types of the the first substatement.
i.e. the body of the ~if~ /statement/.

Otherwise, if the ~else~ part of the selection statement is present, then the
set of potentially-thrown exception types of the /selection-statement/ is the union of
/I/ and the set of potentially-thrown exception types of the second substatement.
i.e. the body of the ~else~ /statement/.

Otherwise, the set of potentially-thrown exception types of the /selection-statement/
is /I/.

For example: The following statement has a set of potentially-thrown exceptions
equal to { ~X~ }.
#+begin_src c++
  if constexpr (true) {
    throw X{};
  } else {
    throw Y{};
  }
#+end_src

**** ~if consteval~

An if-statement of the form ~if consteval /compound-statement/~ has a set of
potentially-thrown exception types that is the set of potentially-thrown
exception types of the /compound-statement/.

An if-statement of the form ~if consteval /compound-statement/ else /statement/~ has
a set of potentially-thrown exception types that is equal to the union of the
sets of potentially thrown exception types of /compound-statement/ and /statement/,
respectively.

Note that the /compound-statement/ is manifestly constant-evaluated and so is
not currently permitted to throw exceptions and so could potentially be considered
as not contributing to the set of potentially-thrown exception types.

However, it is possible that we may want to support the ability to throw exceptions
during constant-evaluation in future.
See [[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r0.pdf][P3068R0]] "Allowing exception throwing in constant-evaluation" for such a proposal.

If we were to initially treat code within the manifestly-constant-evaluated
branch as non-throwing then later changing it to be potentially-throwing would be a
breaking change.

**** ~switch~

A switch statement of the form ~switch ( /init-statement/ /condition/ ) /statement/~
or ~switch ( /condition/ ) /statement/~
has a set of potentially thrown exception-types equal to union of the sets of potentially
thrown exception types of the following parts:
- /init-statement/ (if present)
- /condition/ expression
- /statement/

*** /iteration-statement/

The following kinds of iteration-statement are possible:
- ~while ( /condition/ ) /statement/~
- ~do /statement/ while ( /expression/ ) ;~
- ~for ( /init-statement/ /condition/ ; /expression/ ) /statement/~
- ~for ( /init-statement/ /for-range-declaration/ : /for-range-initializer/ ) /statement/~

For all of these forms of iteration statement, the set of potentially-thrown exception types
of the iteration statement is the union of the sets of potentially-thrown exception types
from each of the relevant subexpressions or substatements:
- /condition/
- /statement/
- /expression/
- /init-statement/
- /for-range-declaration/
- /for-range-initiailizer/

Note that this includes exceptions that may be thrown from the body of the iteration statement,
even if the statement's /condition/ is such that the body will never be executed.

*** /jump-statement/

Jump statements include:
- ~break;~
- ~continue;~
- ~return~ /expr-or-braced-init-list/ ~;~
- /coroutine-return-statement/
- ~goto~ /identifier/ ~;~

Only the ~return~ and ~co_return~ statements can potentially affect the set of potentially-thrown
exception types here. The others are pure control flow, and while they can potentially trigger
exceptions to be thrown when exiting scopes via that control-flow (if destructors are potentially-throwing),
those exceptions should be covered by the declaration statement for that variable.

**** ~return~ statements

A ~return~ statement has a set of potentially-thrown exception types equal to the
union of the set of potentially-thrown exception types of the operand expression,
and the set of potentially-thrown exception types from any implicit conversion
or constructor call required to initialize the return-value.

Note that there is an edge-case here that needs to be considered, where the operand
to the return statement is a prvalue which is returned with guaranteed copy-elision
and where the object has a potentially-throwing destructor. Normally, an expression
that creates a pr-value includes the potentially-throwing types of both the call to
the constructor, and the call to the destructor, as a statement containing that
expression will also call the destructor at the end of the full-expression.
However, for a return-value that is initialized with guaranteed copy-elision, the
destructor will be invoked by the caller of the function, rather than the local
function, and so the exception-specification of the return-value type should not
be included in the calculation of the set of potentially-thrown exception types for
the return statement.

For example:
#+begin_src c++
  struct Foo {
    Foo() throw(A);
    Foo(Foo&&) throw(B);
    ~Foo() throw(C);
  };

  Foo f() throw(auto) { // deduces to throw(A)
    return Foo{}; // constructor called here but not destructor
  }

  Foo g() throw(auto) { // deduces to throw(A, B, C)
    Foo f; // declaration statement potentially throws A (from constructor) and C (from destructor)
    return f; // move-constructor potentially called here, even if copy is elided due to NRVO
  }
#+end_src

We also need to consider the case where the returned object is initialized using aggregate
initialization, where there may be a whole tree of sub-expressions that potentially initialize
sub-objects of the returned object.

Any expression in such a return-statement that directly initializes an object or sub-object of
the return-value that will be destroyed by the caller should not consider the exception-specification
of that sub-object's type's destructor when computing the set of potentially-thrown exceptions of
the ~return~ statement.

Note that, while it may be possible that the return-statement may execute the destructor of some
of these sub-objects in the case that initialization of a subsequent sub-object exits with an
exception, we do not need to consider this case for the purposes of computing the potentially-thrown
exceptions as these destructors will only be called in case there is an unwind due to another
exception - if these destructors then throw their own exceptions during unwind then this results
in an immediate call to ~std::terminate~.

For example:
#+begin_src c++
  struct X {
    X() throw(A);
    ~X() throw(B);
  };
  struct Y {
    Y() throw(C);
    ~Y() throw(D);
  };

  struct Z {
    X x;
    Y y;
  };

  Z h() throw(auto) { // deduces to throw(A, C)
    return Z{X{}, Y{}};
  }
#+end_src

In this example, if ~Z::x~ is initialized and then the call to ~Z::y~'s constructor throws
then the ~Z::x~ destructor will be called, which could theoretically exit with an exception
of type, ~B~. However, since this can only happen while unwinding with an exception of type
~C~, if ~Z::x.~X()~ exits with an exception during unwind then ~std::terminate()~ is called.
So it is not possible for the function ~h()~ to exit with an exception of type ~B~.

As an aside, it would be useful to be able to make ill-formed any cases that could result in
potential calls to ~std::terminate()~ due to an exception being thrown during unwind - at
least in pursuit of the goal of embedded systems having no hidden calls to ~std::terminate()~.
How, and whether, to do this is an open-question.

**** ~co_return~ statements

A ~co_return~ statement of the form ~co_return;~ has a set of potentially-thrown exception types
equal to the set of potentially-thown exception types of the statement ~promise.return_void();~,
where /promise/ is the current coroutine's promise object.

A ~co_return~ statement of the form ~co_return /expr/ ;~, where /expr/ has type ~void~ has
a set of potentially-thrown exception types equal to the union of the set of potentially-thrown
exception types of /expr/ and the set of potentially-thrown exception types of the statement
~promise.return_void()~, where /promise/ is the current coroutine's promise object.

A ~co_return~ statement of the form ~co_return /expr-braced-init-list/ ;~, where the operand
is either an /expression/ of non-~void~ type or is a /braced-init-list/, has a set of potentially-thrown
exception types equal to the set of potentially thrown exception types of the statement
~promise.return_value( /expr-or-braced-init-list/ );~.

*** /declaration-statement/

A declaration statement consists of a /block-declaration/, which in turn consists of one of the following:
- /simple-declaration/
- /asm-declaration/
- /namespace-alias-definition/
- /using-declaration/
- /using-enum-declaration/
- /using-directive/
- /static_assert-declaration/
- /alias-declaration/
- /opaque-enum-declaration/
 
Other than the first two cases, the rest of the declarations do not introduce any executable code that
might throw exceptions.

Note that, while the /static_assert-declaration/ has a child expression, this expression is evaluated
as a manifestly constant expression, and therefore the program is ill-formed if that expression exits
with an exception.

**** /simple-declaration/

A declaration statement that declares one or more block variables with automatic storage duration
has a set of potentially-thrown exception types equal to union of the sets of potentially
thrown exception types of any /initializer/ expressions and any calls to constructors or
conversion operators required to initialize the local variables, and any potentially thrown
exception types of calls to the destructors of the declared variables.

A declaration statement that declares one or more block variables with either static storage duration
or thread storage duration has a set of potentially-thrown exception types equal to the union
of the sets of potentially-thrown exception types of any /initializer/ expressions and any calls
to constructors of conversion operators required to initialize the local variables, but does _not_
include exception types of calls to the destructors of the declared variables.

We do not include the exceptions thrown by destructors of static/thread_local variables because
these destructors are not called from within the scope of a function that initializes these
variables.

Q. Initialization of variables with static storage duration needs to perform synchronization
in multi-threaded environments in order to guard against data-races initializing the
variable. Is it possible that operations on the synchronization primitives might fail with an
implementation-defined or unspecified exception (in which case we would need to include this
in the set of exception types) or can we assume that the synchronization will always succeed?

A declaration statement that declares a constant expression (i.e. is declared with the ~constexpr~
specifier) has an empty set of potentially-thrown exception types, assuming that the program is ill-formed
if a constant-evaluation exits with an exception.

**** /asm-declaration/

The /asm-declaration/ has implementation defined behaviour and, while in theory, on some implementations,
an assembly declaration might be able to throw an exception, we cannot, in general, deduce anything about
the set of exception types that might be thrown in a portable way.

There are three possible options we take here:
- the /asm-declaration/ has implementation-defined behaviour, so the set of potentially-thrown exceptions
  from such a declaration should be implementation-defined.
- the /asm-declaration/ could potentially do anything (invoke a potentially-throwing function,
  implement some exception-throwing mechanics, etc.) so we should treat this as potentially throwing
  any type of exception.
- the vast majority of /asm-declaration/ usage is for implementing optimized, inline code, which
  won't throw any exceptions, so we could define it to be non-throwing.
- we could make it ill-formed to use an /asm-declaration/ in any context in which the
  exception-specification needs to be deduced.
  
This paper suggests treating an /asm-declaration/ statement as having an implementation-defined
set of potentially-thrown exceptions as this at least allows the possibility of the implementation
being able to analyse a declaration and deduce what exceptions might be thrown in an implementation-specific
way.

However, it would be worth a more detailed discussion within the Evolution sub-group about
what the desired semantics are here.

*** /try-block/

A /try-block/ statement has the form ~try /compound-statement/~ followed by one or more
handlers of the form ~catch ( /exception-declaration/ ) /compound-statement/~.

In addition, a /function-try-block/ statement for a constructor can also have the form
~try /ctor-initializer/ /compound-statement/~ followed by one or more handlers of the
form ~catch ( /exception-declaration/ ) /compound-statement/~.

Let /A/ be the set of potentially-thrown exception types of the try block's /compound-statement/.

If this is a function try block for a constructor then let /B/ be the union of /A/ and
the sets of potentially-thrown exceptions of initializer expressions and calls to
constructors of any base classes and non-static data-members.

Otherwise, let /B/ be the set /A/.

Let /E/ initially be the empty set.

For each type, /x/, in the set /B/
- if /x/ is ~std::any_exception~ then
  - add the set of potentially-thrown exception types of the /compound-statement/ of every reachable
    handler to /E/.
    - NOTE: a handler is not reachable if the /exception-declaration/ for that handler names a type
      unambiguously derived from a base class type that is listed in an earlier handler's /exception-declaration/.
    - NOTE: this does not include template handlers as those are only invoked from exceptions thrown
      from expressions that have a static exception specification.
  - if the list of handlers associated with this try-block does not include a handler with an /exception-declaration/ of ~...~
    then add ~std::any_exception~ to /E/.
- otherwise, if any handler is a match for an exception object of type /x/ then
  - The selected handler for this exception type is the first handler, /h/, that matches
    an exception object of type /x/. /h/ is a reachable handler.
  - Add the set of potentially-thrown exception-types of /h/'s /compound-statement/ to /E/.
  - Add the set of potentially-thrown exception-types of a function call expression
    that invokes the destructor of an object of type, /x/.
    - NOTE: This is because exiting the handler's /compound-statement/ will potentiallly
       call the destructor of the exception object of type /x/.
    - NOTE: There is a potential edge-case here, where the /compound-statement/ unconditionally
      rethrows the exception (e.g. with a ~throw;~ statement). In this case, the destructor
      of the exception object is never called upon existing the /compound-statement/ and so
      we could avoid adding the destructor's set of potentially-thrown exception types to
      the set of potentially-thrown exception types for this handler.
      This is unlikely to make much difference in practice, as 
- otherwise,
  - add /x/ to /E/

If the /try-block/ is part of a /function-try-block/ then a handler associated with that
/try-block/ should be treated as if the statement ~throw;~ was inserted immediately prior to
the closing brace of its /compound-statement/ for the purposes of computing its set of
potentially-thrown exception types.

The set of potentially-thrown exception types of the /try-block/ is the resulting set, /E/.

*** /init-statement/

An init-statement is either a:
- /simple-declaration/ 
- /expression-statement/ - Expression statements are already described above.
- /alias-declaration/ - These do not contain any executable code and thus do not contribute to the set of potentially-thrown exception types.


If the statement is a /simple-declaration/ that is an object declaration,
the set of potentially-thrown exception types of that statement is the union
of the sets of potentially-thrown exception types of the /initializer/ expression,
the function call expression of the objects selected constructor and the
function call expression of the object's destructor.

*** /expression/

There are many different types of expressions that need to be considered.

I am not going to list all of them here, but instead give some general rules that
apply to most expressions and then describe separately the rules for any expressions
that do not follow the general rules.

**** General rules for expressions

Expressions that have sub-expressions in general have a set of potentially-thrown exception
types that includes the union of the sets of potentially-thrown exception types of the
immediate-sub-expressions of that expression.

Operator expressions or conversions that resolve to calls to user-defined operator
functions have a set of potentially-thrown exception types of a function call expression to
that user-defined operator function. Built-in implicit conversions and operators
generally have an empty set of potentially-thrown exceptions.

**** Function call expressions

Function call expressions have a set of potentially-thrown exception types equal to the
union of the sets of potentially-thrown exception types of the following expressions:
- the expressions provided as arguments to the function, including any default argument expressions.
- any implicit conversion expression required to convert the argument to the corresponding parameter type, and
- the /postfix-expression/ immediately preceding the parenthesised argument-list
unioned with the set of exception types listed in the /postfix-expression/'s function type's or function-pointer type's
exception-specification.

If the /postfix-expression/ has function type then the set of potentially-thrown exception types
is taken from the exception-specification of the function declaration.

If the /postfix-expression/ has function-pointer or member-function-pointer type then the set of
potentially-thrown exception types is taken from the exception-specification of the pointed-to
function type.
Note that this may be a superset of the set of exception types listed in the pointed-to
function's exception specification.

If the function or function-pointer has an dynamic exception-specification then the
set of potentially-thrown exception types is the set { ~std::any_exception~ },
otherwise, if it has a static exception-specification then the set of potentially
thrown exception types is the set of types listed in the exception specification.

Note that if any parameter types of the function or function-pointer being called have
a value category of prvalue then the set of potentially-thrown exception types will also
include the exception types listed in the type's destructor's exception-specification,
as per the next section.

**** prvalue expressions

If an expression has a prvalue value category then the set of potentially thrown exception
types of that expression includes the set of potentially thrown exception types of a
function call expression to that object's destructor, unless that expression is the operand
of a ~return~ statement of a function returning a prvalue of the same type as the operand
and the operand is used to initialize the result object via copy-initialization.

See the section on ~return~ statements for more details (in particular regarding aggregate
initialization of return values).

**** Standard conversions

The set of potentially-thrown exceptions from all standard conversions listed under
[conv.general] is the empty set.

**** Constant expressions

In C++23 it is not permitted for an exception to be thrown within the evaluation of a constant
expression. If this is to remain the case, then we could assume that any manifestly constant expression
has an empty set of potentially-thrown exceptions.

However, it's possible that in the future we may decide to allow exceptions to be thrown during
the evaluation of a constant expression. Although this may be limited to the cases where any thrown
exception is caught within the same constant evaluation - similar to how dynamic memory allocation
is allowed, as long as the memory is freed within the same constant evaluation.
The paper [[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r0.pdf][P3068]] "Allowing exception throwing in constant-evaluation" proposes such a change to the language.

In order to allow for this possibility, and to avoid having adding this capability later be a
breaking change, manifestly constant expressions should be treated the same as runtime-evaluated
expressions for the purposes of computing the set of potentially-thrown exception types of that
expression.

However, the top-level expression that begins a new constant evaluation, such as initialization of
a ~constexpr~ variable or the /condition/ of an ~if constexpr~ statement, should be assumed to be
non-throwing. An exception propagating out of such an expression would make the program ill-formed.

For example:
#+begin_src c++
  constexpr int parse_integer(const char* s) throw(parse_error) {
    int result = 0;
    do {
      if (!std::isdigit(*s)) throw parse_error{};
      result = 10 * result  + (*s - '0');
      ++s;
    } while (*s != '\0');
    return result;
  }

  int example_1() throw(auto) { // deduces to throw()
    constexpr int i = parse_integer("1234");
    return i;
  }

  int example_2() throw(auto) { // deduces to throw(parse_error)
    const int i = parse_integer("1234");
    return i;
  }

  int example_3() throw(auto) { // deduces to throw()
    if constexpr (parse_integer("1234") >= 10) {
      return 10;
    }
    return 0;
  }

  constexpr int example_4() throw(auto) { // deduces to throw(parse_error)
    if consteval {
      return parse_integer("1234");
    } else {
      return 0;
    }
  }
#+end_src

In ~example_2()~, even though a compiler could potentially evaluate the call to ~parse_integer()~
as a constant-expression, it is not required to do so and so could potentially have a runtime
call to a function that is potentially-throwing.

Also, if the function does happen to throw during a speculative constant execution of the function
then the compiler falls back to inserting a runtime call to the function instead, rather than
making the program ill-formed, like it would be if the invocation in ~example_1()~ or ~example_3()~
were to throw.

For example, consider what the semantics should be if ~example_2()~ replaced the argument to
~parse_integer~ with ~"not-a-number"~ . In this case, we would expect that calling ~example_2~
would throw ~parse_error~ at runtime. Simply changing the value of the string literal passed
to ~parse_integer~ should not change the deduced exception-specification of the function.

In ~example_4()~, despite the call to the ~parse_integer()~ function being evaluated as a
manifestly constant expression (inside a true ~if consteval~ sub-statement) this context
is not being evaluated as a top-level constant evaluation and so might (one day) propagate
the exception up to some caller that then handles the exception.

**** Throw expressions

We need to consider both:
- ~throw <expr>~ expressions that throw new exception objects, and
- ~throw~ expressions that rethrow an existing exception.

***** ~throw <expr>~

A throw-expression constructs and throws a new exception object of type equal to the decayed type of the operand expression.

Some throw-expressions may require dynamic allocation of storage for the exception object,
which might fail due to resource exhaustion. In this case, the throw expression may instead
result in throwing an exception of type ~std::bad_alloc~.

Note that currently, the behaviour of a program that fails to allocate storage for a newly
thrown exception is unspecified. However, the behaviour for failure to allocate/rethrow
an ~exception_ptr~ is well-defined and so I would expect most implementations to do something
similar - i.e. throw ~std::bad_alloc~.

This was discussed in the mailing list thread: https://lists.isocpp.org/core/2023/10/15012.php

*************** TODO Update this section based on the outcome of the mailing list discussion
*************** END

This paper proposes defining some forms of throw expressions as not requiring dynamic memory
allocation, but instead requiring that implementations allocate the exception objects as
automatic storage duration objects. This is necessary to be able to provide the guarantee
to programs that particular throw expressions actually throw an exception of that type
and do not throw an expression of some other type (like ~std::bad_alloc~) and therefore
that the set of potentially-thrown exception types is limited to the types of the actual
thrown exceptions.

****** Dynamic and Static throw expressions

The function that contained the throw expression that created the exception object is
called the "originating function".

If the exception thrown by a throw-expression is either handled within the originating
function or if the exception escapes the originating function (possibly after a number
of catch/rethrow steps) and the function definition has a throw-specifier with a static
exception specification (note this implies the exception type is listed in the
throw-specification as otherwise the program would be ill-formed), then the throw
expression is considered a /static throw expression/. All other throw-expressions
are /dynamic throw expressions/.

In general, this means that all throw expressions in functions with a throw-specifier
on the definition that have a static exception specifications will be /static throw expressions/
and throw-expressions in a function with a dynamic exception specification will be
dynamic throw expressions unless they are caught locally within the originating
function.

For example: Both of the throw-expressions and the rethrow-expressions are all
/static throw expressions/.
#+begin_src c++
  void example1(int i) throw(Y, Z) {
    try {
      switch (i) {
      case 0:
	throw X{}; // static throw-expression: doesn't escape the function - locally handled
      case 1:
	throw Y{}; // static throw-expression: can escape the function (with rethrow)
      case 2:
	throw Z{}; // static throw-expression: escapes the function (not handled locally)
      }
    } catch (X) {
      // handled, not rethrown
    } catch (Y) {
      // handled, rethrown
      throw;
    }
  }

#+end_src

Another example: this time with some dynamic exception specifications
#+begin_src c++
  void example2(int i) throw(...) {
    try {
      switch (i) {
      case 0:
	throw X{}; // static throw-expression: doesn't escape the function - locally handled
      case 1:
	throw Y{}; // dynamic throw-expression: can escape the function (with rethrow)
      case 2:
	throw Z{}; // dynamic throw-expression: escapes the function (not handled locally)
      }
    } catch (X) {
      // handled, not rethrown
    } catch (Y) {
      // handled, rethrown
      throw;
    }
  }
#+end_src

A /dynamic throw expression/ allocates the storage in an unspecified way
controlled by the implementation in the same way that storage for thrown exception
objects are currently allocated. The exception object created by a /dynamic throw expression/
is called a /dynamic exception object/.

A /static throw expression/ allocates the storage for the exception object
with automatic storage duration. The exception object created by a /static throw expression/
is called a /static exception object/. The scope of the storage ends after the end
of the lifetime of the static exception object.

****** Lifetime of exception objects created by static throw expressions

According to [except.throw] p4
#+begin_quote
The points of potential destruction for the exception object are:
- when an active handler for the exception exits by any means other than rethrowing, immediately after
  the destruction of the object (if any) declared in the exception-declaration in the handler.
- when an object of type ~std::exception_ptr~ that refers to the exception object is destroyed, before
  the destructor of ~std::exception_ptr~ returns.

Among all points of potential destruction for the exception object, there is an unspecified last one
where the exception object is destroyed. All other points /happen before/ the last one.
#+end_quote

For exception objects created by /static throw expressions/, we need to be able to deterministically
compute their latest-possible point of destruction so that we know where to allocate the automatic
storage-duration storage for that exception object.

To allow the compiler to compute this point, we need to eliminate the possibility of the exception object's
lifetime being dynamically extended by calling ~std::current_exception()~ and holding on to the ~std::exception_ptr~.
However, we still want to permit users to call ~std::current_exception()~ if desired.

If the exception object being handled by the most-recently entered handler is a /static exception object/
then a call to ~std::current_exception()~ returns a /dynamic exception object/ that is copied from
the /static exception object/.

Note that the current semantics of capturing the exception in a ~std::exception_ptr~ by calling
~std::current_exception()~ and throwing the captured exception by ~std::rethrow_exception()~ does
not necessarily throw the same exception object. An implementation is allowed to copy the current
exception object into storage referenced by the returned ~std::exception_ptr~, so this behaviour
is consistent with existing semantics.

Similarly, if a /static exception object/ is rethrown by a ~throw;~ expression that is not
a /lexically associated rethrow/ of the active handler then the compiler may not be able to
deduce that the current exception object escapes the current handler and should not be destroyed
when the current handler exits.

A /lexically associated rethrow/ is a ~throw;~ expression that is a sub-statement of a
handler's /compound-statement/ and that is;
- not inside the handler of a try-block nested within this handler; and
- not inside the body of a lambda expression nested within this handler; and
- not inside the body of a member function of a local class

A ~throw;~ expression that is not a /lexically associated rethrow/ throws a
/dynamic exception object/.
If the current exception is a /static exception object/ then this will allocate a new
/dynamic exception object/ copied from the current /static exception object/.

With those cases handled, we can now define that the lifetime of a /static exception object/
ends deterministically upon exiting a handler for that exception through any means other
that a /lexically associated rethrow/.

Storage for a /static exception object/ is has automatic storage-duration.

Generally, the storage for a /static exception object/ will be allocated in the scope of
the function that has the outer-most dynamic scope for a handler that can match the
exception object's type, taking into account possible chains of catch/rethrow of the
exception object.

However, there are some cases where rethrowing an exception object may result in copying a
/static exception object/ from automatic storage duration storage allocated in an
inner dynamic-scope to automatic storage duration allocated by an outer dynamic-scope.

A caller of a function with a static throw specification will generally provide storage
to the called function so that the called function can allocate the exception object in
storage owned by the caller before it exits. If the caller is not the final handler of
an exception (i.e. the lifetime of the exception object may escape the calling function),
the caller may choose to reuse the storage provided to it by its caller as the storage
it provides to the function it calls.

******* Examples of static exception object lifetime and storage duration

The following examples walk through some simple cases and describe how the
exception object lifetime of static exception objects is intended to work.

Given the following exception type, ~X~, and function ~f()~, which throws an instance of ~X~:
#+begin_src c++
  struct X {
    explicit X(int) noexcept;
    X(const X&) noexcept;
    ~X();
    int value;
  };

  extern int some_int;

  void f() throw(X) { throw X{some_int}; }
#+end_src

Example 0: Consider the following case:
#+begin_src c++
  void g0() throw(X) {
    f();
  }

  void h0() throw() {
    try { g0(); } catch (const X&) {}
#+end_src

In this case:
- ~h0()~ allocates automatic-storage duration storage for an exception object of
  type ~X~ and provides the address of this storage to ~g0()~.
- then ~g0()~ calls ~f()~ and provides the address provided by ~g0()~ to ~f()~
- if ~f()~ throws an exception, then it constructs the object directly into the
  storage provided by ~g0()~.
- the exception unwinds through ~g0()~ and the handler in ~h0()~ is activated
- the exception object is destroyed and the lifetime of the storage for the
  exception ends when the handler in ~h0()~ exits.

Example 1: Consider the following case:
#+begin_src c++
  void g1() throw(X) {
    try { f(); }
    catch (const X&) { throw; }
  }

  void h1() throw() {
    try { g1(); } catch (const X&) {}
  }
#+end_src

In this case:
- ~h1()~ allocates automatic-storage duration storage for an exception object of
  type ~X~ and provides the address of this storage to ~g1()~.
- when ~g1()~ calls ~f()~ it forwards the address provided by ~h1()~ to ~f()~ and
  ~f()~ constructs the exception object directly into the storage provided by ~h1()~.
- execution returns from ~f()~ and the handler in ~g1()~ is activated.
- this handler then rethrows the exception - as the exception object is already
  constructed in the final location there is no need to copy the object.
- execution then returns to ~h1()~ and its handler is activated
- the exception object is destroyed when the handler in ~h1()~ exits

Note that ~g1()~ in this case was able to pass the address of the storage for the exception
object provided by ~h1()~ to ~f()~ because there was no other exception object being
thrown by ~g1()~ whose lifetime overlaps with the lifetime of the exception object thrown
by ~f()~.

Example 2: Consider the following case:
#+begin_src c++
  void g2() throw(X) {
    try { f(); }
    catch (const X& x) { throw x; }
  }

  void h2() throw() {
    try { g2(); } catch (const X&) {}
  }
  #+end_src

In this case:
- The handler in ~g2()~ throws a new exception object insead of rethrowing the existing one
- This means that the lifetime of the new exception object thrown by ~g2()~ overlaps the lifetime
  of the exception object thrown by ~f()~, which is alive until the handler is exited.
- This means that ~g2()~ cannot reuse the storage for the exception object provided by ~h2()~
  to pass to ~f()~ and it needs to allocate its own automatic storage duration storage to
  provide to ~f()~ for any exception object
- When ~f()~ throws an exception it constructs into the storage in ~g2()~ and then unwinds
  and activates the handler in ~g2()~.
- The ~throw x;~ statement in ~g2()~'s handler then constructs a new exception object in
  the storage provided by ~h2()~.
- When the handler in ~g2()~ exits, the exception object thrown by ~f()~ is destroyed
  and its storage lifetime ends.
- Control then unwinds to ~h2()~ and activates its handler.
- When the handler in ~h2()~ exits, the exception object thrown by ~g2()~ is destroyed
  and its storage lifetime ends.
  
Example 3: Consider the following case:  
#+begin_src c++
  void g3() throw(X){
    try { f(); }
    catch (const X& x) {
      if (x.value < 0) {
	throw X{0}; // throw a new object
      }
      throw; // rethrow
    }

    void h3() throw() {
      try { g3(); } catch (const X&) {}
    }
#+end_src

In this case:
- The handler in ~g3()~ conditionally either rethrows the current exception object
  or throws a new exception object.
- In the case that the handler throws a new object, we have a similar case to ~g2()~ where
  there is overlap in lifetime between the exception object thrown by ~f()~ (whose lifetime
  ends at the end of the current handler) and the new exception object created by the
  ~throw X{0};~ statement.
- This means that we cannot reuse the storage that ~h3()~ provided to ~g3()~ for returning
  the exception as the storage that ~g3()~ provides to ~f()~ for returning its exception,
  even though there is another code-path in ~g3()~'s handler that rethrows the current
  exception to ~h3()~.
- Instead, ~g3()~ will need to allocate its own local storage to provide to ~f()~, and then
  in both of the throw and rethrow-expressions, construct a new exception object in the storage
  provided by ~h3()~ to ~g3()~.
- Note that in the rethrow-expression case, since the original exception object is about to
  be destroyed, we may be able to move-construct the new exception object from the original
  object instead of copy it as the ~throw;~ statement will exit the handler.
  Note: This may not be the case for all rethrow expressions.

Example 4: Consider the following case:
#+begin_src c++
  void g4() throw(X) {
    try { f(); }
    catch (const X& x) { if (x.value >= 0) throw; }
    throw X{0};
  }

  void h4() {
    try { g4(); } catch (const X&) {}
  }
#+end_src

In this case:
- It is similar to the above ~g3()~ example, except that this time, the new exception object
  is thrown from outside of the handler.

****** Rules for throw expressions

The set of potentially-thrown exception types of a throw expression is the union of
- the set of potentially-thrown exception types of the operand expression
- the type of exception thrown. i.e. ~std::decay_t<decltype(<expr>)>~
- the set of potentially-thrown exception type of copy-initialization of the exception-object

Additionally, if the throw-expression is a dynamic-throw-expression then the set of
potentially-thrown exception types also includes ~std::bad_alloc~, which may be thrown
if the implementation fails to allocate storage for the exception object.

***** ~throw~ (rethrowing the currently handled exception)

If the rethrow expression occurs lexically within the body of a handler and is not nested within
a locally defined function body or a lambda expression body defined in the scope of that handler,
then we say that the rethrow expression is associated with the inner-most enclosing handler.

Otherwise, we say that the rethrow expression is unassociated with a handler.

For example:
#+begin_src c++

  void example() {
    throw; // unassociated - not inside handler

    try {
      throw; // unassociated - not inside handler
    } catch (A a) { // #1
      if (!can_handle(a)) {
        throw; // associated with #1
      }

      auto rethrow = [] {
        throw; // unassociated - inside lambda
      };

      struct LocalClass {
        static void Rethrow() {
          throw; // unassociated - inside nested function
        }
      };
    } catch (...) { // #2
      try {
        throw; // associated with #2
      } catch (B b) { // #3
        throw; // associated with #3
      }
    }
  }
#+end_src

If a rethrow expression is associated with a handler then we potentially have more static information about
the set of possible exception types that might be thrown by that expression than a rethrow expression that
is unassociated with a handler.

We can compute the set of exception types that might be thrown by such a rethrow exception
based on the set of exception-types that may propagate out of the try-block and based on the exception
types that may be handled by handlers earlier in the sequence of handlers for that try-block.

****** Unreachable handlers

One of the interesting cases to handle is when we can statically determine whether the handler is
unreachable. This can happen in one of two cases:
- When an earlier handler matches an unambiguous base-class of the later handler's exception-declaration type and
  will therefore preferentially match any exception types that would be handled by the later later handler.
- When the set of potentially thrown exception types of the try-block's /compound-statement/ is a finite set
  (i.e. does not contain contain ~std::any_exception~) and there are no types in that finite set that match
  this handler and that do not match any earlier handler.

In this case, there is the question of what the set of potentially-thrown exception types should be for
a rethrow expression that is associated with such an unreachable handler.

As the handler itself is statically determined to be unreachable, the body of the handler's compound-statement does
not contribute to the overall set of potentially-thrown exception types of the try-block, so we might say
"it doesn't matter".

However, if we consider the ability to query the set of potentially-thrown exception types
using ~declthrow()~ then a program might want to query within the context of the handler, what types might
be thrown by a rethrow expression. i.e. ~declthrow(throw)...~.

The ability to query whether or not a given handler is reachable can be useful in eliminating code that would
otherwise be ill-formed, or that we want to avoid instantiating to reduce compile-times.

For example: Code for implementing the P2300 ~std::execution::then()~ algorithm needs to determine whether invoking
the transformation function might throw and only if it does then invoke the receiver with ~set_error()~, otherwise
it should not form a call to ~set_error()~.

For example:
#+begin_src c++
  template<typename... Args>
  void then_receiver::set_value(Args&&... args) noexcept {
    try {
      if constexpr (std::is_void_v<decltype(this->func(std::forward<Args>(args)...)>) {
        this->func(std::forward<Args>(args)...);
        std::execution::set_value(this->receiver);
      } else {
        std::execution::set_value(this->receiver, this->func(std::forward<Args>(args)...));
      }
    } catch (...) {
      // Only want to instantiate the call to set_error() if there are actually
      // any errors possible.
      if constexpr (noexcept(this->func(std::forward<Args>(args)...)) {
        std::execution::set_error(this->receiver, std::current_exception());
      }
    }
  }
#+end_src

Note that here we need to repeat the essential parts of the body of the try-block in a
constexpr if condition noexcept clause to determine whether or not the ~catch(...)~ block
was reachable. And while, for this example, the body only has one such expression, it
is relatively easy to conceive of try-block logic that could be much more involved.

If, instead, we were able to query whether or not the handler was reachable by querying
the set of exception types that might be thrown by ~throw;~ within that handler, then
we could avoid having to duplicate the body expressions in the constexpr if condition.

For example:
#+begin_src c++
  template<typename... Args>
  void then_receiver::set_value(Args&&... args) noexcept {
    try {
      if constexpr (std::is_void_v<decltype(this->func(std::forward<Args>(args)...)>) {
        this->func(std::forward<Args>(args)...);
        std::execution::set_value(this->get_receiver());
      } else {
        std::execution::set_value(this->get_receiver(), this->func(std::forward<Args>(args)...));
      }
    } catch (...) {
      // Only want to instantiate the call to set_error() if there are actually
      // any errors possible.
      //
      // declthrow(throw)... will produce the empty pack if the try-block body
      // is not potentially-throwing.
      if constexpr (sizeof...(declthrow(throw)...) != 0) {
        std::execution::set_error(this->get_receiver(), std::current_exception());
      }
    }
  }
#+end_src

Another design direction that could be taken here is to allow writing the catch-all handler
as a template catch that is instantiated with an exception declaration of ~std::exception_ptr~.
This could build upon the alternative suggested earlier for using ~std::exception_ptr~ in place
of ~std::any_exception~ for indicating the set of potenially-thrown exception types for a
call to a function with a dynamic exception specification.

If the body of the try-block had a set of potentially-thrown exception types that was empty
then the ~template catch~ handler would not be instantiated.

For example:
#+begin_src c++
  template<typename... Args>
  void then_receiver::set_value(Args&&... args) noexcept {
    try {
      if constexpr (std::is_void_v<decltype(this->func(std::forward<Args>(args)...)>) {
	this->func(std::forward<Args>(args)...);
	std::execution::set_value(this->get_receiver());
      } else {
	std::execution::set_value(this->get_receiver(), this->func(std::forward<Args>(args)...));
      }
    } template catch (auto error) {
      // Catch-block is only instantiated if there are any exceptions that might be thrown from code in the try-block.
      // If an exception is thrown by a 'throw(...)' function then 'error' will have type 'std::exception_ptr'.
      std::execution::set_error(this->get_receiver(), std::move(error));
    }
  }
#+end_src

****** Rethrow expression rules

If the rethrow expression is unassociated with a handler then the set of potentially-thrown exception types
for that rethrow expression is equal to the set { ~std::any_exception~ }.
This is because the expression could potentially be executed within the dynamic scope of any handler and
thus could rethrow any caught exception type.

Otherwise, if the rethrow expression is associated with a handler, /H/, then;

Let /E/ be the set of potentially-thrown exception types of the /compound-statement/ of the try-block associated with /H/.

Let /H-pre/ be the set of handlers associated with the same try-block as /H/ that precede /H/ in the try-block's /handler-seq/.

Let /X/ be initially the empty set.

For each type, ~e~, in the set /E/
- if ~e~ is ~std::any_exception~ then
  - if the /exception-declaration/ of /H/ is ~...~ then add ~std::any_exception~ to the set /X/
  - otherwise, let ~h~ be the type named in /H/'s /exception-declaration/
    - if any handler in /H-pre/ matches exceptions of type ~h~ then, do nothing (this handler is unreachable)
    - otherwise, if ~h~ is of non-class type or is a final class then add ~h~ to /X/
    - otherwise add ~std::any_exception~ to /X/ (it might handle an unbounded set of potential exceptions derived from ~h~)
- otherwise,
  - if any handler in /H-pre/ matches exceptions of type ~e~, then do-nothing
  - otherwise, if /H/ matches exceptions of type ~e~, then add ~e~ to /X/
  - otherwise, do nothing

The set of potentially-thrown exception types for a rethrow expression associated with /H/ is /X/.

Note that this algorithm can produce a set of potentially-thrown exception types that includes
a list of concrete exception types as well as ~std::any_exception~.

Note that these rules make the result of a ~declthrow(throw)~ expression context dependent.

****** Examples

Given the following declarations:
#+begin_src c++
  struct A {};
  struct B : A {};
  struct C : A {};
  struct D : B, C {};
  struct E final {};

  template<typename... Ts>
  void throws() throw(Ts...);
#+end_src

Example 1: static exception list, catch(...)
#+begin_src c++
  try {
    throws<A>();
  } catch (...) {
    throw; // declthrow -> { A }
  }
#+end_src

Example 2: static exception list, typed handler, unreachable catch (...)
#+begin_src c++
  try {
    throws<A>();
  } catch (A) {
    throw; // declthrow -> { A }
  } catch (...) {
    throw; // declthrow -> { }
  }
#+end_src

Example 3: multiple exceptions caught by single handler
#+begin_src c++
  try {
    throws<A, B>();
  } catch (A) {
    throw; // declthrow -> { A, B }
  } catch (...) {
    throw; // declthrow -> { }
  }
#+end_src

Example 4: multiple exceptions caught by multiple handlers
#+begin_src c++
  try {
    throws<A, B>();
  } catch (B) {
    throw; // declthrow -> { B }
  } catch (A) {
    throw; // declthrow -> { A }
  } catch  (...) {
    throw; // declthrow - > { }
  }
#+end_src

Example 5: ambiguous bases
#+begin_src c++
  try {
    throws<D>();
  } catch (A) {
    throw; // declthrow -> { } - empty because A is ambiguous base of D and so doesn't match
  } catch (B) {
    throw; // declthrow -> { D } - catch (B) unambiguously handles exceptions of type D
  } catch (C) {
    throw; // declthrow -> { } - already handled by catch (B)
  } catch (D) {
    throw; // declthrow -> { } - already handled by catch (B)
  }
#+end_src

Example 6: mixed static/dynamic
#+begin_src c++
  try {
    throws<A>();
    throws<std::any_exception>();
  } catch (A) {
    throw; // declthrow -> { std::any_exception, A }
  } catch (...) {
    throw; // declthrow -> { std::any_exception }
  }
#+end_src

Example 7: dynamic throw with final class
#+begin_src c++
  try {
    throws<std::any_exception>();
  } catch (E) {
    throw; // declthrow -> { E }
  } catch (...) {
    throw; // declthrow -> { std::any_exception }
  }
#+end_src

Example 8: mixed static/dynamic with final class
#+begin_src c++
  try {
    throws<E>();
    throws<std::any_exception>();
  } catch (E) {
    throw; // declthrow -> { E }
  } catch (...) {
    throw; // declthrow -> { std::any_exception }
  }
#+end_src

Example 9: template handler, single type
#+begin_src c++
  try {
    throws<A>();
  } template catch (auto e) { // Instantiated for types { A }
    throw; // -> declthrow -> { decltype(e) }
  }
#+end_src

Example 10: template handler, multiple types
#+begin_src c++
   try {
     throws<A, B, C, D>();
   } template catch (auto e) { // Instantiated for following types { D, B, C, A }
                               // handlers for derived types before handlers for base types
     throw; // declthrow -> { decltype(e) }
   }
#+end_src

Example 11: template handler + non-template handler
#+begin_src c++
  try {
    throws<A, B, C, D>();
  } catch (B) {
    throw;  // declthrow -> { B, D }
  } template catch (auto e) { // Instantiated for { C, A } - handlers for derived types before handlers for base types
    throw; // declthrow -> { decltype(e) } - either A or C
  }
#+end_src

Example 12: template handler + non-template handler + dynamic throw
#+begin_src c++
  try {
    throws<A, B, C, D>();
    throws<std::any_exception>();
  } catch (B) {
    throw; // declthrow -> { B, D, std::any_exception }
  } template catch (auto e) { // Instantiated for { C, A }
    throw; // declthrow -> { decltype(e) }
  } catch (...) {
    throw; // declthrow -> { std::any_exception }
  }
#+end_src

Note that for example 12 the template handler is instantiated for
types A and C and rethrowing within the template handler only
rethrows those concrete types, despite the possibility of the
~throws<std::any_exception>()~ potentially being able to throw
exceptions of type derived from either ~C~ or ~A~.

Example 13: constrained template handler + non-template handler + dynamic throw
#+begin_src c++
  try {
    throws<A, B, C, D>();
    throws<std::any_exception>();
  } template catch (std::one_of<B, C> auto e) { // instantiated for { B, C }
    throw; // declthrow -> { decltype(e) }
  } catch (A) {
    throw; // declthrow -> { A, D, std::any_exception }
  } catch (...) {
    throw; // declthrow -> { std::any_exception }
  }
#+end_src

Note that with this example, the compiler tries to instantiate the template
handler for each of the static exception types, but substitution fails for
types A and D, succeeding only for types B and C.

The handler for A matches A and D and potentially also an unbounded set of other types derived from A.

The final handler matches an unbounded set of types not derived from A.

**** /await-expression/

An expression of the form ~co_await /expression/~ has a set of potentially-thrown exception
types equal to union of the sets of potentially-thrown exception types of each of the
sub-expressions that the /await-expression/ de-composes into.

Including:
- The operand /expression/
- The call to ~p.await_transform(expr)~, if applicable.
- The call to member or non-member ~operator co_await~, if applicable.
- The calls to ~await_ready()~, ~await_suspend()~ and ~await_resume()~.
- A call to the destructors of any temporary objects created as a result of one of the above sub-expressions

Note that if one of the sub-expressions is an /interrupted-flow expression/ then we still consider the
set of potentially-thrown exception types of subsequently evaluated sub-expressions even though they
may be unreachable. If we want to consider ignoring unreachable sub-expressions then this should be
applied more generally across all expression evaluation.

**** /yield-expression/

A ~co_yield /assignment-expression/~ or ~co_yield /braced-init-list/~ expression has a
set of potentially-thrown exception types equal to the union of the sets of the potentially
thrown exception types of the expression ~co_await promise.yield_value(expr)~, where
~promise~ is an lvalue reference that refers to the current coroutine's promise object.

**** ~dynamic_cast~

Basically, any ~dynamic_cast~ expression to reference-type that could fail the runtime
check has a set of potentially-thrown exception types equal to the set { ~std::bad_cast~ }.

A ~dynamic_cast~ expression that is a cast to pointer-type or that was a cast to a reference
type that would not fail (e.g. because it was a cast to an unambiguous base-class of the operand's class type)
has an empty set of potentially-throw exception types.

Note that the wording of ~dynamic_cast~ currently permits implementations to throw some type
that would match a handler of type ~std::bad_cast~. This change would require that the exception
thrown was exactly the type ~std::bad_cast~.

**** ~typeid~

A ~typeid(/type-id/)~ expression has an empty set of potentially-thrown exception types.

A ~typeid(/expression/)~ expression has a set of potentially-thrown exception types equal
to { ~std::bad_typeid~ }. This exception may be thrown if the operand of the ~typeid~
expression is the result of dereferencing a null pointer of non-cv type.


While this behaviour matches the current specification of ~typeid~ expressions, supporting
the ability to ask for the type of a dereferenced null pointer seems to be of questionable
value. The wording for the builtin unary ~*~ operator in [expr.unary.op] says that the behaviour
of performing an indirection on a pointer that does not point to a function or object is
undefined /except as specified in [expr.typeid]/.

So, literally the only thing you can do with an lvalue produced by dereferencing a null pointer
is pass it to a ~typeid~ expression.

It may be worth exploring whether we can either deprecate/remove this behaviour from ~typeid~
(which would be a breaking change) or whether we can add a new form of ~typeid(/expression/)~
that has a precondition that the /expression/ does result in an glvalue that refers to an
object or function. i.e. passing a dereferenced null pointer is undefined-behaviour.

This would allow the set of potentially-thrown exception types for a ~typeid~ expression
to be empty.

**** Name expressions

Expressions that simply name an object

These expressions include:
- /id-expression/
- ~this~
  
These expressions have an empty set of potentially thrown exception types.

**** Lambda expressions

The set of potentially-thrown exception types of a lambda expression are
the union of the set of potentially thrown exception types of the initializers
of the lambda captures.

** Template handlers

Template handlers are the static-exception equivalent of a ~catch(...)~.

They allow a generic handler to be written that can be instantiated to handle any
number of exception types statically. The compiler instantiates the handler based
on the set of potentially-thrown exception types computed for the body of the
corresponding ~try~ block which were not caught by any preceding handlers.

The short-hand syntax allows the user to prefix the ~catch~ keyword with the
~template~ keyword and then use a /placeholder-type-specifier/ as the /exception-declaration/.

For example:
#+begin_src c++
  void do_something() throw(A, B, C);

  try {
    do_something();
  } template catch (auto e) {
    // catch-block instantiated for each unique type in the static-exception specification
    // In this case where 'e' has type A, B or C.
  }
#+end_src

The ~template~ keyword is technically redundant in this case as we could deduce that the handler
is a template from the use of a /placeholder-type-specifier/. However, the use of the keyword
~template~ here can also serve as an indication in code that something a bit different is going
on.

The requirement for the ~template~ keyword could potentially be dropped in this case if desired
to match consistency with the syntax for function declarations.

The short-hand syntax also allows a trailing /requires-clause/ to be added after the /exception-declaration/
to allow introducing type-constraints on the instantiation of the template handler.

For example:
#+begin_src c++
  void do_something() throw(A, B, C);

  try {
    do_something();
  } template catch (auto e) requires std::derived_from<decltype(e), std::exception> {
    // catch block only instantiated for types that inherit from ~std::exception~.
    LOG("error: %s", ex.what());
  } template catch (auto e) {
    // handle types not inherited from std::exception
  }
#+end_src

The more general syntax for a template catch-block allows the use of a /template-head/ before the
~catch~ keyword and then refer to to a dependent type that allows any template parameters declared
in the /template-head/ to be deduced from the type of the exception.

For example: Alternative to ~template catch (auto e)~ using the /template-head/ syntax
#+begin_src c++
  try {
    do_something();
   }
   template<typename T>
   catch (T e) {
     //... do something with 'e'
  }
#+end_src

For example: Using constraints and deduced template arguments for a class template
#+begin_src c++
  template<typename Inner>
  struct MyException : std::exception {
    const char* what() noexcept override { return "MyException"; }
    Inner inner;
  };

  try {
    do_something();
  }
  template<std::derived_from<std::exception> Inner>
  requires (!std::derived_from<Inner, std::runtime_exception>)
  catch (MyException<Inner> err) {
    LOG("Failed with MyException because: {}", err.inner.what());
  }
#+end_src

Template handlers can also then be used with ~if constexpr~ to handle
a given exception based on static properties of the exception type.

For example:
#+begin_src c++
  template<typename T, typename Inner>
  struct NestedException : public T {
    Inner inner;
  };

  template<typename T>
  constexpr bool is_nested_v = false;
  template<typename T, typename Inner>
  constexpr bool is_nested_v<NestedException<T, Inner>> = true;

  void foo() throw(FooError,
		   NestedException<FooError, std::bad_alloc>,
		   NestedException<FooError, std::system_error>);

  try {
    foo();
  } template catch (std::derived_from<FooError> auto err) {
    // generic FooError handling
    if constexpr (is_nested_v<decltype(err)>) {
      std::print("error: Failed with FooError because {}", err.inner);
    } else {
      std::print("error: Failed with FooError");
    }
  }
#+end_src

*** Template argument deduction

When the compiler is trying to determine which handler, if any, will match
a static exception object thrown from the body of a /try-block/, it proceeds
to try each handler in order. If a handler matches the exception type then
the compiler stops searching and does not look at any subsequent handlers.

If, during the search for a matching handler, the compiler encounters a template
handler, then the compiler performs the following to determine whether the
handler is a match:
- Attempts to deduce template arguments of the template handler by treating
  the handler as if it were a function template with a single argument and
  then forming a call to that function-template, passing a single argument
  which is a non-const lvalue reference to the static exception object.
  However, this is done with the restriction that the only conversions allowed
  are implicit conversion to an unambiguous base-class.
- If template argument deduction fails then the handler is not a match.
- Otherwise, if template argument deduction succeeds, then any constraints
  are evaluated using those deduced template arguments.
- If those constraints are not satisfied then the handler is not a match.
- Otherwise, the handler is a match and the body of the handler is instantiated
  with the deduced template arguments, substituting those template arguments
  into the body of the handler. The resulting handler instantiation becomes
  the handler for static exception objects of that type.

If a handler template is never instantiated (i.e. because it did not match
any thrown static exception object types) then the /compound-statement/ of
that handler does not contribute any statements to the body of the enclosing
function.

This can potentially affect the return-type of a function with a deduced return-type.

For example:
#+begin_src c++
  auto example(auto f) throw(X) {
    try {
      f();
    }
    template catch (auto err) {
      return err;
    }

    throw X{};
  }

  example([] throw() {}); // deduces return type to be 'void' as return statement never instantiated
  example([] throw(int) {}); // deduces return type to be 'int' - single return statement
  example([] throw(int, long) {}); // ill-formed: multiple return statements with different deduced return types
#+end_src

*** Matching dynamic exception objects

The proposed design is such that a template handler does not match a thrown
dynamic exception object, so if the body contains any ~throw(...)~ expressions
then the handler sequence will still require a ~catch(...)~ handler as the
last handler to handle those.

However, one design direction being explored is to allow a dynamic-exception-object
to match template and non-template handlers as if the exception object had type
~std::exception_ptr~. In this case, a ~template catch (auto e)~ would be
instantiated with ~decltype(e)~ deduced to ~std::exception_ptr~.

*** Ordering of instantiated handlers 

For the purposes of determining which handler is a match, instantiations of a given
handler template are unordered. If multiple instantiations would potentially match a
given handler when written out then which one is chosen is determined by deducing
template arguments and choosing that instantiation rather than looking at which one
appears earlier in a list of instantiations.

** Virtual Functions

Virtual functions declared on a base-class can potentially have a different (wider) exception
specification than an override of that virtual function declared in a derived class.

For example: A base class might declare a virtual function as ~noexcept(false)~ whereas a
derived class might declare its override as ~noexcept(true)~.

However, a derived class cannot have an exception-specification that is wider than the base
class method. Callers of a base-class virtual method marked ~noexcept~ can rightly expect that
derived classes cannot override this method to start throwing exceptions from the call.

If we want to extend this idea to throw-specifications, then we need to require that
an override of a virtual function does not widen the set of potentially-thrown exception
types.

If a base class has a virtual function with an exception specification that is
~noexcept(false)~ or ~throw(...)~ then an override of this function in a derived
class can have any exception-specifier.

Example 1
#+begin_src c++
  struct base {
    virtual void f() throw(...);
  };

  struct derived1 : base {
    void f() throw() override; // OK
  };
  struct derived2 : base {
    void f() throw(A, B, C) override; // OK
  };
  struct derived3 : base {
    void f() throw(...) override; // OK
  };
#+end_src

If a base-class has a virtual function with an exception specification that is
~noexcept(true)~ or ~throw()~ then an override of this function must also have
an exception specification that is either ~noexcept(true)~ or ~throw()~.

Example 2
#+begin_src c++
  struct base {
    virtual void f() throw();
  };

  struct derived1 : base {
    void f() throw() override; // OK
  };
  struct derived2 : base {
    void f() throw(A, B, C) override; // ERROR: f() has wider exception specification than base::f()
  };
  struct derived3 : base {
    void f() throw(...) override; // ERROR: f() has wider exception specification than base::f()
  };
#+end_src

If a base-class has a virtual function with a non-empty static exception specification
then an override of this function must have a static exception specification that
is a subset of the set of exception types listed in the base class exception specification.

Example 3
#+begin_src c++
  struct base {
    virtual void f() throw(A, B);
  };

  struct derived1 : base {
    void f() throw(A, B) override; // OK
  };
  struct derived2 : base {
    void f() throw(A) override; // OK
  };
  struct derived3 : base {
    void f() throw(B) override; // OK
  };
  struct derived4 : base {
    void f() throw() override; // OK
  };
  struct derived5 : base {
    void f() throw(A, C) override; // ERROR: Throws C which is allowed by base::f() throw specification
  };
  struct derived6 : base {
    void f() throw(...) override; // ERROR: f() has wider exception specification than base::f().
  };
#+end_src

It is worth noting here that virtual function overrides are only permitted to throw
a subset of the set of types listed in the throw-specification of the base class declaration.
They are not permitted to throw types not listed in the throw-specification that are derived
from the types listed in the base class declaration.

Virtual functions that want to allow overrides to throw types not listed in the
base class function's throw-specification should declare the base-class virtual
function with the ~noexcept(false)~ or ~throw(...)~ specifier to indicate that
a dynamic exception type may be thrown.

*** ABI of virtual functions with differing exception specifications

While the language semantics described above are a natural extension of the current rules around
noexcept, they do have some impacts on what implementations need to do to provide these
semantics.

A virtual function with a non-empty static exception-specification can have a different
calling-convention to a function with a different exception-specification.

This means that in cases where an override chooses to narrow the exception specification
that we may not be able to directly use a pointer to the overridden function in the
vtable slot used for a call that dispatches statically via the base class interface
as the calling conventions may not match.

This is a similar case to how the compiler needs to handle overrides that can have
covariant return-types that return a pointer/reference to some type that is derived
from the return-type of the base class.

In many cases the ABI of the override that returns a derived type is the same as the
ABI of the base class function.

For example:
#+begin_src c++
  struct base {
    virtual base* clone();
  };
  struct derived : base {
    derived* clone() override;
  };
#+end_src

In this case, the ~derived~ class has the ~base~ class as its first sub-object
and so the address of the ~derived~ object returned by ~derived::clone()~ can be
reused as the address of the ~base~ object and so the vtable entries for calling
~base::clone()~ and ~derived::clone()~ can be the same.

However, if you consider:
#+begin_src c++
  struct base {
    virtual base* clone();
  };
  struct other_base {
    virtual std::string to_string();
  };
  struct derived : other_base, base {
    derived* clone() override;
  };
#+end_src

Now, the ~base~ object is not necessarily the first sub-object of a ~derived~ and
so the pointer returned by ~derived::clone()~ may need to be adjusted by an offset
when called via the ~base::clone()~ interface so that the returned pointer refers
to the ~base~ sub-object.

This means that the vtable entry for ~base::clone()~ cannot just contain the address
of the ~derived::clone()~ function as it would return an address that was not a
pointer to the ~base~ sub-object.

Instead, the table entry for ~base::clone()~ in the ~derived~ type's vtable contains
the address of a "thunk" - a function stub that forwards the call onto the real
implementation and then adjusts the returned address by applying the necessary offset.

When a call is made via the ~derived::clone()~ interface, it instead dispatches to
a separate vtable entry that directly calls the ~derived::clone()~ function.

The same approach would be required whenever a base-class virtual function is overridden
by a derived class that has an exception-specification that differs such that it has a
different calling convention and is thus ABI incompatible with the ABI of the base
class function's ABI.

These thunks would be the kind of thunk that is generated when you cast a function
to a function-pointer with a different exception-specification, described in 
[[id:d0523c1d-8c67-4876-a4f7-183a3fa451f7][Static exception specifications are part of the function type]].

** Concepts

A ~requires~ expression allows checking that certain expressions are ~noexcept~.

For example:
#+begin_src c++
  template<typename T, typename U>
  concept nothrow_assignable_from =
    requires(T t, U u) {
      { static_cast<T&&>(t) = static_cast<U&&>(u) } noexcept;
    };
#+end_src

This concept checking that the assignment expression is valid and that the set
of potentially thrown exceptions for the expression is the empty set.

It is equivalent to the following, only without the repetition of expressions:
#+begin_src c++
  template<typename T, typename U>
  concept nothrow_assignable_from =
    requires(T t, U u) {
      static_cast<T&&>(t) = static_cast<U&&>(u);
    } &&
    noexcept(std::declval<T&&>() = static_cast<U&&>(u));
#+end_src

If we are to introduce static exception specifications then it seems reasonable to
also want to extend the requires-expression syntax with the ability to check that
the set of potentially-thrown exceptions from an expression satisfies some requirement.

For example, say we wanted to check that a given member-function-call could only throw ~std::bad_alloc~,
we we could allow the user to write something like:
#+begin_src c++
  template<typename T>
  concept foo_factory =
    requires(T& obj) {
      { obj.make_foo() } throw(std::bad_alloc) -> foo_concept;
    };
#+end_src

However, from this syntax it's not clear exactly what the semantics of such a check should be.
It could be:
- Check that the set of potentially-thrown exceptions is a subset of the listed types.
  e.g. because it needs to be callable from a function with a ~throw(std::bad_alloc)~ specifier.
- Check that the set of potentially-thrown exceptions would be caught by a handler whose
  exception-declaration is ~std::bad_alloc~.
  e.g. because the expression needs to be callable from within a ~noexcept~ function but is
  surrounded by a try/catch that catches and handles ~std::bad_alloc~.

This confusion/ambiguity is similar to the one that was raised during the design of contracts
for C++20 - is a ~{ expr } -> T;~ clause in a requires-expression checking that the expression
results in exactly type ~T~, or is it checking that the expression is convertible to type ~T~?

The approach taken to resolve this was to require that you specify a concept that the result of
the expresion needs to match. This forces the user to be explicit about intent.
i.e. either write ~std::same_as<T>~ or ~std::convertible_to<T>~.

Thus this paper proposes taking a similar approach.
i.e. to extend the /compound-requirement/ as follows:

#+begin_src text
  /compound-requirement/:
     { /expression/ } /exception-requirement[opt]/ /return-type-requirement[opt]/ ;

  /exception-requirement/:
     noexcept
     /throw-requirement/

  /throw-requirement/:
     throw ( /type-constraint/ )
#+end_src

The propsed semantics of providing a /throw-requirement/ as part of a /compound-requirement/ are as follows.

The set of potentially-thrown exceptions is computed by applying ~declthrow()~ query to the expression.

The requirement is satisfied if, for each type produced in the expanded pack produced by the ~declthrow()~
query, the type satisfies the specified /type-constraint/.

i.e. If the /throw-requirement/ was ~throw(C)~, then the requirement is satisfied if ~(C<declthrow(expr)> && ...)~ is ~true~.

If we wanted the above example to mean "Any exceptions caught by a handler for type ~std::bad_alloc~"
then we could write the concept as follows:
#+begin_src c++
  template<typename T>
  concept foo_factory = 
    requires(T& obj) {
      { obj.make_foo() } throw(std::derived_from<std::bad_alloc>) -> foo_concept;
#+end_src

Or, if you want to check that the only exception thrown (if any) is exactly ~std::bad_alloc~ then
replace the use of ~std::derived_from~ with ~std::same_as~.

To handle the case where you want the expression to be one of a set of types,
e.g. because the expression is called from a function that is only allowed to
emit those exception types, you can use the ~one_of~ concept helper.
#+begin_src c++
  template<typename T, typename... Ts>
  concept one_of = (std::same_as<T, Ts> || ...);

  template<typename T>
  concept foo_factory =
    requires(T& obj) {
      { obj.make_foo() } throw(std::one_of<A, B, C>) -> foo_concept;
    };

  void usage(foo_factory auto& factory) throw(A, B, C) {
    auto foo = factory.make_foo();
    // ...
  }
#+end_src

It is expected this should cover most scenarios that users will want to write.

For other scenarios, expressions involving direct use of ~declthrow()~ queries can be used
to for more complicated type-constraints.

** Coroutines

Coroutines have several areas that require updates to support static exception specifications:
- Extensions to ~unhandled_exception()~ function of a coroutine's promise-type to allow handling
  static exception objects.
- Rules for computing the exception specification of a coroutine with a deduced throw specificiation

The rules for computing the set of potentially thrown exceptions for ~co_return~ statements and
~co_await~ and ~co_yield~ expressions are already described above.

*** Coroutine promise object handling for static exception objects

The current behaviour of a coroutine with a given /function-body/ is specified to be as if the /function-body/ were replaced by:
#+begin_src c++
  {
    /promise-type/ promise /promise-constructor-arguments/ ;
    try {
      co_await promise.initial_suspend();
      /function-body/
    } catch (...) {
      if (!initial-await-resume-called)
	throw;
      promise.unhandled_exception();
    }
  final_suspend:
    co_await promise.final_suspend();
  }
#+end_src

The only way that the ~promise.unhandled_exception()~ object can observe the current exception object
is by either performing a dynamic rethrow expression, ~throw;~, or by calling ~std::current_exception()~.
This would force any static exception object to be copied to a dynamic exception object, which negates
the benefit of static exceptions.

Also, we may want to define a coroutine promise type such that the coroutine body itself cannot throw
types other than a specified set of potentially-thrown exception types.

To support these use-cases, we can modify the above translation as follows:
#+begin_src c++
  {
    /promise-type/ promise /promise-constructor-arguments/ ;
    try {
      co_await promise.initial_suspend();
      /function-body/
    } template catch (auto& ex) {
      // Static exception objects caught here
      if (!initial-await-resume-called)
	throw;

      if constexpr (can_handle_exception</promise-type/, decltype(ex)>) {
	promise.unhandled_exception(ex);
      } else if (can_handle_exception</promise-type/, std::exception_ptr>) {
	promise.unhandled_exception(std::make_exception_ptr(std::move(ex)));
      } else {
	promise.unhandled_exception();
      }
    } catch (...) {
      // Dynamic exception objects caught here
      if (!initial-await-resume-called)
	throw;

      constexpr bool is_handler_reachable = sizeof...(declthrow(throw)) > 0;
      if constexpr (is_handler_reachable) {
	if constexpr (can_handle_exception</promise-type/, std::exception_ptr>) {
	  promise.unhandled_exception(std::current_exception());
	} else {
	  promise.unhandled_exception();
	}
      }
    }
  final_suspend:
    co_await promise.final_suspend();
  }
#+end_src

Where the following exposition-only concept is defined:
#+begin_src c++
  template<typename P, typename E>
  concept can_handle_exception =
    requires(P& promise, E& ex) {
      p.unhandled_exception(ex);
    };
#+end_src


If a thrown static exception object, ~ex~, escapes the body of the coroutine then the exception is caught
and one of the following expressions is evaluated, tried in-order;
  - Call ~promise.unhandled_exception(ex)~, if that expression is valid; otherwise
  - Call ~promise.unhandled_exception(std::current_exception())~, if that expression is valid; otherwise
  - Call ~promise.unhandled_exception()~ if that expression is valid; otherwise
  - The program is ill-formed
If a thrown dynamic exception object escapes the body of the coroutine then the exception is caught
and one of the following expressions is evaluated, tried in-order;
  - Call ~promise.unhandled_exception(std::current_exception())~, if that expression is valid; otherwise
  - Call ~promise.unhandled_exception()~, if that expression is valid; otherwise
  - The program is ill-formed

Some key points to note here:
- The ~unhandled_exception()~ method can now optionally take a parameter that accepts an
  lvalue-reference to the static exception object
  - It is a non-const reference to allow the implementation to move/mutate the exception object
    if desired.
- The ~unhandled_exception()~ method can also optionally take a parameter of type ~std::exception_ptr~
  to refer to the current exception.
  - This can be potentially more efficient on some platforms than having the ~unhandled_exception()~
    method call ~std::current_exception()~ since, in the case of a static exception object being thrown,
    it has a reference to the exception object already and so doesn't necessarily have to access the
    thread-local values inside ~std::current_exception()~.
  - It also allows some freestanding implementations that do not support thread-locals and thus do not
    support ~std::current_exception()~ to still allow type-erasing exception objects in a ~std::exception_ptr~.
- We only try to form a call to ~promise.unhandled_exception()~ if the handler is potentially-reachable.
  i.e. if either the ~await_resume()~ method on the initial-suspend awaiter object is potentially-throwing
  or if the /function-body/ of the coroutine is potentially-throwing.
  - This differs from C++20 which always requires that a promise type has an ~unhandled_exception()~ object.
  - This also means that a coroutine promise-type that does not define any ~unhandled_exception()~
    member function can still be used as long as the set of potentially-thrown exceptions from the function-body
    is the empty set.

Together, these changes will allow a coroutine promise type to store and/or inspect an exception object without
having to first dynamically rethrow the exception, or if [[https://wg21.link/P2927][P2927]] is adopted, have to allocate a dynamic exception
object and call ~try_cast<T>()~ to check if it has type

For example, say we wanted to write a coroutine type that only permitted exceptions of type ~A~ and ~B~
to exit the coroutine body, we could define it to have a promise-type that had the following
~unhandled_exception()~ member-function.

#+begin_src c++
  struct my_promise_type {

    // ... rest of promise type omitted for brevity

    void unhandled_exception(one_of<A, B> auto& ex) throw() {
      constexpr std::size_t index = std::same_as<decltype(ex), A&> ? 2 : 3;
      result.emplace<index>(std::move(ex));
    }

    std::variant<std::monostate, value_type, A, B> result;
  };
#+end_src

If any other exception than ~A~ or ~B~ escapes the function body then the compiler will fail to
find a suitable overload for a call to ~promise.unhandled_exception()~ and will be considered ill-formed.
This allows the author of a coroutine type to mimic the equivalent throw-specification checking that
normal functions with a ~throw(A, B)~ specfication does.

This will allow async coroutines to efficiently propagate static-exception objects through chains of
coroutines without needing to invoke any of the dynamic exception machinery of the C++ runtime.

*** Computing the exception specification of a coroutine with a deduced throw specification

When a coroutine is invoked, the call to the coroutine does not necessarily invoke the entire body
of the coroutine. The coroutine may suspend at the initial-suspend point and then return immediately.

Also, once the execution of the coroutine reaches a certain point during the execution of the initial-suspend
expression, any exceptions that exit the coroutine body from that point are caught and directed to the
promise object's ~unhandled_exception()~ member-function, as described in the previous section.

This means that the set of potentially-thrown exceptions of the initial call to the coroutine is
different from the set of potentially-thrown exceptions of the coroutine function-body that the
user writes.

This section defines the steps for computing the deduced throw specification of a coroutine
that accurately matches the set of potentially-thrown exception types of the initial invocation
of a coroutine.

The steps involved in the initial call to a coroutine are:
- allocating the coroutine frame, calling ~promise_type::operator new()~ if present and viable, otherwise
  calls global ~operator new~.
- copying/moving parameters of the function to the coroutine-frame
- constructing the promise object, optionally passing lvalues of the parameter copies to the promise constructor
- calling ~promise.get_return_object()~
- calling ~promise.initial_suspend()~
- calling ~operator co_await()~ on the returned object, if one is defined
- calling ~await_ready()~ on the awaiter
- calling ~await_suspend()~ on the awaiter


*************** TODO Finish describing how to compute the set of potentially-thrown exceptions for a coroutine with deduced throw specification
*************** END

** Type traits

The standard library has a number of traits queries that let you query properties about
certain operations and whether or not they are "nothrow".

*** Nothrow queries

The existing ~std::is_nothrow_*~ traits are specified in terms of ~noexcept~ expressions.

As the ~noexcept~ operator will still "do the right thing" for expressions that have static
exception specifications (i.e. will return ~false~ if there is a non-empty static exception
specification) these existing type-traits should not require any changes in specification.

It is not expected that implementations will require any changes to these traits.

*** ~std::is_function~ and ~std::is_member_function_pointer~

While the specification of these traits need not change, as they are just defined in terms
of whether or not a given type is a function type, there may be some changes to standard
library implementations which use partial specialization of all of the different forms
of functions.

It is noted that libc++, libstdc++ and MSSTL all either are defined in terms of compiler
intrinsics, which would need to be updated as part of implementing this feature, or are
defined in terms of other properties of the type. For example, by computing ~is_function_v<T>~
by checking whether the result of evaluating ~is_const_v<const  T> && !is_reference_v<T>~ is ~true~.

*** Additional traits

It's possible we may want to add some additional traits for querying information about
static exception specifications of certain expressions, however this has not yet been
explored.

It is expected that any such traits could be added in future as and when a need for
them has been established.

** Freestanding

*************** TODO Describe which aspects of exceptions could be used in freestanding.
Allowed:
- static throw expression
- static rethrow expression
- template catch
Disallowed:
- dynamic throw expression
- dynamic rethrow expression
- exception_ptr
- uncaught_exceptions()
- current_exception()
*************** END


* Prior Work
:PROPERTIES:
:ID:       62c9aff2-91ea-4bb4-a3f4-b01c3ab593ef
:END:

** Throw specifications and noexcept

- [[https://wg21.link/N2855][N2855]] - Rvalue References and Exception Safety (2009)
  - Discusses the problem with move-constructors and providing strong exception-safe guarantee,
    which motivates some way for the library to check whether an expression/move-ctor can throw.
  - Proposes introducing the ~noexcept~ specifier
  - Originally proposed to have ~noexcept~ functions be ill-formed if any exception could
    potentially escape the function.
  - Proposed to use syntax ~throw(...)~ to mean "this function can throw any exception."
    This eventually became ~noexcept(false)~.
  - Proposes making destructors ~noexcept~ by default.
  - Proposes adding a ~noexcept~ block that allows telling the compiler to assume that no
    exceptions will propagate out of this block. e.g. where exceptions are a dynamic property
    that is guarded against by other means.
    #+BEGIN_SRC c++
      double sqrt(double);

      noexcept void f(double& x) {
        if (x > 0) {
          noexcept { x = sqrt(x); } // okay: if sqrt(x) throws, invokes undefined behaviour
        }
      }
    #+END_SRC
    - Would need something similar to make it easy to suppress errors about unhandled exceptions.
      #+BEGIN_SRC c++
        void f(double& x) throw() {
          if (x > 0) {
            try { x = sqrt(x); }
            catch (...) { std::unreachable(); /* or std::terminate(); */ }
          }
        }
      #+END_SRC

  - Proposes that exception specifications are deprecated
    - Lack of static checking has limited usability and ocnfused users
    - Provide few benefits for compilers
    - Not useful in generic code, where functions need to know whether an exception can the thrown or not, but don't know (or care) what kind of exceptions can be thrown.
    - In fact, the noexcept specifier---along with the ability to detect whether an operation is noexcept via concepts---provides precisely the statically-checked exception specifications that are required in C++ code.

- N2983 Allowing Move Constructors to Throw (2009)
  - Proposes use of ~std::move_if_noexcept()~ in move-constructors that require strong exception-safety guarantee.
  - Proposes new ~noexcept(<expr>)~ expression.
  - Proposes a parameterised ~noexcept(<bool-expr>)~ function specifier.
  - Suggests making destructors ~noexcept~ by default.

- [[https://wg21.link/N3051][N3051]] - Deprecating exception specifications
  - Talks about shortcoming of original throw-specifications
    - Run-time checking
      - Offers programmer no guarantees all exceptions have been handled.
      - ~std::unexpected()~ does not lend itself to recovery.
    - Run-time overhead
      - Run-time checking requires compiler to generate extra code, which hampers optimisations.
    - Unusable in generic code
      - Not generally possible to know what types of exceptions may be thrown from operations on template arguments, so precise exception specification cannot be written.
  - Claims that there are only two useful exception-specifications: throws-something and throws-nothing.
  - Proposes deprecation of ~throw()~ specifications as ~noexcept~ covers the two useful cases.
  - Also proposed that ~noexcept~ was equivalent to ~throw()~ on a declaration, but differed
    in semantics when it was placed on the definition.

- [[https://wg21.link/N3103][N3103]] - Security impact of noexcept
  - Says that a program that continues after noexcept function exits with an exception can
    lead to undefined/unexpected-behaviour that can be exploited by a malicious user to bypass
    security restrictions and/or cause denial-of-service attacks.
  - Proposes mandating that the program should terminate if there is ever an unhandled exception
    that is about to exit a noexcept function.

- [[https://wg21.link/N3248][N3248]] - noexcept prevents library validation (2011)
  - The "Lakos Rule" paper
    - don't put noexcept on functions with narrow contracts
    - so we can test assertions/preconditions
  - The risk from overly aggressive use of noexcept specifications is that programs with hidden terminate calls are produced
  - The risk of under-specifying noexcept specifications is that they become difficult to add in a later
    revision of the standard, as the noexcept operator becomes an observable part of the ABI.
  - Long list of library changes to roll back use of noexcept.

- [[https://wg21.link/N3279][N3279]] - Conservative use of noexcept in the Library (2011)
  - Summary of N3248 that just describes the guidelines for use of noexcept

- N4133 - Cleanup for exception-specification and throw-expression
  - N4285 - Cleanup for exception-specification and throw-expression
  - Editorial wording cleanup
  - Introduces "exception specification" semantic concept separate from the grammar term exception-specification.
  - Wording changes from "throws an exception" to "exits via an exception"

- N4320 - Make exception specifications be part of the type system (2014)
- N4518 - Make exception specifications be part of the type system, version 2 (2015)
- N4533 - Make exception specifications be part of the type system, version 3 (2015)
- P0012R0 -     Make exception specifications be part of the type system, version 4 (2015)
- P0012R1   Make exception specifications be part of the type system, version 5

- P0003R0 -         Removing Deprecated Dynamic Exception Specifications (2015)
- P0003R2   Removing Deprecated Dynamic Exception Specifications from C++17 (2016)
- P0003R5   Removing Deprecated Exception Specifications from C++17 (2016)


** Java Checked Exceptions

*** Background On How Exceptions work in Java

In the Java exception model all exception types inherit from the ~Throwable~ base class.
A ~throw~ expression can only throw objects that inhert frim ~Throwable~.

There are a number of important base-classes for exceptions defined in

- ~Throwable~ - Base-class for all types that can be thrown
  - ~Error~ - Base-class for bugs (assertion failures) or more serious problems with the runtime (e.g. ~StackOverflowException~, ~OutOfMemory~).
    Applications are not expected to handle these errors.
  - ~Exception~ - Base-class for conditions that an application may need to handle.
    - ~RuntimeException~ - Base-class of conditions that might be raised at any time by the runtime.
      e.g. ~NullPointerException~, ~IndexOutOfBoundsException~, etc.
      
Types inheriting from ~Throwable~, directly or indirectly, are classified as
either "checked" exceptions, or "unchecked" exceptions.

Types inheriting from either ~Error~ or ~RuntimeException~ are "unchecked" exceptions.
These could potentially be raised by the runtime at any time and may not require an
explicit ~throw~ expression in user-code.

Types inheriting from ~Throwable~ that are not "unchecked" exceptions are classified
as "checked" exceptions.

This property of being "checked" or "unchecked" is a property of the type.
A checked exception type is always a checked exception type, regardless of context.

Functions in Java have an optional ~throws~ clause that is placed after the argument list.

For example:
#+begin_src java
  public void foo() throws IOException {
      // ...
  }
#+end_src

If a function can potentially throw a checked exception then it must list that checked
exception type, or one of its base-classes, in the throws clause, otherwise the program
is ill-formed.

A function is allowed to list unchecked exception types in its throws clause, but is
not required to.

*** Criticisms of Java Checked exceptions




** Midori

Midori was an internal research/incubation project at Microsoft that explored ways of
innovating the software stack, including programming languages, compilers, operating-systems,
services, applications and overall programming models.

Joe Duffy has written an excellent [[https://joeduffyblog.com/2015/11/03/blogging-about-midori/][blog series]] about the Midori project, which is generally
a good read which I highly recommend. However, there is one article in particular on the
[[https://joeduffyblog.com/2016/02/07/the-error-model/][Midori Error Model]] that is worth discussing here as it contains a lot of good ideas and
also critique of error models of other languages, including Java's checked exceptions
and C++ exceptions.

The critique of what he calls the "unchecked exceptions" model:
#+begin_quote
In this model, any function call  and sometimes any statement  can throw an exception,
transferring control non-locally somewhere else. Where? Who knows.
There are no annotations or type system artifacts to guide your analysis.
As a result, its difficult for anyone to reason about a programs state at the time of the throw,
the state changes that occur while that exception is propagated up the call stack  and possibly
across threads in a concurrent program  and the resulting state by the time it gets caught or goes unhandled.
#+end_quote




** Deducing exception specifications
:PROPERTIES:
:ID:       02f589c7-b738-439d-a886-ed5ccdf08a72
:END:

- N3202 - To which extent can noexcept be deduced (Bjarne) (2010)
  - Summarises N3227
    - "almost every  statement in function tempaltes leak into the noexcept declaration"
    - "a user-maintained noexcept increases the likelihood that the specification is not
      correct. In turn this implies (a) an increased chance that client code terminates
      unexpectedly, or (b) that optimization opportunities are lost. (Note tha providing
      correct warnings is also undecidable.)
    - client code can still change (fail to compile, different runtime behaviour) if
      noexcept is added or removed from a library.
    - Questions of consistency of deducing noexcept declarations:
      #+BEGIN_QUOTE
      The idea of noexcept is to allow code to be written to take
      advantage of knowing that code will not throw. The key observation is that if we fail to deem a
      function noexcept even though it doesnt throw the worst that can happen is that sub-optimal,
      but still correct, code will be executed. In other words, as long as we dont mistakenly deem a
      throwing function noexcept, not serious harm is done.      
      #+END_QUOTE
    - Walks through some cases where there might be inconsistencies in deducing the noexceptness
      in different contexts.
      - This seems to be based on the assumption that it needs to be an implicit deduction rather
        than explicit opt-in for each function.

- [[https://wg21.link/N3207][N3207]] - noexcept(auto) (2010)
  - Highlights issues with implicit deduction in N3202
    - Easy to accidentally introduce ODR violations
    - Issues with eager function template instantiation to determine function signature/noexceptness
      (not SFINAE friendly).
  - Proposes ~noexcept(auto)~ as in-between compromise between having to duplicate body in noexcept declaration, and fully implicit, which has issues
  - Doesn't let mutually recursive functions all have their noexcept-specification deduced
    #+BEGIN_SRC c++
      struct A {
        void f(int i) noexcept(auto)
          { if (i > 1) g(i-1); } // call to g()  is ill-formed as it's noexcept specifier is incomplete.
        void g(int i) noexcept(auto)
          { if (i > 1) f(i-1); }
      };
    #+END_SRC
  - Also mentions this example as being ill-formed, but it looks ok to me:
    #+BEGIN_SRC c++
      template<bool> struct M;
      template<> struct M<true> { int large[100]; };
      template<> struct M<false> { char small; };
      struct B {
        template<bool> void maybe_throw();
        template<> void maybe_throw<true>() noexcept(auto) { throw 0; } // deduced noexcept(false)
        template<> void maybe_throw<false>() noexcept(auto) { } // deduced noexcept
        void f() noexcept(auto) { maybe_throw<(sizeof(B) > 10)>(); };
        M<noexcept(f())> data; // ill-formed because the noexcept-specification for f() is not yet deduced.
      };
      // Definition of f() isn't available until the end of the class-definition, here.
    #+END_SRC
  - Recursion is also interesting:
    #+BEGIN_SRC c++
      int f(int i) noexcept (auto) 
      {
        if (i == 0)
          return i;
        else
          return f(i-1)+i;
      }
    #+END_SRC
    Should in theory be deducible, but similar to mutually recursive functions
    - What about the following:
      #+BEGIN_SRC c++
        int f(int i) noexcept (auto) {
          if constexpr (noexcept(f(i-1))) {
            throw X{};
          } else {
            return i;
          }
        }
      #+END_SRC
      Such a function is self-contradicting.
      - Could allow calls to ~f()~ but is ill-formed if you query ~noexcept(f())~?

    - Minutes:
      - dislike of noexcept(auto) with SFINAE on exception-specifications; having only the latter without the former is ok
      - you can't overload on exception-specifications, why do you want to SFINAE on it?
      - can delay determining exception-specification until the function was selected in overload resolution
      - Issue with non-template deduced member inside class template
        #+BEGIN_SRC c++
          template<class T1, class T2>
          struct C {
            C(C&& other) noexcept(auto)
              : first(std::move(other)), second(std::move(other))
            { }

            T1 first;
            T2 second;
          };

          C<int, int> x;  // will instantiate the body of C::C(&&) right here
        #+END_SRC
        The implicit instantiation of the body of the move constructor should only be performed if ODR-used.
        This would make noexcept(auto) more like explicitly enumerating the expressions.
        Ideally, the noexcept specification shoud only be deduced if overload selected.
        May need to be deduced even if used in unevaluated operand - e.g. ~noexcept(f())~
      - Issue with debug builds w/ assertions that throw in move-ctor with deduced noexcept meaning that std::vector copies instead of throwing and never calls move ctor.
    - Paper was struck from core motions in 2010-11 Batvia meeting
      - Why?

    - Presentation Notes
      https://wiki.edg.com/pub/Wg21batavia/Documents/noexcept_auto.pdf
      - Lists two perils
      - Adding print statements changes the deduced exception-specification (e.g. using cout)
        Can workaround by adding try/catch.
      - Adding assertions can change deduced exception-specification.
        - An issue if assertion macro throws.
          Not an issue if it terminates.
        
      
- N3227 - Please reconsider noexcept (2010)
  - Draft: https://wiki.edg.com/pub/Wg21batavia/EvolutionWorkingGroup/reconsider_noexcept.html
  - https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3227.html
  - Suggests that we should support deducing ~noexcept~-ness of a function
  - Talked about avoiding use of flow-analysis to determine noexceptness of a function (undecidable/hard problem - Rice's theorem).
  - Concerns about inconsistencies across compiler with flow-analysis leading to some programs being well-formed on some compilers but ill-formed on others based on whether they deduced the noexcept the same way.
  - Not a problem if you ignore flow-analysis and just look at whether there are any potentially-throwing expressions that do not catch exceptions.
  - Has some expected objections and some counter-arguments

- N3204 -  Deducing "noexcept" for destructors (2010)
  - Short paper
  - Wording for  default exception-specification to be the same as for an implicit destructor.
    i.e. deduced from the exception-specifications of the data-members/base-classes.

- N3386 - return type deduction for normal functions (2012)
  - N3638 - Return-type deduction for normal functions (2013)
  - maybe relevate to noexcept(auto) deduction?
  - talks about deduced return types for recursive functions
    - works if there is a prior recursion-breaking return-statement by the
      time we get to the use of the recursive call.
  - Talks about instantiation of function templates even if they are not odr-used
    e.g. if you use it in a non-evaluated context such as ~decltype(f(1))~.
  - Proposes adding ~decltype(auto)~ as well.

- [[https://wg21.link/N4473][N4473]] - noexcept(auto), again (2015) Ville
  - Tries to open up the discussion about adding ~noexcept(auto)~ again.
  - Not a lot of detail here, other than this is something that is oft-requested, and is a big pain point for some people.
  - [[https://wiki.edg.com/bin/view/Wg21lenexa/N4473][Minutes]]
    - Jason M had some proposed wording (not found/attached)
    - Had consensus in EWG in Lenexa
- [[https://wg21.link/P0133R0][P0133R0]] -  Putting noexcept(auto) on hold, again
  - Abandoned noexcept(auto) upon realising that you still need to duplicate the expressions
    for SFINAE cases.
    - Seems like there still would have been value in adding this.

** Faster Exceptions

- N4049 - 0-overhead-principle violations in exception handling (2014)
- N4234 - 0-overhead-principle violations in exception handling - part 2 (2014)

- low-latency SG
  - N4456 - Towards improved support for games, graphics, real-time, low latency, embedded systems
    - Mentions wanting guaranteed support for -fno-exceptions, -fno-rtti
      No detail on why/motivation/issues.
  - 

- P0709 Zero-overhead deterministic exceptions (Herb Sutter) 
  - Intro sections have a lot of good motivation for fixing exceptions.
  - Makes the claim that the overheads of dynamic exceptions cannot be avoided by a better
    implementation strategy.
  - Section 4.1 contains EWG polls indicating that exception-handling is something that they want to improve
  - Marking function with ~throws~ turns return type into a union of R + E with a bool flag to indicate whether it's a result/error.
    - Basically baking std::expected into the language
    - Requires a new function-call ABI.
  - ~throws(cond)~ can be a bool value, or an ~except_t~ value (no_except, static_except, dynamic_except)
  - std::error type
    - Tries to map error values to exception type when propagating out of a function.
      e.g. std::errc::ENOMEM <-> std::bad_alloc
    - For types where there is no obvious standard mapping, it would just wrap an exception_ptr
    - This mapping seems like it would be complicated, and difficult to specify/extend.
  - At call sites (that propagate or handle an error), a potential downside of the if-error-goto-handler
    implementation model is that it injects branches that can interfere with optimizations.
    - Claims that you can still use table-based handling.
      But not sure what this would look like.
  - Catching ~std::error~ then requires you to do further conditional branches
    to determine which of the many possible error-conditions it might be.
    - The callee knew which error they returned with, yet this information has
      been type-erased in the ~std::error~ object, and the type information
      now needs to be extracted again.

  - try expression / statement
    - Require every potentially throwing expressions/statement to be covered by a ~try~ expression.

    - Also proposes a ~catch(E) { ... }~ without an opening ~try { ... }~ block.
      Instead, could have ~try~ expressions scattered throughout code between
      enclosing open-brace and ~catch~ clause.
      - This would have issues with the programmer determining what variables are in-scope inside
        the ~catch~ block. Every variable whose scope beings after the first ~try~ expression
        would potentially  not exist and not be available in the ~catch~ block.

  - Suggests adding a ~throws{E}~ syntax for specifying a single error type that would be thrown
    instead of ~std::error~.


** Freestanding


** Alternative Error-handling mechanisms

*** std::expected

- N4015 - A proposal to add a utility class to represent expected monad (2014)
- N4109 - A proposal to add a utility class to represent expected monad - Revision 1 (2014)


*** std::variant

- N4450 - Variant: a typesafe union (v2) 
- N4542 - Variant: a type-safe union (v4) (2015)
- P0129R0   We cannot (realistically) get rid of throwing moves
  - Talks about std::variant and support for types with throwing move ctor/assignment
- P0087R0   Variant: a type-safe union without undefined behavior (v2)
- P0088R0   Variant: a type-safe union that is rarely invalid (v5) (2015)
- P0088R1   Variant: a type-safe union that is rarely invalid (v6) (2015)
- P0239R0   valueless_by_exception (2015)
- P0088R2           Variant: a type-safe union for C++17 (v7) (2016)
- P0095R0   The case for a language based variant
  
*** std::optional


* Design Discussion
:PROPERTIES:
:ID:       e6228e14-fde7-4217-b0c8-a9b7fb781ac5
:END:
** Code Evolution

As a code-base evolves over time, there are a number of potential changes we may want to
make to a function and its exception-specification over time.

The exception-specification forms part of the interface of a function and provides
callers with information about 

There are a number of cases that we need to consider with regards to functions with exception-specifications
as code evolves

With the existing dynamic exceptions facility in C++, extending the set of potentially-thrown
exceptions for a given function to include a new exception type can be done



TODO:
- How do we evolve a function to add new exception types?
- How do we evolve a function to remove exception types from throw-specification?
- What about changing from dynamic to static?
- Or from static to dynamic?


** A new calling convention / function-type


** Changing the implementation changes the calling convention

- this was a problem with the implicit constexpr paper

counter points
- this is already a problem for things with deduced return-type
  - mangled names don't include the return type
  - std::execution / other expression template libraries can change
    the return-type of a function if they change the implementation
    (i.e. the type of the expression-object being returned)
- lots of template code that wants to be noexcept transparent already has to
  maintain this by hand - duplicating the body in the noexcept clause
  - if the implementation changes then so does the noexcept clause
  - this is not eliminating something
- lots of code is currently specified as "expression equivalent to", which
  implies having the equivalent noexceptness.
  - using throw(auto) is a more direct way of expressing that the exception
    specification is "expression equivalent to" the function body

** How accurate does the potentially-thrown exception type calculation need to be?

This paper currently proposes rules for computing the set of potentially-thrown exception types in a
somewhat conservative way and might include exceptions that

It considers only control-flow structure of the function-body and function-signatures of called functions.
It does not involve or require any reasoning about whether or not conditions are always true or false unless.

There are a couple of decisions that were made in the design described in this paper which should
be considered 



** Avoiding dependencies on thread-locals
:PROPERTIES:
:ID:       58f857b8-ec19-4dd5-ac5d-2efa62ebac55
:END:

The design proposed by this paper allows eliminating some of the overhead of dynamic exceptions;
in particular the dynamic allocation, reference-counting and run-time type-information needed to
perform dynamic matching of handlers.

However, there is still some overhead that remains and that is the dependency on thread-local
variables needed to support ~std::uncaught_exceptions()~, ~std::current_exception()~ and
dynamic-rethrow expressions.

As mentioned in the "Error Handling" section of Ben Craig's paper, [[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2268r0.html#error_handling][P2268R0]] "Freestanding Roadmap",
there are some freestanding environments that do not support thread-locals. P2268 suggests
some potential directions we could take to try to eliminate the dependency on
thread-locals for freestanding environments and this paper discusses them further here.

*** Avoiding overhead implied by ~std::current_exception()~ and ~throw;~

The ~std::current_exception()~ function and ~throw;~ expression can be called from any
function dynamically within the scope of a handler - they don't need to be called from
code lexically within the handler.

However, this means that, because they could be called from an arbitrary number of different
contexts, they don't know anything about the type of the exception objects that might be
returned or rethrown - so they necessarily need to deal with dynamic exception objects.

These facilities also rely on accessing thread-local state to be able to find the
current exception object.

When a thrown static exception object is caught by a handler, the exception object will be living
on the stack. However, if we want a call to ~std::current_exception()~ to be able to return
an ~exception_ptr~ that references a dynamic exception object that is a copy of the stack-allocated
object on the stack, then the handler needs to register the address of the object, some basic
type-information and information about how to copy that object to a new location.
This then allows a subsequent call to ~std::current_exception()~ within the scope of the handler
to find the object, allocate new storage for a dynamic-exception-object of the right size, copy
the static-exception-object to the dynamic-exception-object and then return an ~exception_ptr~
referencing that dynamic-exception-object.

Then on exit from the handler, the handler needs to deregister this information from the
thread-local.

All of this generated code for registering/unregistering the static-exception-object
adds to the cost of handling an exception, both in terms of execution and in terms
of binary size.

If the compiler can prove that there will be no calls to ~std::current_exception()~ or
dynamic rethrow it could theoretically optimize out the registration/deregistration logic.
But this is difficult to prove as soon as the handler contains any calls to functions
that weren't inlined.

However, if we were to annotate the handler with some kind of marker that told the
compiler that within the dynamic scope of this handler there will be no calls to
~std::current_exception()~ or any dynamic-rethrow expressions, then the compiler
could avoid needing to register the information about the exception object.

**** Using ~catch static~ to reduce overhead of dynamic exception facilities

We could consider adding some kind of annotation/specifier to a handler that allows
the author to indicate that they will not be making use of the dynamic exception
facilities within the handler and that the compiler can optimise on this basis.

For example:
#+begin_src c++
  try { something(); }
  catch static (const X& ex) {
    // user promises not to call std::current_exception() or dynamic-rethrow in here
  }
#+end_src

Annotating a handler thusly signals to the compiler that, while this handler is the active
handler, that:
- evaluating a call to ~std::current_exception()~ will return an unspecified
  ~std::exception_ptr~. It is unspecified since if the handler has caught a
  dynamic exception object then there may not be any overhead in registering
  the exception object if the act of throwing the exception already registered it.
- evaluating a dynamic-rethrow expression either calls ~std::terminate()~ or
  is undefined-behaviour (which one is TBD).

Note that the handler can still rethrow the exception by evaluating a ~throw;~
expression that is lexically within the handler - the compiler knows where to
go to get the exception object in this case.

**** Catching ~std::exception_ptr~ as an alternative to calling ~std::current_exception()~

Another avenue to explore that might reduce the need for thread-local access
is to allow the user to write:
#+begin_src c++
  try { something(); }
  catch /* static */ (std::exception_ptr e) {
    // stash 'e' somewhere
  }
#+end_src
as an alternative to writing:
#+begin_src c++
  try { something(); }
  catch (...) {
    auto e = std::current_exception();
    // stash 'e' somewhere
  }
#+end_src

The alternative formulation potentially allows the compiler to directly
construct the ~exception_ptr~ and pass it to the handler without needing
to access the thread-local state.

If the thrown exception object was a dynamic-exception-object then it
might not be any more efficient and so might lower to calling ~std::current_exception()~
and just passing the result.

If the thrown exception object was a static-exception-object, however, then
the compiler could directly construct a new dynamic-exception-object from the
static-exception-object and pass the pointer withouth having to access the
thread-locals. e.g. as if by ~std::make_exception_ptr(obj)~.

On the throwing side, we could consider making a ~throw expr~ expression where
argument is a possibly-cv-qualified ~std::exception_ptr~ as equivalent to calling
~std::rethrow_exception()~.

This would have great benefits for generic programming if we could treat ~std::exception_ptr~
as if it were just another exception object that could be thrown/caught.

The major challenge to a syntax like this, however, is that it would be a breaking change.
There may be code-bases out there that are intentionally throwing an exception of type
~std::exception_ptr~ and catching ~std::exception_ptr~ rather than using ~std::rethrow_exception()~
to rethrow the contained dynamic-exception-object.

Adoping the semantics described above would mean their ~catch(std::exception_ptr)~ handler
would now start matching all exceptions, not just a thrown ~std::exception_ptr~.

Also, if we decided that, like ~catch(...)~, that a ~catch(std::exception_ptr)~ must
appear as the last handler in the sequence of handlers for a try-block, then it may
cause existing code to become ill-formed.

A quick search in https://codesearch.isocpp.org/ showed 2 matches for handlers that
were catching a ~std::exception_ptr~.

One was a unit-test[fn:pplx] in cpprestsdk that was making sure that when an ~exception_ptr~
was being rethrown by an async tasl library that it was using ~std::rethrow_exception(eptr)~
instead of ~throw eptr~ and was checking that the ~catch(std::exception_ptr)~ handler was not
being entered when the exception was rethrown.

The other was similarly for an async framework in the Ice project which was intentionally
catching an ~exception_ptr~ and then immediately calling ~std::rethrow_exception()~ to
propagatethe exception. Upon further investigation, I found an issue[fn:ice] that indicated
a desire to move away from this and a search of the latest version of the codebase
yielded no usage.

A search of github yielded one other hit:
- [[https://github.com/quantanotes/heisenberg-go/blob/3a5404c1cba7ae1fe16262219e5535223cf32adf/core/hnsw/hnsw_wrapper.cc#L72][heisenberg-go hnsw_wrapper.cc]]
  This looks like it might be a bug and may have intended to write ~catch(const std::exception&)~ as I could
  not find any ~throw~ expressions that were throwing an ~exception_ptr~ in the project.

Usage of this pattern in open-source projects does not seem to be wide-spread.
While not representative of code-bases at large, it may be worth considering a syntax
like this to both allow freestanding platforms that don't have access to thread-locals
an alternative API for obtaining the current exception an an ~exception_ptr~.


[fn:pplx] https://github.com/microsoft/cpprestsdk/blob/master/Release/tests/functional/pplx/pplx_test/pplx_op_test.cpp#L198
[fn:ice] https://github.com/zeroc-ice/ice/issues/582


*** Avoiding overhead implied by ~std::unhandled_exceptions()~

The ~std::unhandled_exceptions()~ function reports a count of the number of in-flight
exceptions on the current thread - ones for which a ~throw~ expression has been evaluated
but for which the corresponding handler has not yet been activated.

Multiple exceptions can be in-flight at once in the case that a destructor calls some
function that throws an exception which is then caught within the scope of the destructor.

This is used by facilities such as ~scope_success~ or ~scope_failure~ scope-guard objects
that conditionally execute some logic if the destructor is called during the normal scope
exit path or during exception unwind. These classes capture the number of uncaught exceptions
in their constructor and then compare that number to the number of uncaught exceptions in
their destructor decide whether to execute the logic based on the result of that comparison.

For example: A scope_failure can be used to roll back a transaction if something fails
#+begin_src c++
  {
    scope_failure cancel_on_fail{[&] { transaction.RollBack(); }};

    for (auto& x : items) {
      transaction.execute(generate_sql(x)); // might throw
    }
  }
#+end_src


To make this work, however, the C++ runtime needs to store a thread-local count of the
number of in-flight exceptions and then increment it whenever executing a ~throw~ expression
and decrement it whenever a handler is activated.

For example, on the Itanium ABI, there are the following interface:
#+begin_src c++
  struct __cxa_eh_globals {
    __cxa_exception* caughtExceptions;
    unsigned int uncaughtExceptions;
  };

  // Gets a pointer to the current thread's exception state
  __cxa_eh_globals* __cxa_get_globals(void);
#+end_src

When an exception is thrown, the compiler needs to ensure that something equivalent to
the following:
#+begin_src c++
  ++__cxa_get_globals()->uncaughtExceptions;
#+end_src
and then in the handler (immediately after initializing any exception-object parameter)
#+begin_src c++
  --__cxa_get_globals()->uncaughtExceptions;
#+end_src

Usually the increment/decrement is wrapped up inside the ~__cxa_throw()~ and ~__cxa_begin_catch()~
functions.

The use of a thread-local here is a somewhat indirect mechanism to detect the context
that the compiler is calling the destructor and has known deficiencies when used in
conjunction with coroutines or fibers which can suspend and then resume in a different
context, potentially with a different number of in-flight exceptions.

One direction to explore, which has been previously hinted at in both P0709 and P2268
(and possibly others) is to allow either having two destructors, one to execute during
exception unwind and another to execute during normal scope exits, or to pass a flag
that indicates the disposition in which the destructor is being called.

#+begin_src c++
  template<std::invocable F>
  struct scope_failure {
    F func;

    // Normal destruction
    ~scope_failure() {}

    // Unwind destruction
    ~scope_failure(std::unexpect_t) {
      func();
    }
  };

  template<std::invocable F>
  scope_failure(F) -> scope_failure<F>;
#+end_src

The compiler already knows in what contexts it is calling the destructors - the calls
to destructors during unwind is typically separate from the code that calls destructors
during normal scope exit, and so it would be straight-forward for compilers to call
a different overload in exceptional contexts.

While this would allow classes like ~scope_success~ and ~scope_failure~ to be implmented
without a dependency on thread-locals, it would be a fairly large design change and
potentially require a lot of viral changes to standard library types to support.

More exploration is needed to determine the viability of this option.

In the meantime, it's possible that freestanding platforms that do not support thread-locals
could provide basic exception support but without providing ~std::uncaught_exceptions()~.


** Calling C functions

When importing APIs from C libraries which were not written with consumption by C++ in-mind,
C function declarations will generally not have any exception-specification listed on them,
thus defaulting the exception-specification to ~noexcept(false)~.

When a C++ program calls such functions, the compiler must assume that they could potentially
throw an exception and so may end up generating additional code to handle the case that these
functions throw an exception, even if the vast majority of these functions will not ever emit
an exception.

When you call these C functions from a ~noexcept~ function then the worst you get is some
suboptimal code-gen that bloats your binary and maybe misses out on some optimizations.

However, within a function that has a static-exception-specification, calling such functions
would require surrounding the call in a ~try { } catch (...) {  }~ to ensure that all exceptions
are handled.

For example:
#+begin_src c++
  extern "C" int some_c_api(void*);

  void some_caller() throw(std::error_code) {
    // ...

    void* handle = /* ... */;

    int result = some_c_api(handle); // ERROR: some_c_api() may throw a dynamic exception which is not handled locally
    if (result < 0) {
      throw std::error_code{errno, std::system_category()}
    }

    // ...
  }
#+end_src

This is helpful that the compiler can identify places where control flow may cause
an unhandled exception to be emitted, however in this case may be an example of
a false-positive.

The code can be amended either by adding a ~try/catch(...)~ around the call,
with either a ~std::unreachable()~ or ~std::terminate()~ call, although this
still ends up generating sub-optimal code.

Alternatively, if the developer knows that the function will not throw, the function-pointer
can be ~reinterpret_cast~ to an equivalent function-pointer annotated with ~noexcept~ and then
call through that function-pointer. While non-portable, this will work on most platforms and
gives better codegen (without code for handlers).

For example: Given the following helpers
#+begin_src c++
  template<typename T> struct noexcept_cast_helper;
  template<typename R, typename... As>
  struct noexcept_cast_helper<R(*)(As...)> {
    using type = R(*)(As...) noexcept;
  };
  template<typename F>
  [[clang::always_inline]] auto noexcept_cast(F func) noexcept {
    return reinterpret_cast<typename noexcept_cast_helper<F>::type>(func);
  }
#+end_src
you can write the following (which is now well-formed):
#+begin_src c++
  void some_caller() throw(std::error_code) {
    // ...

    void* handle = /* ... */;

    int result = noexcept_cast(some_c_api)(handle); // OK: This is now a call to a noexcept function.
    if (result < 0) {
      throw std::error_code{errno, std::system_category()}
    }

    // ...
  }
#+end_src

Another direction suggested by Ben Craig was to add something similar to the ~extern "C"~ block to allow
declaring that all functions in a given block are ~noexcept~.

For example: The following would
#+begin_src c++
  extern "C" { noexcept {
  #include "the_c_api.h"
  } }
#+end_src


** Standard Library Impacts

*** Function-wrapper types

**** ~std::function~

This type is parameterised by a function signature of form ~R(Args...)~.

This class is undefined for function signatures of the form ~R(Args...) noexcept~,
largely because doing so would have no effecton the resulting class.

The ~std::function::operator()~ call can throw the ~std::bad_function_call~ exception
if invoked on a ~std::function~ instance that is empty and so the ~operator()~ could
not be marked ~noexcept~ anyway.

The existing ~std::function~ class could be used as-is to wrap functions and function-objects
whose call-operator as a non-empty static-exception specification. Although we would need to
extend the function-pointer casting rules to allow casting from ~void(*)() throw(X)~ to
~void(*)() throw(...)~.

We could also consider defining an additional partial-specialization of ~std::function~ that
allowed specifying a function-signature with a static-exception specification and then computed
a static-exception specification for ~operator()~ that added ~std::bad_function_call~ to that
exception-list.

**** ~std::copyable_function~ and ~std::move_only_function~

These types are parameterised on a function-type that inclues the exception-specification.

- ~std::reference_wrapper~

These types

The following types could be extended to have call operators annotated with ~throw(auto)~
to have them deduce the exception specification based on the exception specification of
the underlying operator implementation.
  
Arithmetic function objects
- std::plus
- std::minus
- std::multiplies
- std::divides
- std::modulus
- std::negate
Comparison function object
- std::less
- std::greater
- std::less_equal
- std::greater_equal
- std::equal_to
- std::not_equal_to
- std::compare_three_way
Logical Operations
- std::logical_and
- std::logical_or
- std::logical_not
Bitwise Operations
- std::bit_and
- std::bit_or
- std::bit_xor
- std::bit_not
    

*** Implementations adding ~noexcept~ to "Throws: Nothing" functions can affect well-formedness

A function in the standard library specified as "Throws: Nothing" but for which there is a pre-condition
are often specified as being ~noexcept(false)~ functions. The main rationale here is to allow for the
possibility that an implementation might want to throw an exception if the pre-condition is violated,
since violating a pre-condition is undefined-behaviour the implementation is technically free to do
anything, including throw an exception.

However, implementations that do not throw exceptions on pre-condition violations and instead
choose to terminate/abort are currently free to add ~noexcept~ to function declarations wherever they
feel is appropriate.

This permission is granted to them by [res.on.exception.handling] p5 which says
#+begin_quote
An implementation may strengthen the exception specification for a non-virtual function
by adding a non-throwing exception specification.
#+end_quote

For example MS-STL, libc++ and libstdc++ all declare ~std::vector::operator[]~ as ~noexcept~ despite it
having a pre-condition that the index is less-than ~size()~. It is worth noting, however, the same
standard library implementations do not mark ~std::vector<bool>::operator[]~ with ~noexcept~.

With this paper and the ability to either decare a function as having a deduced throw-specification
or to call these functions from a context where the the exception-specification is checked, the
implementation differences on ~noexcept~ qualification of these member functions can potentially
affect the well-formedness of the program.

For example: The following function would be well-formed on current major standard library implementations
which mark ~std::vector::operator[]~ as ~noexcept~, but might be ill-formed on other conforming implementations
that do not mark ~std::vector::operator[]~ as ~noexcept~, and thus would not be portable C++ code.
#+begin_src c++
  void example(const std::vector<int>& v) throw() {
    int sum = 0;
    for (size_t i = 0; i < v.size(); ++i) {
      sum += v[i];
    }
    return sum;
  }
#+end_src

A portable implementation would either need to use ~noexcept~ and allow the possibility
of a runtime ~std::terminate()~ call if the implementation of ~example()~ happens to
contain a bug that violates a pre-condition and the implementation of ~vector::operator[]~
handles this by throwing an exception.

Or you would need to surround the body in a /function-try-block/ that calls either ~std::terminate()~
or, if you are confident in the correctness of the code, calls ~std::terminate()~ in the handler.
For example:
#+begin_src c++
  void example2(const std::vector<int>& v) throw() try {
    int sum = 0;
    for (size_t i = 0; i < v.size(); ++i) {
      sum += v[i];
    }
    return sum;
  } catch (...) { std::terminate(); }
#+end_src

Note that ideally we'd be able to declare that this handler was unreachable by calling ~std::unreachable()~
instead, however ~std::unreachable()~ is not specified as ~noexcept~ and so might again throw an exception
which would violate the ~throw()~ specifier checking.

The ~std::terminate()~ function, on the other hand, is specified to be ~noexcept~, and so can be called in
this case to portably indicate that the function does not exit with an exception.

Alternatively, the user can define a new ~nothrow_unreachable()~ function as follows and call that instead
of ~std::terminate()~:
#+begin_src c++
  [[noreturn]] void nothrow_unreachable() noexcept {
    std::unreachable();
  }
#+end_src



* Implementation Strategies
:PROPERTIES:
:ID:       01aa3390-7ae3-4f75-831e-d7f22c40d5ae
:END:

This section describes some potential implementation strategies that could be taken
for implementing the semantics described above.

Note that this is just a sketch that talks through some of the potential challenges and
techniques that could be used. It has not yet been implemented in a compiler, so treat
this section as speculative until implementation experience has been gained.

** Multiple return-paths/return-addresses

One of the intents of the semantics described above for functions with static-exception specifications
is to model them effectively as a function that can either return a value object for the success
return-path or can return an error object for each of a set of possible exception-types listed in the
exception specification.

With a normal function call there is usually a single return-address that the callee must transfer
control to when the callee completes.

The return-address is usually passed from the caller to the callee on the stack. Many hardware
architectures have dedicated hardware instructions for pushing the address of the next
instruction onto the stack before then jumping to the entry-point of the callee. When returning
there is also often hardware support for popping this return address from the stack and then
jumping to the return address.

If the callee is potentially throwing then there is, logically, a second potential return-address
that the callee might transfer execution to when it exits - the exception unwind path. The unwind
path is the path that, logically, exits scopes, destroying automatic-storage duration variables,
until it reaches a matching handler and then transfers execution to that handler.

To avoid overhead in having to pass multiple return-addresses to a function and to take advantage of
the dedicated hardware instructions for passing a single return-address and returning to that
return-address upon completion, implementations often use auxiliary data-structures stored within
the binary that allow looking up the exceptional return-address for the current function based
on the return-address for the normal path.

With functions with static exception specifications we have a function that has 1 normal return
path and zero or more possible exceptional return-paths.

If the caller knows what all of the possible exception types that might be thrown are, it can
statically compute what the unwind path should be for each potential exception type thrown.
e.g. whether it is handled locally within the function or is propagated through to its caller.

If the caller could pass, somehow, a list of return-addresses to the callee, one for each
possible return-path, then the callee can then return directly to the return-address corresponding
to either the normal return-path or a particular exception-type return-path.

However, we want to do so without increasing substantially the cost of making a normal call.
For example, if we were to have to generate assembly code to push 5 separate return-addresses
onto the stack for a function call to a function that could thrown 4 different exception types
then this would increase the cost of making the function call and the stack-space used by
the calling convention.

Also, many CPUs optimise their branch predictor for call/ret instructions to maintain a
stack of recent return-addresses pushed onto the stack so that it can predict the target
that a ret instruction will jump to, assuming that for every call instruction there is
eventually a corresponding ret instruction. Any scheme that doesn't maintain balanced
call/ret instructions can result in a misaligned return-address branch predictor cache
which can significantly increase the number of subsequent branch mispredictions.

One approach to implementing this with a lower cost for a function call would be to provide
a jump-table of possible return-addresses and to instead push a pointer to the jump-table
as part of the call instruction.

On x86/x86-64 architectures this can be done relatively cheaply in one of two ways
without increasing the amount of stack-space and would only require one additional
instruction to be executed on the normal return path compared to a normal function-call.

*** Inline Jump Tables

The first option would be to immediately follow a ~call~ instruction with a series of
5-byte ~jmp~ instructions that jump to the relevant block for handling the corresponding
return-path. The first jmp instruction would jump to the code for the normal-return path,
and subsequent jmp instructions for each exception path.

This calling convention is backwards compatible with existing calling conventions.
The caller issues a ~call~ instruction as per normal and the callee when it returns a value
just issues a ~ret~ instruction to return, which transfers to the first ~jmp~ instruction
which then unconditionally jumps to the code that handles this path.

The additional direct ~jmp~ instruction should be reasonably able to be predicted/pipelined
by a CPU so shouldn't add much in the way of additional latency (NOTE: to be confirmed with data).

For example, given the following code:
#+begin_src c++
int divide(int num, int den) throw(divide_by_zero, overflow) {
  if (den == 0) throw divide_by_zero{};
  if (den == -1 && num == INT_MIN) throw overflow{};
  return num/den;
}

int x, y;

int example() {
  try {
    int result = divide(x, y);
    return 2 * result;
  } catch (divide_by_zero e) {
    return -1;   
  } catch (overflow) {
    return -2;
  }
}
#+end_src

The caller could be translated into assembly similar to the following:
#+begin_src asm
x:
  .data 4
  
y:
  .data 4
  
example:
  mov edi, dword ptr [x]   ; Load 'x' into register for param 1
  mov esi, dword ptr [y]   ; Load 'y' into register for param 2
  call divide    ; Jump to 'divide' and push address of .JUMP_TABLE onto stack
.JUMP_TABLE:     ; Each entry is a 'JMP rel32' encoded instruction which is 5 bytes
  jmp .SUCCESS   ; entry[0] - success path
  jmp .ERR_0     ; entry[1] - error path for divide_by_zero
  jmp .ERR_1     ; entry[2] - error path for overflow
.SUCCESS:
  # result is in eax
  mul eax, 2
  ret
.ERR_0:
  mov eax, -1
  ret
.ERR_1:
  mov eax, -2
  ret
#+end_src

Note that for simplicity, this is assuming that the divide_by_zero and overflow
types are empty, trivially destructible types.

The callee function could be translated into assembly similar to the following:

#+begin_src asm
divide:
  ;# NOTE: [rsp] points to address of .JUMP_TABLE
  test esi, esi
  je .THROW1
  cmp esi, -1
  jne .LBL1:
  cmp edi, 0x7fffffff
  jne .THROW2
.LBL1:
  mov eax, edi
  cdq
  idiv esi
  ret       ; return to entry[0]
.THROW1:
  ; [rsp] contains address of entry[0] instruction
  ; need to add '5' (size of JMP instruction) to this to get address of entry[1]
  ; do this in-place to avoid using an extra register to compute the address
  add qword ptr [rsp], 5
  ret       ; return to entry[1]
.THROW2:
  ; [rsp] contains address of entry[0] instruction
  ; need to add '10' (size of 2 * JMP instruction) to this to get address of entry[2]
  ; do this in-place to avoid using an extra register to compute the address
  add qword ptr [rsp], 10
  ret       ; return to entry[2]
#+end_src

A few things are worth noting here.
- The calling code still just passes arguments in registers, calls the
  function with a call-instruction, which returns on the normal return-path
  back to the instruction after the call-instruction.
- The callee still executes a normal 'ret' instruction to return on the
  normal code-path.
- On the error return-path, the callee adjusts the return address by adding
  a constant to the location on the stack where the return-address is stored.
  On x86 this can be done with a single instruction and does not require any
  additional registers.
- After returning to the appropriate return-address, the caller then needs
  to jump to the appropriate location to execute the logic for that code-path.
  - For the success case, this is the one extra instruction that needs to be
    executed compared to traditional table-based exception-throwing calling
    conventions.
- There is no need for additional exception-unwind-lookup tables or runtime-type-information.
  All of the data/logic for handling the exceptions is local and inline within
  the caller and callee.
- There are no additional branches to execute on the caller side here.
  Once the callee has branched to the necessary code path that executes the
  ~throw~ expression, it returns directly to the code-path in the caller that
  handles that case.
  
Of particular note is that overhead of returning via the exception code-path
is one additional instruction.
  
A slight space-optimisation could be to inline the final code-path (in the above example,
the code-path corresponding to the 'overflow' exception case) in lieu of having a
jump instruction for the final block of code.

For example: Inlining the last case into the jump table
#+begin_src asm
example:
  mov edi, dword ptr [x]   ; Load 'x' into register for param 1
  mov esi, dword ptr [y]   ; Load 'y' into register for param 2
  call divide    ; Jump to 'divide' and push address of .JUMP_TABLE onto stack
.JUMP_TABLE:     ; Each entry is a 'JMP rel32' encoded instruction which is 5 bytes
  jmp .SUCCESS   ; entry[0] - success path
  jmp .ERR_0     ; entry[1] - error path for divide_by_zero
.ERR_1:
  mov eax, -2.   ; entry[2] - error path for overflow (inlined as last jump table entry)
  ret
.SUCCESS:
  ; result is in eax
  mul eax, 2
  ret
.ERR_0:
  mov eax, -1
  ret
#+end_src

One concern with this approach is that the normal return-path is no longer inline
immediately after the call instruction as there is now a number of jmp instructions
interspersed between the call and the logic that handles the success case.

This can potentially have a detrimental effect on instruction-cache miss rate,
particularly if the number of possible exception types is large. e.g. if there
were more than 12 possible exception types listed in the signature, each of which
required their own jump table entry, then you're pretty much guaranteed that the
call instruction will live in a different cache-line and so may be more likely to
result in an instruction-cache miss. For cases with a small number of exception types,
the overhead on the normal return-path is expected to be small, however.

Implementation experience is required to evaluate the actual impact of this on
the performance of the normal call-path.

*** "NOP Stuffing" Jump Tables

Another alternative approach of implementing the jump-table is to somehow embed
a pointer/offset to an external jump-table in a location relative to the call
instruction.

NOTE: The following information is based on memory from a discussion with
Ben Craig. Need to go back and verify this from the Intel reference manual.

On x86/64 there are some ~nop~ instruction encodings that have unused bytes
within them and this can be used to encode some data in the instruction stream
without that instruction having any effect on the state of the CPU registers
(other than advancing the instruction pointer).

You can place this instruction immediately following a call instruction and
encode into the spare bits of the instruction, an offset to the jump table.
As this instruction is a no-op, you can just immediately follow the instruction
with the logic for handling the normal return-path. In this case, there is
much less of a concern with instruction cache misses.

So in the above case, the caller would be replaced with:
#+begin_src asm
  example:
    mov edi, dword ptr [x]   ; Load 'x' into register for param 1
    mov esi, dword ptr [y]   ; Load 'y' into register for param 2
    call divide    ; Jump to 'divide' and push address of .JUMP_TABLE onto stack
  .DATA_NOP
    nop DWORD (.JUMP_TABLE - .DATA_NOP) ; 3-byte prefix + 4-bytes jump table offset
    mul eax, 2
    ret

  .JUMP_TABLE:     ; Each entry of table is a pointer to return-address
    data DWORD (.ERR_0 - .DATA_NOP)     
    data DWORD (.ERR_1 - .DATA_NOP)

  .ERR_0:
    mov eax, -1.  ; entry[1] - error path for divide_by_zero
    ret

  .ERR_1:
    mov eax, -2.  ; entry[2] - error path for overflow
    ret
#+end_src

Then the callee would be updated to look something like the following:
#+begin_src asm
  divide:
    ; NOTE: [rsp] points to address of nop encoding offset to .JUMP_TABLE
    test esi, esi
    je .THROW1
    cmp esi, -1
    jne .LBL1:
    cmp edi, 0x7fffffff
    jne .THROW2
  .LBL1:
    mov eax, edi
    cdq
    idiv esi
    ret       ; return to nop instruction (normal return)
  .THROW1:
    ; [rsp] contains address of nop instruction (i.e. return address)
    mov rax, QWORD PTR [rsp]       ; load the address of the nop instruction
    mov edx, DWORD PTR [rax+3]     ; load the offset-to-jump-table part of the nop instruction (assuming 7 byte encoding, last 4 bytes is offset) 
    mov edx, DWORD PTR [rax+rdx]   ; load the offset in entry[0] of table
    add QWORD PTR [rsp], rdx       ; add offset to return-address
    ret                            ; return to unwind path for 'divide_by_zero'
  .THROW2:
    mov rax, QWORD PTR [rsp]       ; load the address of the nop instruction
    mov edx, DWORD PTR [rax+3]     ; load the offset-to-jump-table part of the nop instruction (assuming 7 byte encoding, last 4 bytes is offset) 
    mov edx, DWORD PTR [rax+rdx+4] ; load the offset in entry[1] of table
    add QWORD PTR [rsp], rdx       ; add offset to return-address
    ret                            ; return to unwind path for 'overflow'
#+end_src

Note that with this approach, while there are potentially gains on the caller side
in terms of instruction cache coherency on the normal return-path as there is no
~jmp~ instruction immediately on return. However, this comes at the cost of
additional instructions for each of the exceptional return paths, which also
involves additional indirect memory loads.

It's unclear which calling-convention would end up being more efficient / smaller code-size overall.
Both approaches will need to be tried on a variety of code-bases to evalute effects on performance and code-size.

Other architectures may have alternative approaches that are possible or may have additional
constraints - these will all need to be investigated to find the most appropriate calling
convention to support multiple return-addresses.

** Multiple return-value-slots

The previous section focused mostly on how to implement multiple return-addresses
for a given function in an efficient way. We also need to consider how to return
the exception objects themselves.

With the normal return path, there are a couple of common conventions for passing
the return value back to the caller. If the return type is void there is nothing
to do as the return-path does not need to pass a value back.

If the return-type is trivially copyable and the return-value fits within a register
or two then the return-value can sometimes be passed back in designated register(s).
e.g. on x86-64 this is often the eax/rax register

Otherwise, in order to support guaranteed copy-elision, the return object will need
to be constructed into storage provided by the caller. The caller usually provides
the address of this storage by passing it in a register, which the callee then uses
to construct the return object before returning.

When returning an exception object from a function with a static exception specifcation
we can use a lot of the same conventions for passing the excepton value back.

If the exception object is trivially empty then we just return to the corresponding return-address.

If the exception object is trivially copyable and fits within a register, then we can put
the exception object in a register before returning to corresponding return-address. The
caller can then just read the exception object value from the register.


If the exception object needs to be placed in memory then to get the same copy-elision
behaviour as for normal return-values the caller needs to provide the address of the
storage for that particular exception type.

This presents somewhat of a challenge, because now, instead of passing a single address
for the return value, we potentially need to pass N addresses, one for the return object
and one for each of the exception object types.

While in some cases, the caller might reuse the same storage for the different exception
types, in general the lifetimes of the exception objects may be different and so may need
to have separate addresses.

The naiive approach of passing each additional exception object address in a register
would be very expensive as the registers are a very limited resources - they are also
used for passing parameters and using them for passing additional return-addresses will
increase register pressure and force additional spills of values to the stack.

If we passed the return addresses on the stack then we would need N push instructions
and possibly N or more additional instructions for computing the addresses of each of
the return-objects. This would mean the overhead of a function call would scale linearly
with the number of potential exception objects, which is not what we want. If you have
a function with 40 potentially thrown exception types (not implausible) then you could
easily end up with 100 instructions just for calling the function!

Instead, what we want is something that has a constant overhead for a function call
and only has 




** Unwinding through scopes with destructors

** Tail Calls

** Interop between static-exception functions and dynamic-exception functions

** Virtual function calls


** Interaction with ~std::uncaught_exceptions()~


** Static exceptions and the Itanium C++ ABI

See https://godbolt.org/z/8578rKh6j for an proof-of-concept of how a local throw/catch within a function,
which under this proposal would be required to be a static exception object, would interact with
the Itanium C++ ABI and facilities such as ~std::uncaught_exceptions()~, ~std::current_exception()~
and ~throw;~.

Support for static exception objects is likely to require some changes to the implementations of
the ~__cxa_*~ functions that form the ABI, and thus would require relining with the ABI libraries
(either statically or dynamically) but should otherwise be able to link against code previously
compiled against the existing ABI.

Additional work is required here to validate this approach.

* Acknowledgements

Special thanks to Ben Craig and Corentin Jabot for providing feedback on drafts of
this paper.

* References

- "Fast dynamic casting" (Gibbs, Stroustrup)\\
  https://www.stroustrup.com/fast_dynamic_casting.pdf
  
- [P0709R4] "Zero-overhead deterministic exceptions: Throwing values" (Sutter)\\
  https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf
  
- [P2268R0] "Freestanding Roadmap" (Craig)\\
  https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2268r0.html

* Paper notes                                                      :noexport:


- Previous papers relating to exceptions
  - 2004
    - N1664 - Toward Improved Optimization Opportunities in C++0x
      - Describes type-effects of ~throwing()~ / ~nothrow~ qualifier on a function as part of the function's type.
  - 2003
    - N1462 	03-0045 	Safe Exceptions and Compiler Security Checks
  - 2004
    - N1725 	04-0165 	Copy Elision in Exception Handling
  - 2005
    - [[https://www.stroustrup.com/fast_dynamic_casting.pdf][Fast dynamic casting]] (Gibbs, Stroustrup)
      - Talks about fast dynamic casting using integer ids and the Chinese Remainder Theorem.
        Assigns each type in the hierarchy a prime number.
        Type id for each type is the product of the prime numbers of all base classes.
        Can test for castability by checking if concrete type id is divisible by base-class type id.
      - Referenced in Bjarne's paper from 2019 P1947R0.

    - N1825 	05-0085 	Addressing Exception Specifications for Next Generation of C++
      - talks about making exception specifications similar to contract post-conditions
        - std::bad_exception - exception thrown when exception-specification violated
          - inherits from std::broken_contract, which inherits from std::exception
  - 2006
    - N2061 	06-0131 	Library Exception Propagation Support
    - N2089 	06-0159 	Asynchronous Exceptions for Threads
    - N2096 	06-0166 	Transporting Values and Exceptions between Threads
    - N2106 	06-0176 	Cloning and Throwing Dynamically Typed Exceptions
    - N2107 	06-0177 	Exception Propagation across Threads
    - 
  - 2007
    - N2309 	07-0169 	Error-handling and Exception-related library changes for C++0x
    - 
  - 2008
    - N2509 	08-0019 	Nesting Exceptions
    - N2538 	08-0048 	Removal of System error support
    - N2559 	08-0069 	Nesting Exception Objects (Revision 1)
    - N2636 	08-0146 	Error Handling Specification for Chapter 30 (Threads)
    - N2678 	08-0188 	Error Handling Specification for Chapter 30 (Threads)
    - N2809 	08-0319 	Library Support for hybrid error handling
    
        
  - 2009
    - [[https://wg21.link/N2815][N2815]] - Improving the standard library's exception specifications
      - Proposes adding "no-fail" guarantees to certain container methods
    - [[https://wg21.link/N2838][N2838]] - Library support for Hybrid Error Handling
      - Proposes adding ~void foo(error_code& ec = throws())~ as a way to avoid doubling the number
        of overloads when an ~error_code~ and exception-throwing version both exist.
      - Doesn't look like it was accepted.
    - N2952 - Accessing current exception during unwinding
      - Talks about the use-case of wanting to log an in-flight exception in the destructor
  - 2010
    - N3114 - throw() becomes noexcept
      - Library changes that search/replace ~throw()~ with ~noexcept~.
    - N3148 - throw() becomes noexcept (Version 2)
    - N3149 - From Throws: Nothing to noexcept
      - Library specification changes to use ~noexcept~ in more places.
    - N3150 - Removing non-empty dynamic exception specifications from the library
      - Removes ~throw(std::bad_alloc)~ from allocation functions
    - N3155 - More on noexcept for the language support library
      - Adding ~noexcept~ to more library bits.
    - N3156 - More on noexcept for the diagnostics library
    - N3157 - More on noexcept for the General Utilities Library
    - N3166 - Destructors default to noexcept
    - N3167 - Delete operators default to noexcept
    - N3180 - More on noexcept for the Strings Library
    - N3187 - More on noexcept for the Containrs Library
    - N3195 - From Throws: Nothing to noexcept (version 2)
    - N3199 - More on noexcept for the General Utilities Library (version 2)

      

    - N3205 - Delete operators default to noexcept

    - 2011
      - N3251 - noexcept for the ATomics Library
      - N3252 - A review of noexcept in the threads library
      - N3263 - More on noexcept for the Containers Library (revision)
      - N3267 - A review of noexcept in the threads library (revised)
    - 2012
      - N3441 - Call Stack Utilities and std::exception extension proposal
    - 2013
      - N3614 - unwinding_exception
      - N3757 - Support for user-defined exception information and diagnostic information in std::exception
      - N3758 - standard exception information types for std::exception
    - 2014
      - N4002 - Cleaning-up noexcept in the LIbrary
      - N4055 - Ruminations on (node-based) containers and noexcept
      - N4152 - uncaught_exceptions (2014)
        - N4259 - Wording for std::uncaught_exceptions (2014)
      - N4157 - Relaxing Packaging Rules for Exceptions Thrown by Parallel Algorithms
      - N4227 - Cleaning-up noexcept in the Library (Rev 2)
      - N4258 - Cleaning up noexcept in the Library (Rev 3)
      - N4274 - Relaxing Packaging Rules for Exceptions Thrown by Parallel Algorithms - Proposed Wording (Revision 1)
    - 2015
      - N4526 - Towards improved support for games, graphics, real-time, low latency, embedded systems
        - Talks about supporting version with exceptions disabled (-fno-except, -fno-rtti)
      - P0043R0 -         Function wrappers with allocators and noexcept
      - P0044R0 -         unwinding_state: safe exception relativity
      - P0172R0   Abominable Function Types
    - 2016
      - P0333R0   Improving Parallel Algorithm Exception Handling
      - P0394R4   Hotel Parallelifornia: terminate() for Parallel Algorithms Exception Handling
      - P0509R1   Updating "Restrictions on exception handling"
        - Allows library functions to throw exceptions derived from the ones listed in the Throws: paragraph.
    - 2017
      - P0568R0   Towards Better Embedded programming support for C++ and an update on the status of SG14, two years later
      - P0619R1   Reviewing Deprecated Facilities of C++17 for C++20
        - Covers proposed removal of throw specifications
      - P0640R0   User-defined exception information and diagnostic information in exception objects
      - P0762R0   Concerns about expected<T, E> from the Boost.Outcome peer review
      - P0779R0   Proposing operator try() (with added native C++ macro functions!)
      - P0797R0   Exception Handling in Parallel STL Algorithms
      - P0829R0   Freestanding proposal
      - P0619R2   Reviewing Deprecated Facilities of C++17 for C++20
    - 2018
      - P0323R5   std::expected
      - P0824R1   Summary of SG14 discussion on <system_error>
      - P0829R1   Freestanding Proposal
      - P0881R0   A Proposal to add stack trace library
      - P0884R0   Extending the noexcept Policy
      - P0938R0   SG14: Low Latency Meeting Minutes 2017/12/13-2018/01/10
      - P0939R0   Direction for ISO C++
        - Lists "Exception and error returns" as one of the medium-term aims (3-10 years)
      - P0323r6   std::expected
      - P1002R0   Try-catch blocks in constexpr functions
      - P0132R1   Non-throwing container operations
      - P0709R0   Zero-overhead deterministic exceptions: Throwing values
      - P0933R0   Runtime type introspection with std::exception ptr
      - P1028R0   SG14 status_code and standard error object for P0709 Zero-overhead deterministic exceptions
      - P1066R0   How to catch an exception_ptr without even try-ing
      - P1071R0   SG14: Low Latency Meeting Minutes 2018/04/11- 2018/05/02
      - P0323r7   std::expected
      - P0095R2   Language Variants
      - P0709R2   Zero-overhead deterministic exceptions: Throwing values
      - P0933R1   Runtime type introspection with std::exception_ptr
      - P1028R1   status_code and standard error object for P0709 Zero-overhead deterministic exceptions
      - P1066R1   How to catch an exception_ptr without even try-ing
      - P1095R0   Zero overhead deterministic failure - A unied mechanism for C and C++
      - P1105R1   Leaving no room for a lower-level language: A C++ Subset
        - talks about freestanding and exceptions that just terminate on throw
      - P1195R0   Making <system_error> constexpr
      - P1196R0   Value-based std::error_category comparison
      - P1197R0   A non-allocating overload of error_category::message()
      - P1198R0   Adding error_category::failed()
      - P1273R0   86 The Absurd (From Exceptions)
      - P1002R1   Try-catch blocks in constexpr functions
      - P0788R2 Standard Library Specification in a Concepts and Contracts World
    - 2019
      - P0829R4   Freestanding Proposal
      - P1377R0   Summary of Dec 2018 SG14 freestanding discussions
      - P0323R8   std::expected
      - P0709R3   Zero-overhead deterministic exceptions: Throwing values
      - P0797R2   Handling Concurrent Exceptions with Executors
      - P1028R2   SG14 status_code and standard error object for P0709 Zero-overhead deterministic exceptions
      - P1640R0   Error size benchmarking
      - P1641R0   Freestanding Library: Rewording the Status Quo
      - P1642R0   Freestanding Library: Easy [utilities]
      - P1656R0   "Throws: Nothing" should be noexcept
      - P1667R0   Concept-aware noexcept specifiers
      - P1675R0   rethrow_exception must be allowed to copy
      - P1676R0   C++ Exception Optimizations. An experiment.
      - P1736R0   SG14: Low Latency Meeting Minutes 2019/04/17-2019/06/12
      - P0323R9   std::expected
      - P0709R4   Zero-overhead deterministic exceptions: Throwing values
	- Minutes: https://wiki.edg.com/bin/view/Wg21cologne2019/P0709R3-EWG
      - P1675R1   rethrow_exception must be allowed to copy
      - P1640R1   Error size benchmarking: Redux
      - P1641R1   Freestanding Library: Rewording the Status Quo
      - P1642R1   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P1888R0   Executors without exception handling support
      - P1909R0   SG14: Low Latency Meeting Minutes 2019/08/14-2019/09/11
      - P1947R0   C++ exceptions and alternatives (Bjarne)
        - 
      - P1028R3   SG14 status_code and standard error object
    - 2020
      - P1642R2   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P1706R2   Programming Language Vulnerabilities for Safety Critical C++
      - P1641R3   Freestanding Library: Rewording the Status Quo
      - P2013R1   Freestanding Language: Optional ::operator new
      - P2170R0   Feedback on implementing the proposed std::error type
      - P1642R4   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P2013R2   Freestanding Language: Optional ::operator new
      - P2013R3   Freestanding Language: Optional ::operator new
      - P1642R5   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P2268R0   Freestanding Roadmap
    - 2021
      - P2232R0   Zero-Overhead Deterministic Exceptions: Catching Values
      - P2338R0   Freestanding Library: Character primitives and the C library
      - P0323R10          std::expected
      - P1706R3   Programming Language Vulnerabilities for Safety Critical C++
      - P2376R0   Comments on Simple Statistical Functions (p1708r4): Contracts, Exceptions and Special cases
      - P2381R0   Pattern Matching with Exception Handling
      - P1642R6   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P2370R0   Stacktrace from exception
      - P2338R1   Freestanding Library: Character primitives and the C library
      - P2392R0   Pattern matching using is and as 
      - P2392R1   Pattern matching using "is" and "as"
      - P2411R0   Thoughts on pattern matching
      - P2410R0   Type-and-resource safety in modern C++
      - P2370R1   Stacktrace from exception
      - P1642R7   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P0323R11          std::expected
      - P2490R0   Zero-overhead exception stacktraces
    - 2022
      - P2370R2   Stacktrace from exception
      - P2517R0   Add a conditional noexcept specification to std::apply
      - P2524R0   SG14: Low Latency/Games/Embedded/Finance/Simulation 2020/12/09-2022/01/12
      - P0323R12          std::expected
      - P2505R1   Monadic Functions for std::expected
      - P2544R0   C++ exceptions are becoming more and more problematic
      - P2549R0   std::unexpected should have error() as member accessor
      - P1642R8   Freestanding Library: Easy [utilities], [ranges], and [iterators]
      - P2490R3   Zero-overhead exception stacktraces
      - P2517R1   Add a conditional noexcept specification to std::apply
      - P2392R2   Pattern matching using is and as
      - P2505R5   Monadic Functions for std::expected
      - P2561R1   An error propagation operator
      - P2683R0   SG14: Low Latency/Games/Embedded/Finance/Simulation virtual meeting minutes 2022/02/09-2022/10/12
      - P2687R0   Design Alternatives for Type-and-Resource Safe C++
      - P2688R0   Pattern Matching Discussion for Kona 2022
      - P1028R4   SG14 status_code and standard error object
      - P2602R2   Poison Pills are Too Toxic
      - P2698R0   Unconditional termination is a serious problem
    - 2023
      - P1028R5   SG14 status_code and standard error object
      - P2887R0   SG14: Low Latency/Games/Embedded/Finance/Simulation virtual meeting minutes to 2023/05/11
      - P2833R1   Freestanding Library: inout expected span
      - P2966R0   Making C++ Better for Game Developers -- Progress Report
      - P2966R1   Making C++ Better for Game Developers -- Progress Report
      - P2976R0   Freestanding Library: algorithm, numeric, and random 
      
      
- Other references for exceptions
  - https://gcc.gnu.org/legacy-ml/libstdc++/2008-06/msg00001.html
    Implementation of exceptions in libstdc++ (std::exception_ptr)
  - A Pragmatic Look at Exception Specifications (2002) - Herb Sutter
    http://www.gotw.ca/publications/mill22.htm
    - Throw specifications could not be included in a typedef of a function-pointer type.
      But they could be included in the type of a function-pointer variable declaration
      #+BEGIN_SRC c++
        void f() throw(A, B);
        
        typedef void (*PF)() throw(A,B); // syntax error

        void (*pf)() throw(A,B); // ok
        pf = f; // ok
      #+END_SRC
    - You can convert from a more-restrictive function-pointer type to a less-restrictive function-pointer type.
      i.e. where the  target variable throw specification is a strict superset of the source function-pointer.
    - If a function does throw an exception not listed in the throw-specification then it calls ~std::unexpected()~
      - This function could rethrow a different exception, but:
        - It was global so was unlikely to be able to choose a suitable alternative exception type.
    - Compiler has to generate more code to ensure at runtime that only those exceptions that match
      the exception-specification are actually thrown.
    - Compiler can insert calls to ~std::unexpected()~ which by default calls ~std::terminate()~.
    - Removing an exception from a throw-specification in a base-class virtual method declaration is a breaking change.
    - Microsoft compiler did not generate code to enforce ~throw()~ specifications, but had optimisations that relied on the stated behaviour.
      - This turned throw-specifications from a request to the compiler to enforce the throw specification
        to a promise to the compiler that you won't throw anything other than these exceptions, which the
        compiler relies upon and optimises. Leading to UB if you do actually end up throwing something
        out-of-specification.
    - Boost guidelines on excpetion specifications basically say "don't use throw-specifications", except maybe "throw()" and even then, you should probably avoid that.
  - The sad history of the C++ throw(...) exception specifier
    https://devblogs.microsoft.com/oldnewthing/20180928-00/

  - https://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf
    Technical report on performance
    - Section 5.4 talks about exception handling
      - 
        #+BEGIN_QUOTE      
        With exceptions, once a problem is identified, it cannot be ignored  failure to catch and
        handle an exception results in program termination.
        #+END_QUOTE
      - 
        #+BEGIN_QUOTE
        In some embedded and resource-constrained environments, use of exceptions was deliberately excluded
        either because of fear of overheads or because available exception implementations could not
        meet a projects requirements for predictability.
        #+END_QUOTE
      - 
        #+BEGIN_QUOTE
        Enforcing exception specifications - Conformance of the thrown types to the
        list of types permitted in the exception-specification must be checked. If a mismatch
        is detected, the unexpected-handler must be called.
        #+END_QUOTE
      - 
        #+BEGIN_QUOTE
        A run-time cost is associated with checking the throw-specifications of the functions
        that are called.
        #+END_QUOTE
      - 
         #+BEGIN_QUOTE
         For some programs, difficulty in predicting the time needed to pass control from a throw-
         expression to an appropriate catch clause is a problem. This uncertainty comes from the
         need to destroy automatic objects and  in the table model  from the need to consult
         the table. In some systems, especially those with real-time requirements, it is important
         to be able to predict accurately how long operations will take.
        
         For this reason current exception handling implementations may be unsuitable for some
         applications.  
         #+END_QUOTE
  - Design and Evolution of C++ (Stroustrup)
    - Chapter 16 - Exceptions
    - Aims and Assumptions (selected points)
      - Exception handlers are rare compared to function definitions.
      - Exceptions occur infrequently compared to function calls.
      - Exceptions are a language-level concept
    - Ideals
      - Type-safe transmission of arbitrary amounts of information from a throw-point to a handler
      - No added const (in time or space) to code that does not throw an exception
      - A guarantee that every exception raised is caught by an appropriate handler.
      - A way of grouping exceptions so that handlers can be written to catch groups of exceptions as well as individual ones.
      - A mechanism that allows cooperation with other languages, especially with C.
      - Easy to use.
      - Easy to implement.
    - Quotes
      - To some, the most important aspect of exceptiosn is that they provide a general
        mechanism for reporting errors detected in a constructor.
        - Workarounds include putting object into an invalid state, leaving return-value indicators
          in agreed-upon variables (global/thread_local/out-parameters).
      - In a mixed-language environment, it is not possible to require a specific  action
        of a function because that function may be written in another language.
        In particular, a C++ function throwing an exception may be called by a C function that was
        called by a C++ function willing to catch the exception.
      - In effect, writing this:
        #+BEGIN_SRC c++
          void f() throw (e1, e2) {
            // stuff
          }
        #+END_SRC
        is equivalent to writing this:
        #+BEGIN_SRC c++
          void f() {
            try {
              // stuff
            }
            catch (e1) { throw; }
            catch (e2) { throw; }
            catch (...) { unexpected(); }
          }
        #+END_SRC
      - The most important advantage is that the function /declaration/ belongs to an interface
        that is visible to its callers. Function /definitions/ on the other hand, are not
        universally available and even if we do have access to the source code of all our
        libraries, we strongly prefer not to have to look at it very often.
      - "Another advantage is that it may still be practical to detect many uncaught exceptions during compilation" - Koenig, 1990
      - Ideally, exception specifications woudl be checked at compile time, but that would
        require that every function cooperate in the scheme, and that isn't feasible.
      - Such static checking could esily become a source of much recompilation.
        Worse, such recompilation would only be feasible for users who had all the source code to recompile.
        #+BEGIN_QUOTE
        For example, a function must potentially be changed and recompiled if a function it calls
        (directly or indirectly) changes the set of exceptions it catchs or throws. This could
        lead to major delays in the production of software produced (partly) by composition of
        libraries from different sources. Such libraries would /de facto/ have to agree on a
        set of exceptions to be used. For example, if subsystem X handles exceptions from subsystem Y
        and the supplier of Y introduces a new kind of exception, then X's code will have to be
        modified to copy. A user of X and Y will not be able to upgrade to a new version of Y until
        X has been modified. Where many subsystems are used this can cause cascading delays.
        Even where the 'multiple supplier problem' does not exist, this can lead to cascading
        modifications of code and to large amounts of recompilation.
        Such problems would cause people to avoid using the exception specification mechanism
        or else subvert it [Koenig, 1990]
        #+END_QUOTE

  - Java Checked Exceptions
    - [[https://medium.com/javarevisited/its-2022-should-we-give-up-using-checked-exception-176429e05d4b][The exception mechanism of Java has been controversial. | by lance | Javarevisited | Medium]]

    - [[http://articles.vconst.com/2009/08/error-handling-and-exceptions-in-java.html][Constantine's Column: Error Handling and Exceptions in Java]]

    - [[https://www.oracle.com/technical-resources/articles/enterprise-architecture/effective-exceptions-part1.html][Effective Java Exceptions]]
      - 
         #+begin_quote
         After all, compiler-imposed constraints on data types encouraged rigorous coding and precise thinking.
         Compile-time type checking helped prevent nasty surprises at run-time.
         Compile-time exception checking would work similarly, reminding developers that a method had potential
         alternate outcomes that needed to be addressed.
         #+end_quote
      -
        #+begin_quote
        To programmers, it seemed like most of the common methods in Java library classes declared checked exceptions
        for every possible failure. For example, the ~java.io~ package relies heavily on the checked exception ~IOException~.
        At least 63 Java library packages issue this exception, either directly or through one of its dozens of subclasses.

        An I/O failure is a serious but extremely rare event. On top of that, there is usually nothing your code can do
        to recover from one. Java programmers found themselves forced to provide for ~IOException~ and similar unrecoverable
        events that could possibly occur in a simple Java library method call. Catching these exceptions added clutter to
        what should be simple code because there was very little that could be done in a catch block to help the situation.
        Not catching them was probably worse since the compiler required that you add them to the list of exceptions your
        method ~throws~. This exposes implementation details that good object-oriented design would naturally want to hide.

        This no-win situation resulted in most of the notorious exception handling anti-patterns we are warned about today.
        It also spawned lots of advice on the right ways and the wrong ways to build workarounds.

        Some Java luminaries started to question whether Java's checked exception model was a failed experiment.
        Something failed for sure, but it had nothing to do with including exception checking in the Java language.
        The failure was in the thinking by the Java API designers that most failure conditions were the same and could be
        communicated by the same kind of exception.
        #+end_quote
      - Talks about two classes of errors: contingency and fault
        - contingencies are expected failures that the caller should be able to handle
        - faults are generally programming bugs / pre-condition failures
      - Contingencies are usually handled relatively close to where they are thrown
        they are part of the return-value / result of a given function call
        - "A contingency represents an alternative method result that is just as important as the principal return result."
      - Faults are usually handled with a high-level "Fault Barrier" that simply logs the
        fault and continues.
      - Recommendation is that contingencies use checked exceptions, while faults use unchecked exceptions
        - Programmers don't want to have to document in the API of all callers that there might be an
          exception thrown due to a programmer bug in the implementation which the caller won't
          have any idea how to handle.

      - Rules for use:
        - The fault barrier method must reside at the head of a graph of method calls that traverses the participating classes.
        - They must all use unchecked exceptions to signify fault contiditions.
        - They must all use the specific unchecked exception types that the fault barrier is expecting to receive.
        - They all must catch and translate checked exceptions from lower methods that are deemed to be faults in their execution context.
        - They must not interfere with the propagation of fault exceptions on their way to the barrier.

    - [[https://markonovakovic.medium.com/checked-exceptions-vs-either-6468ce94c0c9][Checked exceptions vs Either. Exploring the pros and cons of Javas | by Marko Novakovic | Medium]]

    - [[https://softwareengineering.stackexchange.com/questions/420898/why-do-checked-exceptions-i-e-value-or-error-return-values-work-well-in][language design - Why do "checked exceptions", i.e., "value-or-error return values", work well in Rust and Go but not in Java? - Software Engineering Stack Exchange]]

    - [[https://stackoverflow.com/questions/613954/the-case-against-checked-exceptions][java - The case against checked exceptions - Stack Overflow]]
      - checked exceptions are about being able to communicate errors between layers

      - 

    - [[https://www.artima.com/articles/the-trouble-with-checked-exceptions][artima - The Trouble with Checked Exceptions]] (Bill Venners, Bruce Eckel, Anders Hejlsberg)
      - Versioning
        - Adding a new exception is a breaking change for client code in many cases.
          - Would need to add a new method with a wider exception specification.
          - Without checked exceptions you are breaking the client code silently anyway
            - In lots of cases people don't care - they want to let most errors propagate up to some top-level handler.

      - Scalability
        - In small, checked exceptions are enticing, dealing with small numbers of errors.
        - At scale, high-level ends up with an unwieldy list of exceptions it might throw
          - e.g. code that calls into 4-5 different subsystems that each throw 4-10 exception types can easily end up with 40 exceptions they might need to list
            in their throw-specification
            - Also, adding a new exception to a leaf API you then need to update all caller throw specifications to add this
              new exception.
          - so people end up just writing ~throws Exception~ which then circumvents the benefits of checked exceptions
          - or they end up writing ~try { ... } catch(Exception) {}~ and just suppressing the errors - leading to worse outcomes
            
    - [[https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html][Unchecked Exceptions  The Controversy (The Java Tutorials > Essential Java Classes > Exceptions)]]
      - Inheritance hierarchy:
        - ~Object~
          - ~Throwable~
            - ~Error~ - serious problems that a resonable application should not try to catch (e.g. VM error, assertion failure)
            - ~Exception~
              - ~RuntimeException~ - 
                - all user unchecked exceptions go here
              - all user checked exceptions go here
      - RuntimeException, Error and their subclasses are "unchecked exceptions"
        - language doesn't require unchecked exceptions to be listed in the throw specification, or caught
      - "Any Exception that can be thrown by a method is part of the method's public programming interface."
        "Those who call a method must know about the exceptions that a method can throw so that they can decide what to do about them."
        "These exceptions are as much a part of that method's programming interface as its parameters and return value."
      - Unchecked exceptions represent problems that are the result of a programming problem, and as such, the API client
        code cannot reasonably be expected to recover from them or to handle them in any way.
        e.g. divide by zero, null-pointer dereference, out-of-bounds index
        - In C++ these would be undefined-behaviour / pre-condition failures.
      - "If a client can reasonably be expected to recover from an exception, make it a checked exception.
         If a client cannot do anything to recover from the exception, make it an unchecked exception."
        - These broadly break down to pre-condition violations and recoverable errors.

    - 

  - Rust error handling
    - [[https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html][To panic! or Not to panic! - The Rust Programming Language]]
      -
        #+begin_quote
        You could call ~panic!~ for any error situation, whether theres
        a possible way to recover or not, but then youre making the
        decision that a situation is unrecoverable on behalf of the
        calling code. When you choose to return a ~Result~ value, you
        give the calling code options. The calling code could choose
        to attempt to recover in a way thats appropriate for its
        situation, or it could decide that an ~Err~ value in this case
        is unrecoverable, so it can call ~panic!~ and turn your
        recoverable error into an unrecoverable one. Therefore,
        returning ~Result~ is a good default choice when youre defining
        a function that might fail.
        #+end_quote



  - Previous papers relating to customisation points / overload-sets / ADL
   - N2216 	07-0076 	Report on language support for Multi-Methods and Open-Methods for C++ (2007)
    - P0119R1   Overload sets as function arguments
    - P0084R1   Emplace Return Type (Revision 1)
      - Might be relevant to call-with-return-value-slot() function idea I had for fibers/coroutines
    - P0534R0   call/cc (call-with-current-continuation): A low-level API for stackful context switching 
    - P0536R0   Implicit Return Type and Allowing Anonymous Types as Return Values
    - P0551R0   Thou Shalt Not Specialize std Function Templates!
    - P0923R0   Modules: Dependent ADL
    - P0934R0   A Modest Proposal: Fixing ADL
  - 2018
    - P0923R1   Modules:Dependent ADL   Nathan Sidwell
    - P1170R0   Overload sets as function parameters
  - 2019
    - P1347R1   Modules: ADL & Internal Linkage
    - P1601R0   Recommendations for Specifying Hidden Friends
    - P1665R0   Tag Based Customization Point Functions
    - P1772R0   Variadic overload sets and overload sequences
    - P1779R0   ABI isolation for member functions
    - P1772R1   Variadic overload sets and overload sequences
    - P1779R2   ABI isolation for member functions
    - P1787R3   Declarations and where to find them
    - P1965R0   Blanket Wording for Specifying "Hidden Friends"
    - P2123R0   interfaces: A Facility to Manage ABI/API Evolution
    - P2191R0   Modules: ADL & GMFs do not play together well (anymore)
    - P2279R0   We need a language mechanism for customization points
    - P2538R1   ADL-proof std::projected
    - P2600R0   A minimal ADL restriction to avoid ill-formed template instantiation
    - P2602R0   Poison Pills are Too Toxic
    - P2602R1   Poison Pills are Too Toxic
    - P2893R0   Variadic Friends
    - 

      
  - Previous papers relating to contracts
    - 2013
      - N3604 - Centralized Defensive-Programming Support for Narrow Contracts
      - N3753 - Centralized Defensive-Programming Support for Narrow Contracts (Revision 1)
      - N3818 - Centralized Defensive-Programming Support for Narrow Contracts (Revision 2)
    - 2014
      - N3877 - Centralized Defensive-Programming Support for Narrow Contracts (Revision 3)
      - N3997 - Centralized Defensive-Programming Support for Narrow Contracts (Revision 5)
      - N4075 - Centralized Defensive-Programming Support for Narrow Contracts (Revision 5)
      - N4110 - Exploring the design space of contract specifications for C++
    - 2015
      - N4378 - Language Support for Contract Assertions 
      - N4379 - FAQ about N4378, Language Support for Contract Assertions
      - N4435 - Proposing Contract Attributes       
      - P0147R0         The Use and Implementation of Contracts
      - P0166R0         Three interesting questions about contracts
    - 2016
      - P0380R0         A Contract Design
      - P0380R1         A Contract Design
    - 2017
      - P0542R0         Support for contract based programming in C++
      - P0542R1         Support for contract based programming in C++
      - P0542R2         Support for contract based programming in C++
    - 2018
      - P0542R3         Support for contract based programming in C++
      - P0542R4         Support for contract based programming in C++
      - P1320R0         Allowing contract predicates on non-first declarations
      - P1321R0         UB in contract violations
      - P1323R0         Contract postconditions and return type deduction
    - 2019
      - P1290R1         Avoiding undefined behavior in contracts
      - P1323R1         Contract postconditions and return type deduction
      - P1426R0         Pull the Plug on Contracts? 
      - P1429R0         Contracts That Work
      - P1443R0         SG14: Low Latency Meeting Minutes 2018/07/11 - 2019/01/09
      - P1429R1         Contracts That Work
      - P1606R0         Requirements for Contract Roles
      - P1607R0         Minimizing Contracts
      - P1625R0         Contracts: why the house is not on fire (i.e. why the status quo is tolerable)
      - P1486R0         United Amendment to Contracts Facility for C++20
      - P1486R1         United Amendment to Contracts Facility for C++20
      - P1487R0         User Experience with Contracts That Work
      - P1670R0         Side Effects of Checked Contracts and Predicate Elision
      - P1671R0         Contract Evaluation in Constant Expressions
      - P1680R0         Implementing Contracts in GCC
      - P1704R0         Undefined functions in axiom-level contract statements
      - P1710R0         Adding a global contract assumption mode
      - P1711R0         What to do about contracts?
      - P1728R0         Preconditions, axiom-level contracts and assumptions -- an in depth study
      - P1730R0         Adding a global contract assumption mode
      - P1743R0         Contracts, Undefined Behavior, and Defensive Programming
      - P1744R0         Avoiding Misuse of Contract-Checking
      - P1769R0         The "default" contract build-level and continuation-mode should be implementation-defined
      - P1773R0         Contracts have failed to provide a portable "assume"
      - P1774R0         Portable optimisation hints
      - P1782R0         Local contract restrictions
      - P1786R0         Adding a global contract assumption mode
      - P1429R3         Contracts That Work
      - P1607R1         Minimizing Contracts
      - P1807R0         An Overview of Contracts Papers for Cologne
      - P1812R0         Axioms should be assumable: a minimal fix for contracts
      - P1823R0         Remove Contracts from C++20
      - P1995R0         Contracts - Use Cases
      - P2064R0         Assumptions
      - P1995R1         Contracts - Use Cases
      - P2032R0         Contracts - What Came Before
      - P2114R0         Minimial Contract Use Cases
      - P2176R0         A different take on inexpressible conditions
      - P2185R0         Contracts Use Case Categorization
      - P2053R1         Defensive Checks Versus Input Validation
      - P2339R0         Contract violation handlers
      - P2358R0         Defining Contracts
      - P2388R0         Abort-only contract support
      - P2388R1         Minimum Contract Support: either Ignore or Check_and_abort
      - P2388R2         Minimum Contract Support: either Ignore or Check_and_abort
      - P2388R3         Minimum Contract Support: either No_eval or Eval_and_abort
      - P2466R0         The notes on contract annotations
      - P2659R0         A Proposal to Publish a Technical Specification for Contracts
      - P2660R0         Proposed Contracts TS
      - P2661R0         Miscellaneous amendments to the Contracts TS
    - 2023
      - P2831R0         Functions having a narrow contract should not be noexcept
      - P2834R0         Semantic Stability Across Contract-Checking Build Modes
      - P2837R0         Planning to Revisit the Lakos Rule 
      - P2852R0         Contract violation handling semantics for the contracts MVP
      - P2853R0         Proposal of std::contract_violation
      - P2858R0         Noexcept vs contract violations
      - P2861R0         The Lakos Rule: Narrow Contracts And `noexcept` Are Inherently Incompatible
      - P2521R4         Contract support -- Record of SG21 consensus
      - P2487R1         Is attribute-like syntax adequate for contract annotations?
      - P2811R5         Contract-Violation Handlers
      - P2811R6         Contract-Violation Handlers
      - P2811R7         Contract-Violation Handlers
      - P2877R0         Contract Build Modes and Semantics
      - P2834R1         Semantic Stability Across Contract-Checking Build Modes
      - P2885R0         Requirements for a Contracts syntax
      - P2920R0         Library Evolution Leadership's Understanding of the Noexcept Policy History
      - P2947R0         Contracts must avoid disclosing sensitive information
      - P2949R0         Slides for P2861R0: Narrow Contracts and `noexcept` are Inherently Incompatable
      - P2521R5         Contract support -- Record of SG21 consensus
      - P2885R1         Requirements for a Contracts syntax
      - P2890R0         Contracts on lambdas
      - P2894R0         Constant evaluation of Contracts
      - P2896R0         Outstanding design questions for the Contracts MVP
      - P2935R0         An Attribute-Like Syntax for Contracts
      - P2954R0         Contracts and virtual functions for the Contracts MVP
      - P2957R0         Contracts and coroutines
      - P2932R0         A Principled Approach to Open Design Questions for Contracts
      - P2935R2         An Attribute-Like Syntax for Contracts
      - P2961R0         A natural syntax for Contracts
      - 
        


