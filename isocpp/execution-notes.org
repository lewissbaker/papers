* Notes on std::execution wording for pre-Sofia draft

** Standard defined queries can't customize ~forwarding_query_t~ by inheriting from it

The definition of the ~forwarding_query_t~ ([[[https://eel.is/c++draft/exec#fwd.env][exec.fwd.env]]]) states that a query is a
forwarding-query if either the expression ~q.query(forwarding_query)~ is a constant
expression that evalutes to true o or the query type inherits from forwarding_query_t.

However, all of the queries defined in [[[https://eel.is/c++draft/exec][exec]]] are defined similar to the following:
#+begin_src c++
  struct get_allocator_t { unspecified };
#+end_src

While this definition allows for the members of the class to be unspecified, it still
explicitly specifies that it has an empty list of base-classes and therefore cannot
customize ~forwarding_query_t~ by inheriting from ~forwarding_query_t~.

We should consider whether we want to change the specification of queries that are
to be forwarding-queries to allow inheritance from ~forwarding_query_t~ or otherwise
remove the support for customising ~forwarding_query_t~ by inheriting from it.

The recommended resolution is to remove the rule that checks for inheritance from
~forwarding_query_t~.

** Equal schedulers should be required to have same behaviour

The wording [[[https://eel.is/c++draft/exec#sched-4][exec.sched]]] p4 says:
#+begin_quote
For any two values ~sch1~ and ~sch2~ of some scheduler type ~Sch~, ~sch1 == sch2~ shall
return ~true~ only if both ~sch1~ and ~sch2~ share the same associated execution resource.
#+end_quote

However, I don't think this requirement is sufficient for schedulers to be considered
equal as it is possible to have two different schedulers that share the same associated
execution resource but that have different behaviour.

For example, two schedulers of the same type but where one schedules items with high
priority and others with low priority.

Ideally we want two schedulers to be equal if and only if they can be used interchangeably
such that using either scheduler to schedule work has the same behaviour.

Note that some use cases may also want to compare two schedulers as to whether or not
they share the same associated execution resource, independently of their scheduling
behaviour, however this could be added as a separate operator later.
e.g. ~std::execution::same_resource(sch1, sch2)~

It's also not clear how this definition applies to schedulers such as an ~inline_scheduler~
(added in P3552) in which has no specific associated execution resource but instances
nevertheless have the same scheduling behaviour.

I suggest this paragraph is changed to refer to the schedulers having the same
scheduling behaviour rather than having the same associated execution resource.
Or at least add a note here indicating that equality operator may return false
if the behaviour is different, even if the schedulers share an associated execution
resource.

** Remove note regarding waiting for completion of scheduled operations

The note at the end of [[https://eel.is/c++draft/exec#sched-note-1][exec.sched]] says:
#+begin_quote
[Note: The ability to wait for completion of submitted function objects can be
provided by the associated execution resource of the scheduler - end note]
#+end_quote

The suggestion that the execution resource should be used to join/wait on
scheduled work is problematic in situations that may involve more than one
execution context, as an execution resource having an empty queue of scheduled
work does not necessarily imply that tasks currently running on another
execution context will not later schedule additional work on this execution
resource.

With the introduction of ~counting_scope~ with P3149 we now have a better recommended
way of waiting for tasks that use a resource (including execution resources)
to complete.

The note as it stands represents bad guidance and should either be removed or
updated to refer to ~counting_scope~ and ~simple_counting_scope~ ([exec.counting.scopes]).

** Consider mandating that ~set_value()~, ~set_error()~ and ~set_stopped()~ calls have a return-type of ~void~

The expression ~set_value(rcvr, vs...)~ is defined as expression-equivalent to ~MANDATE-NOTHROW(rcvr.set_value(vs...))~.

As we do not also mandate that the result-type of this expression must be ~void~, it is presumably
allowed to return any other type and the ~set_value_t~ CPO is required to return any such value
returned by the member-function in order to preserve the "expression-equivalent" property.

I think we should mandate that the return-type of this expression is ~void~ to both avoid
misuse of the return-value here but also to preserve design space for potential future
extensions that might want to ascribe meaning to non-void return-values.

Similarly for the ~set_error~ and ~set_stopped~ CPOs.

*Suggestion:*
Add a "Mandates: If the expression ~set_value(rcvr, vs...)~ is well-formed, its type shall be ~void~." to [exec.set.value].
And similarly for ~set_error~ and ~set_stopped~.

** Reconsider ~weakly_parallel~ as the default ~forward_progress_guarantee~

The ~get_forward_progress_guarantee~ CPO is intended to allow querying a scheduler
as for what sort of forward-progress guarantee it provides.

Algorithms may use this to determine whether it is safe to execute certain
operations on a given scheduler.

If a scheduler does not customize this query, the query will fall back to returning
a forward-progress guarantee of ~weakly_parallel~.

I think we should reconsider what this default should be returning and suggest it
should instead return ~parallel~ by default, as this will be by far the most common
kind of scheduler - i.e. a scheduler that executes on ~std::thread~-like execution
agents and that maintains a queue of scheduled tasks.

I expect it to be common that authors of schedulers may forget to customize the
~get_forward_progress_guarantee_t~ query and just leave it at the default, which
will likely leave their scheduler reporting a weaker guarantee than it actually
provides and thus not being usable within generic algorithms that require at least
~parallel~ forward progress.

For example, the ~run_loop~ execution context defined in [exec.run.loop] does not
define its scheduler to customize the ~get_forward_progress_guarantee_t~.
This means it will report the default value of ~weakly_parallel~.

However, the scheduled operations will run on the thread that calls ~run_loop::run()~
and thus will inherit its forward-progress guarantees, and as this function might
block and is therefore unsafe to invoke it from a thread with ~weakly_parallel~
forward progress guarantes (which should probably be explicitly specified as
having undefined-behaviour) we can safely assume that ~run_loop~'s scheduler can
provide ~parallel~ forward-progress guarantee (assuming some thread eventually calls
~run()~).

It's not clear whether the current ~run_loop~ specification defaulting to it's scheduler
having ~weakly_parallel~ forward progress guarantee is intentional or unintentional here.

Schedulers that provide either ~weakly_parallel~ or ~concurrent~ forward progress
guarantees require implementations to be much more aware of the fact that these
are the guarantees they are providing and thus could be more expected to customize
the  ~get_forward_progress_guarantee~ query to return the respective values.

** ~run_loop~'s scheduler should probably report a ~get_forward_progress_guarantee()~ of ~parallel~

Currently ~run_loop~ specification does not define that its scheduler has a customisation of
the ~get_forward_progress_guarantee~ query. This means that it will report a forward-progress
guarantee by default of ~weakly_parallel~.

However, as all tasks scheduled to a ~run_loop~ will be run on the thread that calls
~run_loop::run()~ and because ~run_loop::run()~ may be required to block until scheduled
items are submitted, it would not be safe to call ~run_loop::run()~ from a thread
with a weakly-parallel forward-progress guarantee. Thus we should be able to assume
that ~run_loop~ itself will provide a forward-progress guarantee of ~parallel~.

** It is not possible to constrain a scheduler to require that it statically provides a forward-progress guarantee

It is not possible to evaluate whether the result of the ~get_forward_progress_guarantee()~
query on a given scheduler is going to return a given value as this query is required
to return type ~forward_progress_guarantee~, preventing it from returning e.g.
~constant_wrapper<forward_progress_guarantee::parallel>~.

Also, implementations of the ~queryable~ concept in [exec] do not define static ~query~
functions, so we cannot generally test whether all instances of a queryable object
will return a given value by testing whether ~queryable_type::query(some_query_t{})~ is valid.

This seems to be a fundamental limitation of the ~queryable~ concept and of the environment
object wrappers that [exec] provides.

See https://godbolt.org/z/rcP1Y3jY9 for an example of how we might be able to define
wrappers to forward staticness of queries.

** Unnecessary constraint in ~receiver~ and ~sender~ concepts

In [exec.recv.concepts] ~concept receiver~ is constraining on whether ~get_env(rcvr)~ returns a type that satisfies ~queryable~,
but the ~get_env~ CPO already mandates that the return-value satisfies ~queryable~, so this check seems redundant.

Suggested change:
#+begin_src diff
   template<class Rcvr>
     concept receiver =
       derived_from<typename remove_cvref_t<Rcvr>::receiver_concept, receiver_t> &&
       requires(const remove_cvref_t<Rcvr>& rcvr) {
  -      { get_env(rcvr) } -> queryable;
  +      get_env(rcvr);
       } &&
       move_constructible<remove_cvref_t<Rcvr>> &&       // rvalues are movable, and
       constructible_from<remove_cvref_t<Rcvr>, Rcvr>;   // lvalues are copyable
#+end_src

However, as the ~get_env()~ CPO is defined for all objects (it will fall back to returning
~env<>~ if ~AS-CONST(obj).get_env()~ is not valid), testing whether ~get_env(rcvr)~
expression is valid is not actually going to constrain types in any way.
So we could consider just removing the entire ~requires~ expression that checks
for ~get_env(rcvr)~.

Similar changes should be applied to the ~sender~ concept definition in [exec.snd.concepts].

** Unnecessary constraint in ~operation_state~ concept

The ~operation_state~ concept is defined in [exec.opstate.general] as follows:
#+begin_src c++
  template<class O>
    concept operation_state =
      derived_from<typename O::operation_state_concept, operation_state_t> &&
      is_object_v<O> &&
      requires (O& o) {
        { start(o) } noexcept;
      };
#+end_src

The ~requires~ expression that checks that the ~start(op)~ expression is valid also
checks that this expression is ~noexcept~. However, the ~start~ CPO already mandates
that the expression is ~noexcept~ and so the additional ~noexcept~ check in the
~operation_state~ concept seems unnecessary.

Can we simplify the ~operation_state~ concept to remove the ~noexcept~ check?

** Specification of queries should not require passing references to global CPO objects

The specification of most queries in [exec] defines them to be "expression-equivalent to"
calling the ~query()~ member-function, passing the global CPO object as the argument.

For example: The ~get_allocator~ query is defined as:
#+begin_src c++
  namespace std::execution {
  struct get_allocator_t { unspecified };
  inline constexpr get_allocator_t get_allocator{};
#+end_src
such that ~get_allocator(env)~ is expression-equivalent to ~MANDATE-NOTHROW(AS-CONST(env).query(get_allocator))~

However, when such a formulation is combined with the definition of customization-point object
in [customization.point.object] we can end up with implementations that need to unnecessarily
pass references to the global object.

The wording in [customization.point.object] requires that calling ~operator()~ on any instance of the
customization-point object type, whether const-qualfified or not and whether on an lvalue or rvalue,
has equivalent effects to calling the original customization point object.

Since the effects of calling ~get_allocator(env)~ is such that it passes the object ~get_allocator~ as
an argument to the ~env.query()~ call, then all calls to function objects of type ~get_allocator_t~
must also be expression-equivalent to ~env.query(get_allocator)~. i.e they must pass in a reference
to the global object as this would be detectable behaviour inside the ~query()~ member function.

For example, I could write a ~query()~ function that looked like:
#+begin_src c++
  struct my_env {
    std::allocator<void> query(const std::execution::get_allocator_t& q) const noexcept {
      assert(&q == &std::execution::get_allocator);
      return std::allocator<void>{};
    }
  };
#+end_src
and would be presumably within expected behaviour for the assertion to pass when evaluating
#+begin_src c++
  my_env env;
  auto query = std::execution::get_allocator;
  auto alloc = query(env);
#+end_src

In order to satisfy this behaviour, implementations would need to define ~get_allocator_t~
something like the following:
#+begin_src c++
  namespace std::execution {
    template<class Queryable, class Query>
    concept __has_query = requires(const Queryable& env, const Query& query) {
      env.query(query);
    };

    template<class Queryable, class Query>
    using __query_result_t = decltype(std::declval<const Queryable&>().query(std::declval<const Query&>()));

    struct get_allocator_t {
      template<__has_query<get_allocator_t> Queryable>
      static constexpr auto operator()(const Queryable& q) noexcept
        -> __query_result_t<Queryable, get_allocator_t>;
    };
    inline constexpr get_allocator_t get_allocator{};
    // Must define the operator() overload after 'get_allocator' object definition
    // so that it can pass a reference to 'get_allocator'.
    template<__has_query<get_allocator_t> Queryable>
    constexpr auto get_allocator_t::operator()(const Queryable& q) noexcept
      -> __query_result_t<Queryable, get_allocator_t> {
      return q.query(get_allocator);
    }
  }
#+end_src

This can result in potential aliasing of the CPO object, forcing an instance to live in the binary.

If queries were instead defined to pass a prvalue CPO as an argument to the ~query()~ member
function then implementations could avoid unnecessarily aliasing the global CPO object and
also allow simplification of the implementation, allowing the ~operator()~ to be defined
inline.

For example, simply changing ~get_allocator(env)~ to be expression-equivalent to ~MANDATE-NOTHROW(AS-CONST(env).query(auto(get_allocator)))~
would now permit the following implementation:
#+begin_src c++
  namespace std::execution {
    template<class Queryable, class Query>
    concept __has_query = requires(const Queryable& env) {
      env.query(Query{});
    };

    template<class Queryable, class Query>
    using __query_result_t = decltype(std::declval<const Queryable&>().query(std::declval<Query>()));

    struct get_allocator_t {
      template<__has_query<get_allocator_t> Queryable>
      static constexpr auto operator()(const Queryable& q) noexcept
        -> __query_result_t<Queryable, get_allocator_t> {
        return q.query(get_allocator_t{});
      }
    };
    inline constexpr get_allocator_t get_allocator{};
  }
#+end_src

The suggested change is to replace occurrences of a customization-point object ~cpo~ with ~auto(cpo)~ in
the "expression-equvalent to" expression for all customization-point objects defined in [exec].

** Unformatted

- specification for ~FWD-ENV(env)~ talks about that for queryable object ~env~, ~FWD-ENV(env).query(q, as...)~ is expression-equivalent to ~env.query(q, as...)~.
  My interpretation of this is that this must end up calling ~env.query~ on the original ~env~ object, not on a copy
  of ~env~, and thus the resulting type of ~FWD-ENV(env)~ necessarily needs to store a reference to ~env~.
  However, many uses of ~FWD-ENV~ use ~FWD-ENV(get_env(x))~ which might end up passing a temporary object to ~FWD-ENV~.

- specification of ~completion_signatures~ usage should make use of ~type_order~ facilities to
  ensure a canonical ordering of types listed in ~completion_signatures~.

- ~transform_sender~, ~transform_env~ and ~apply_sender~ are all regular functions, whereas other customisation
  points are all defined as CPOs. Why do we define these as normal functions and the others as CPOs?

- ~default_domain::transform_env~ has a fallback of ~static_cast<Env>(std::forward<Env>(env))~ but it's not
  clear what the effect of the ~static_cast~ is here.
  - If this function is passed an lvalue, then ~Env~ is an lvalue-reference and the static_cast does not
    do anything more than ~std::forward<Env>(env)~ does.
  - If this function is passed an rvalue, then the ~static_cast~ will construct a new prvalue.
    - Why is this the desired behaviour?

- Use of ~common_type~ in ~completion-domain~ helper makes things extra complicated.
  Can we just get away with ~same_as~ here instead?

- In ~get-domain-late~ it uses a lambda expression with the structured binding:
  #+begin_src c++
    [] {
      auto [_, sch, _] = sndr;
      return query-with-default(get_domain, sch, default_domain());
    }()
  #+end_src
  However this will try to perform a copy of the sender which will be ill-formed if the
  sender is not copyable (Note ~sndr~ is a const-ref). The structured binding should instead
  start with ~auto& [_, sch, _] =~.

- ~env<Envs...>~ class contains a ~query(QueryTag)~ member-function that only takes the query-tag.
  However, the ~queryable~ concept description in [exec.queryable.general] still talks about
  queries taking a pack of extra arguments after the query tag. Similarly with the definition
  of ~FWD-ENV(env).query(q, as...)~ which also talks about forwarding an extra pack of arguments.
  Either we should drop support from extra arguments, or we should add support for extra arguments
  to ~env<Envs...>~ and ~prop<Query, Value>~.

- ~env<Envs...>::query()~ has a return-type defined as ~decltype(auto)~.
  I suspect this may cause problems for some queries that need to get the return-type but
  for which the body may not yet be valid (e.g. because some types are still incomplete).
  Although I don't have any concrete examples of where this is an issue at the moment.

- ~unstoppable_token~ concept is ill-formed
  - Can't use ~tok~ argument to ~requires~ clause in evaluated context.
  - Need to change requirement to ~requires (!Token::stop_possible());~ instead.

- ~AS-EXCEPT-PTR(err)~ is not necessarily ~noexcept~ yet is used in contexts (such as ~set_error()~ in [exec.sync.wait])
  where emitting an exception would result in termination.
  - In particular, the paragraph that says it's equivalent to ~make_exception_ptr(system_error(err))~ when ~err~ is an ~error_code~
    might throw from the ~system_error~ constructor, whose constructor is not marked ~noexcept~.
  - Should this be changed to catch any exception thrown by the exception and return
    ~current_exception()~ in that case?

- ~get_allocator_t~ uses ~MANDATE-NOTHROW~ but lots of allocator types are not actually required
  to be nothrow copyable/movable, only that they are "Throws: nothing".
  - Do we need this to be transparent to ~noexcept~ here, instead?

- ~with-await-transform::await_transform()~ uses ~decltype(auto)~ as the return-type.
  Should it use a trailing return-type instead?

- Wording for ~connect()~ needs to specify that ~rcvr~ is only to be evaluated once.
  - It occurs once in call to ~transform_sender(dom, sndr, rcvr)~
  - And occurs again in call to ~new_sndr.connect(rcvr)~

- Wording for ~connect()~ requires evaluating ~get_env(rcvr)~ even if ~get-domain-late~ ends up
  returning a ~default_domain~. Do we want to allow eliding call to ~get_env(rcvr)~ if the
  returned environment would be unused?

- Why are most customization points defined as CPOs, but ~transform_sender~, ~transform_env~ and ~apply_sender~
  are defined as normal functions?

- ~on()~ specification seems to already assume the context that the operation was started on
  is the same as ~get_scheduler(get_env(rcvr))~.
  - Can we make this a more general requirement that if the receiver's environment
    provides ~get_scheduler~ that this places a requirement on the caller to ensure ~start()~
    is called on that context?
  - Alternatively, we should reword the phrasing in [exec.on] to avoid talking about resuming
    on the execution context that it started on and instead just talk about resuming on
    the execution context associated with ~get_scheduler(get_env(rcvr))~.

- Wording for ~connect()~ defines fallback to be expression-equivalent to ~connect-awaitable(new_sndr, rcvr)~.
  However, ~connect-awaitable~ has a ~requires~ clause that checks that ~rcvr~ is able to receive all of the
  completion signals.
  - Should be be "mandating" that ~rcvr~ is able to receive all of the signals rather than using "constraints"
    here?
  - We don't seem to use constraints that check the receiver is able to accept all of the signals when
    calling member ~.connect()~ function so I think we should be consistent with the ~connect-awaitable~
    fallback here.

- Wording for ~connect()~ defines ~operation-state-task~ which must have ~promise_type~ member equal to
  ~connect-awaitable-promise~ whose type depends on type of ~sndr~ and ~rcvr~ expressions passed into
  ~connect()~. However, other than the ~::promise_type~ member alias, there isn't anything in
  ~operation-state-task~ that actually depends on the types of the sender/receiver and so we could
  potentially avoid making this type dependent and all of the additional instantiations needed
  to use it if we instead specialised ~coroutine_traits<operation-state-task, _Sndr, _Rcvr>~ to
  have a ~promise_type~ of ~connect-awaitable-promise~ rather than specifying that ~operation-state-task~
  must have a ~promise_type~ of ~connect-awaitable-promise~.

- Wording for ~connect()~ constructs a coroutine for awaitables but does not make use of the allocator
  provided by ~get_allocator(get_env(rcvr))~ to allocate the coroutine state. Instead, it just uses
  the global allocation function. Should it use the allocator from the environment instead?

- Wording for ~connect-awaitable~ helper in [exec.connect] uses ~same_as<V, void>~ to check for void return-type
  of the await expression, but we should be using ~is_void_v<V>~ here to also handle /cv/ ~void~.

- Should definition of ~connect-awaitable-promise~ in [exec.connect] be calling ~unreachable()~ inside
  the ~final_suspend()~, ~unhandled_exception()~ and ~return_void()~ member-functions instead of ~terminate()~?

- Wording for [exec.as.awaitable] [[https://eel.is/c++draft/exec#as.awaitable-7.2][p7.2]] uses "Preconditions:" for things that look like they should be "constraints".

- Wording for [exec.as.awaitable] [[https://eel.is/c++draft/exec#as.awaitable-7.2][p7.2]] contains the phrase:
  #+begin_quote
... and the expression ~co_await expr~ in a coroutine with promise type ~U~ is expression-equivalent
to the same expression in a coroutine with promise type ~Promise~.
  #+end_quote
  It is not clear how this can be "expression-equivalent to" as the types involved are not the
  same: a different ~coroutine_handle<Promise>~ type is passed to ~await_suspend()~ and ~Promise~
  potentially calls ~await_transform~.
  Perhaps we should use some phrasing along the lines of "effects equivalent to" instead of
  "expression-equivalent to"?

  Alternatively, perhaps there is a different way to describe this by checking whether:
  ~GET-AWAITER(expr, p)~ satisfies ~is-awaiter<Promise>~ where ~p~ is an lvalue-reference to
  an unspecified promise type that does not have an ~await_transform~ member.
  This should effectively just apply the ~operator co_await()~ if such a call is well-formed
  and then check that the result is a valid awaiter in a coroutine with promise-type ~Promise~.
  This would avoid the need to say anything about whether a ~co_await~ expression in some
  coroutine with an unspecified promise is equivalent to a ~co_await~ expression in a
  coroutine with the promise type of ~Promise~.

- Wording for ~as_awaitable~ in [exec.as.awaitable] defines what ~as_awaitable(expr, p)~ is
  equivalent to if ~p~ is an lvalue, but doesn't say what happens if ~p~ is not an lvalue.
  I think we need to say something like "If ~p~ is not an lvalue then ~as_awaitable(expr, p)~
  is ill-formed."

- Wording for [exec.as.awaitable] concept ~awaitable-sender~ refers to unqualified ~awaitable-receiver~
  type. This type should be qualified as ~sender-awaitable<Sndr, Promise>::awaitable-receiver~.

- In [exec.as.awaitable] should ~sender-awaitable~ handle the case where the completion-signatures of the sender
  do not contain any error completions and where ~is_nothrow_constructible_v<result-type, Vs...>~ is true for
  all value completions ~set_value_t(Vs...)~ by avoiding the need to store an ~exception_ptr~ and also
  declaring the ~await_resume()~ member function of ~sender-awaitable~ as ~noexcept~?
  Implementations can already do this if they want to (strengthening is allowed), but do we want
  to require implementations to do this?

- In [exec.as.awaitable] the ~awaitable-receiver::set_value~ member-function is defined as having
  a constraint that the result-type is constructible from the values. Should we be using mandates
  here instead? There shouldn't be any need to change behaviour based on whether or not the
  receiver's completion methods are well-formed or not.

- In [exec.as.awaitable] [[https://eel.is/c++draft/exec#as.awaitable-4.4][p4.4]] we define ~get_env(crcvr).query(tag, as...)~ as expression equivalent
  to ~tag(get_env(as_const(crcvr.continuation.promise())), as...)~.
  However, this can result in the returned environment satisfying some queries by returning default
  values when the original environment did not provide implementations for those queries. This is
  inconsistent with the definitions of ~env<Envs...>::query()~, ~FWD-ENV~ and other environment wrappers
  for which an ~env.query(q)~ is only valid if the underlying environment's ~env.inner.query(q)~ expression is valid.

* Notes not directly related to [exec] wording

- suggestion for language improvement for lookup of ~operator co_await()~.
  - Why can't we make the expression ~operator co_await(x)~ perform lookup of both member-function
    and namespace-scope functions (using ADL) and then perform overload resolution on both
    rather than having to separately perform member and non-member lookup?


