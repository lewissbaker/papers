* Notes on std::execution wording for pre-Sofia draft

** DELEGATED Standard defined queries can't customize ~forwarding_query_t~ by inheriting from it :design:
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 09:22:01+0930]
:END:
:LOGBOOK:
- State "DELEGATED"  from "WAITING"       [2025-08-28 Thu 13:52]
  Tracked as https://cplusplus.github.io/LWG/issue4326
- State "WAITING"  from              [2025-08-25 Mon 09:22] \\
  Sent to lwgchair.
:END:

The definition of the ~forwarding_query_t~ ([[[https://eel.is/c++draft/exec#fwd.env][exec.fwd.env]]]) states that a query is a
forwarding-query if either the expression ~q.query(forwarding_query)~ is a constant
expression that evalutes to true o or the query type inherits from forwarding_query_t.

However, all of the queries defined in [[[https://eel.is/c++draft/exec][exec]]] are defined similar to the following:
#+begin_src c++
  struct get_allocator_t { unspecified };
#+end_src

While this definition allows for the members of the class to be unspecified, it still
explicitly specifies that it has an empty list of base-classes and therefore cannot
customize ~forwarding_query_t~ by inheriting from ~forwarding_query_t~.

We should consider whether we want to change the specification of queries that are
to be forwarding-queries to allow inheritance from ~forwarding_query_t~ or otherwise
remove the support for customising ~forwarding_query_t~ by inheriting from it.

The recommended resolution is to remove the rule that checks for inheritance from
~forwarding_query_t~.

** DELEGATED Equal schedulers should be required to have same behaviour :design:
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 09:45:11+0930]
:END:
:LOGBOOK:
- State "DELEGATED"  from "WAITING"  [2025-08-28 Thu 13:53] \\
  Tracked as https://cplusplus.github.io/LWG/issue4327
- State "WAITING"    from              [2025-08-25 Mon 09:45] \\
  Sent to lwgchair.
:END:

The wording [[[https://eel.is/c++draft/exec#sched-4][exec.sched]]] p4 says:
#+begin_quote
For any two values ~sch1~ and ~sch2~ of some scheduler type ~Sch~, ~sch1 == sch2~ shall
return ~true~ only if both ~sch1~ and ~sch2~ share the same associated execution resource.
#+end_quote

However, I don't think this requirement is sufficient for schedulers to be considered
equal as it is possible to have two different schedulers that share the same associated
execution resource but that have different behaviour.

For example, two schedulers of the same type but where one schedules items with high
priority and others with low priority.

Ideally we want two schedulers to be equal if and only if they can be used interchangeably
such that using either scheduler to schedule work has the same behaviour.

Note that some use cases may also want to compare two schedulers as to whether or not
they share the same associated execution resource, independently of their scheduling
behaviour, however this could be added as a separate operator later.
e.g. ~std::execution::same_resource(sch1, sch2)~

It's also not clear how this definition applies to schedulers such as an ~inline_scheduler~
(added in P3552) in which has no specific associated execution resource but instances
nevertheless have the same scheduling behaviour.

I suggest this paragraph is changed to refer to the schedulers having the same
scheduling behaviour rather than having the same associated execution resource.
Or at least add a note here indicating that equality operator may return false
if the behaviour is different, even if the schedulers share an associated execution
resource.

** DELEGATED Remove note regarding waiting for completion of scheduled operations
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 09:50:08+0930]
:END:
:LOGBOOK:
- State "DELEGATED"  from "DELEGATED"  [2025-08-28 Thu 13:53] \\
  Tracked as https://cplusplus.github.io/LWG/issue4328
- State "WAITING"    from              [2025-08-25 Mon 09:50] \\
  Sent to lwgchair
:END:

The note at the end of [[https://eel.is/c++draft/exec#sched-note-1][exec.sched]] says:
#+begin_quote
[Note: The ability to wait for completion of submitted function objects can be
provided by the associated execution resource of the scheduler - end note]
#+end_quote

The suggestion that the execution resource should be used to join/wait on
scheduled work is problematic in situations that may involve more than one
execution context, as an execution resource having an empty queue of scheduled
work does not necessarily imply that tasks currently running on another
execution context will not later schedule additional work on this execution
resource.

With the introduction of ~counting_scope~ with P3149 we now have a better recommended
way of waiting for tasks that use a resource (including execution resources)
to complete.

The note as it stands represents bad guidance and should either be removed or
updated to refer to ~counting_scope~ and ~simple_counting_scope~ ([exec.counting.scopes]).

** WAITING Consider mandating that ~set_value()~, ~set_error()~ and ~set_stopped()~ calls have a return-type of ~void~ :design:
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 10:07:28+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 10:07] \\
  Sent to lwgchair
:END:

The expression ~set_value(rcvr, vs...)~ is defined as expression-equivalent to ~MANDATE-NOTHROW(rcvr.set_value(vs...))~.

As we do not also mandate that the result-type of this expression must be ~void~, it is presumably
allowed to return any other type and the ~set_value_t~ CPO is required to return any such value
returned by the member-function in order to preserve the "expression-equivalent" property.

I think we should mandate that the return-type of this expression is ~void~ to both avoid
misuse of the return-value here but also to preserve design space for potential future
extensions that might want to ascribe meaning to non-void return-values.

Similarly for the ~set_error~ and ~set_stopped~ CPOs.

*Suggestion:*
Add a "Mandates: If the expression ~set_value(rcvr, vs...)~ is well-formed, its type shall be ~void~." to [exec.set.value].
And similarly for ~set_error~ and ~set_stopped~.

** WAITING Uses of MANDATE-NOTHROW should not include sub-expressions
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 10:58:01+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 10:58] \\
  Sent to lwgchair
:END:

There are a number of CPOs defined in [exec] which have behaviour specified in terms
of being expression-equivalent to a MANDATE-NOTHROW expression.

The intent of this is that we want to make sure that the call that the CPO
dispatches to is marked noexcept.

However, the way that these CPOs are currently specified in terms of sub-expressions
means that we are currently requiring all of the expressions passed as arguments to
the CPO are also noexcept. Outside of defining these CPOs as preprocessor macros, this
is unimplementable - and also undesirable behaviour.

For example, [exec.set.value] defines ~set_value(rcvr, vs...)~ to be equivalent to
~MANDATE-NOTHROW(rcvr.set_value(vs...))~ for sub-expressions ~rcvr~ and pack of
sub-expressions ~vs~.

In [exec.general] p5 we define ~MANDATE-NOTHROW(expr)~ as expression-equivalent to ~expr~
but mandate that ~noexcept(expr)~ is ~true~.

So in the above definition of ~set_value(rcvr, vs...)~ we are actually requiring that
the expression ~noexcept(rcvr.set_value(vs...))~ is true. This is only true if all of
the sub-expressions are ~noexcept~; ~rcvr~, ~vs...~ and the member-function call to ~rcvr.set_value()~
including any implicit conversions of arguments.

This means that if, for example, one of the sub-expressions in the pack ~vs~ was
a call to some potentially-throwing function then the overall ~set_value~ expression
would be ill-formed.

For example:
#+begin_src c++
  struct my_receiver {
    void set_value(int x) noexcept;
  };

  int get_value() noexcept(false);

  my_receiver r;
  std::execution::set_value(r, get_value()); // fails MANDATE-NOTHROW mandates
#+end_src

Instead, we need to redefine these CPOs as being expression-equivalent to something
that does not require that the argument expressions to the CPO themselves are
noexcept - only what will be in the body of the CPO function.

This can be done with an immediately-invoked lambda.

For example, we could change [exec.set.value] to define ~set_value(rcvr, vs...)~
as expression-equivalent to:
#+begin_src c++
  [](auto& rcvr2, auto&&... vs2) noexcept -> decltype(auto) requires requires { rcvr2.set_value(vs2...); } {
    return MANDATE-NOTHROW(rcvr2.set_value(vs2...));
  }(rcvr, vs...);
#+end_src

The following sections all contain problematic uses of MANDATE-NOTHROW:
- [exec.get.allocator]
- [exec.get.stop.token]
- [exec.get.env]
- [exec.get.domain]
- [exec.get.scheduler]
- [exec.get.delegation.scheduler]
- [exec.get.fwd.progress]
- [exec.get.compl.sched]
- [exec.get.await.adapt]
- [exec.set.value]
- [exec.set.error]
- [exec.set.stopped]
- [exec.opstate.start]


** WAITING Reconsider ~weakly_parallel~ as the default ~forward_progress_guarantee~ :design:
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 11:14:48+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 11:14] \\
  Sent to lwgchair
:END:

The ~get_forward_progress_guarantee~ CPO is intended to allow querying a scheduler
as for what sort of forward-progress guarantee it provides.

Algorithms may use this to determine whether it is safe to execute certain
operations on a given scheduler.

If a scheduler does not customize this query, the query will fall back to returning
a forward-progress guarantee of ~weakly_parallel~.

I think we should reconsider what this default should be returning and suggest it
should instead return ~parallel~ by default, as this will be by far the most common
kind of scheduler - i.e. a scheduler that executes on ~std::thread~-like execution
agents and that maintains a queue of scheduled tasks.

I expect it to be common that authors of schedulers may forget to customize the
~get_forward_progress_guarantee_t~ query and just leave it at the default, which
will likely leave their scheduler reporting a weaker guarantee than it actually
provides and thus not being usable within generic algorithms that require at least
~parallel~ forward progress.

For example, the ~run_loop~ execution context defined in [exec.run.loop] does not
define its scheduler to customize the ~get_forward_progress_guarantee_t~.
This means it will report the default value of ~weakly_parallel~.

However, the scheduled operations will run on the thread that calls ~run_loop::run()~
and thus will inherit its forward-progress guarantees, and as this function might
block and is therefore unsafe to invoke it from a thread with ~weakly_parallel~
forward progress guarantes (which should probably be explicitly specified as
having undefined-behaviour) we can safely assume that ~run_loop~'s scheduler can
provide ~parallel~ forward-progress guarantee (assuming some thread eventually calls
~run()~).

It's not clear whether the current ~run_loop~ specification defaulting to it's scheduler
having ~weakly_parallel~ forward progress guarantee is intentional or unintentional here.

Schedulers that provide either ~weakly_parallel~ or ~concurrent~ forward progress
guarantees require implementations to be much more aware of the fact that these
are the guarantees they are providing and thus could be more expected to customize
the  ~get_forward_progress_guarantee~ query to return the respective values.

** WAITING ~run_loop~'s scheduler should probably report a ~get_forward_progress_guarantee()~ of ~parallel~ :design:
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 11:26:13+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 11:26] \\
  Sent to lwgchair
:END:

Currently ~run_loop~ specification does not define that its scheduler has a customisation of
the ~get_forward_progress_guarantee~ query. This means that it will report a forward-progress
guarantee by default of ~weakly_parallel~.

However, as all tasks scheduled to a ~run_loop~ will be run on the thread that calls
~run_loop::run()~ and because ~run_loop::run()~ may be required to block until scheduled
items are submitted, it would not be safe to call ~run_loop::run()~ from a thread
with a weakly-parallel forward-progress guarantee. Thus we should be able to assume
that ~run_loop~ itself will provide a forward-progress guarantee of ~parallel~.

** It is not possible to constrain a scheduler to require that it statically provides a forward-progress guarantee :design:

It is not possible to evaluate whether the result of the ~get_forward_progress_guarantee()~
query on a given scheduler is going to return a given value as this query is required
to return type ~forward_progress_guarantee~, preventing it from returning e.g.
~constant_wrapper<forward_progress_guarantee::parallel>~.

Also, implementations of the ~queryable~ concept in [exec] do not define static ~query~
functions, so we cannot generally test whether all instances of a queryable object
will return a given value by testing whether ~queryable_type::query(some_query_t{})~ is valid.

This seems to be a fundamental limitation of the ~queryable~ concept and of the environment
object wrappers that [exec] provides.

See https://godbolt.org/z/rcP1Y3jY9 for an example of how we might be able to define
wrappers to forward staticness of queries.

** WAITING Unnecessary constraint in ~receiver~ and ~sender~ concepts
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 14:05:53+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 14:05] \\
  Sent to lwgchair
:END:

In [exec.recv.concepts] ~concept receiver~ is constraining on whether ~get_env(rcvr)~ returns a type that satisfies ~queryable~,
but the ~get_env~ CPO already mandates that the return-value satisfies ~queryable~, so this check seems redundant.

Suggested change:
#+begin_src diff
   template<class Rcvr>
     concept receiver =
       derived_from<typename remove_cvref_t<Rcvr>::receiver_concept, receiver_t> &&
       requires(const remove_cvref_t<Rcvr>& rcvr) {
  -      { get_env(rcvr) } -> queryable;
  +      get_env(rcvr);
       } &&
       move_constructible<remove_cvref_t<Rcvr>> &&       // rvalues are movable, and
       constructible_from<remove_cvref_t<Rcvr>, Rcvr>;   // lvalues are copyable
#+end_src

However, as the ~get_env()~ CPO is defined for all objects (it will fall back to returning
~env<>~ if ~AS-CONST(obj).get_env()~ is not valid), testing whether ~get_env(rcvr)~
expression is valid is not actually going to constrain types in any way.
So we could consider just removing the entire ~requires~ expression that checks
for ~get_env(rcvr)~.

Similar changes should be applied to the ~sender~ concept definition in [exec.snd.concepts].

** CANCELLED Unnecessary constraint in ~operation_state~ concept
CLOSED: [2025-08-25 Mon 14:06]
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 14:06:42+0930]
:END:
:LOGBOOK:
- State "CANCELLED"  from              [2025-08-25 Mon 14:06] \\
  This has already been addressed in current wording.
:END:

The ~operation_state~ concept is defined in [exec.opstate.general] as follows:
#+begin_src c++
  template<class O>
    concept operation_state =
      derived_from<typename O::operation_state_concept, operation_state_t> &&
      is_object_v<O> &&
      requires (O& o) {
        { start(o) } noexcept;
      };
#+end_src

The ~requires~ expression that checks that the ~start(op)~ expression is valid also
checks that this expression is ~noexcept~. However, the ~start~ CPO already mandates
that the expression is ~noexcept~ and so the additional ~noexcept~ check in the
~operation_state~ concept seems unnecessary.

Can we simplify the ~operation_state~ concept to remove the ~noexcept~ check?

** TODO Specification of queries should not require passing references to global CPO objects
:PROPERTIES:
:CREATED:  [2025-08-28 Thu 13:57:03+0930]
:END:


The specification of most queries in [exec] defines them to be "expression-equivalent to"
calling the ~query()~ member-function, passing the global CPO object as the argument.

For example: The ~get_allocator~ query is defined as:
#+begin_src c++
  namespace std::execution {
  struct get_allocator_t { unspecified };
  inline constexpr get_allocator_t get_allocator{};
#+end_src
such that ~get_allocator(env)~ is expression-equivalent to ~MANDATE-NOTHROW(AS-CONST(env).query(get_allocator))~

However, when such a formulation is combined with the definition of customization-point object
in [customization.point.object] we can end up with implementations that need to unnecessarily
pass references to the global object.

The wording in [customization.point.object] requires that calling ~operator()~ on any instance of the
customization-point object type, whether const-qualfified or not and whether on an lvalue or rvalue,
has equivalent effects to calling the original customization point object.

Since the effects of calling ~get_allocator(env)~ is such that it passes the object ~get_allocator~ as
an argument to the ~env.query()~ call, then all calls to function objects of type ~get_allocator_t~
must also be expression-equivalent to ~env.query(get_allocator)~. i.e they must pass in a reference
to the global object as this would be detectable behaviour inside the ~query()~ member function.

For example, I could write a ~query()~ function that looked like:
#+begin_src c++
  struct my_env {
    std::allocator<void> query(const std::execution::get_allocator_t& q) const noexcept {
      assert(&q == &std::execution::get_allocator);
      return std::allocator<void>{};
    }
  };
#+end_src
and would be presumably within expected behaviour for the assertion to pass when evaluating
#+begin_src c++
  my_env env;
  auto query = std::execution::get_allocator;
  auto alloc = query(env);
#+end_src

In order to satisfy this behaviour, implementations would need to define ~get_allocator_t~
something like the following:
#+begin_src c++
  namespace std::execution {
    template<class Queryable, class Query>
    concept __has_query = requires(const Queryable& env, const Query& query) {
      env.query(query);
    };

    template<class Queryable, class Query>
    using __query_result_t = decltype(std::declval<const Queryable&>().query(std::declval<const Query&>()));

    struct get_allocator_t {
      template<__has_query<get_allocator_t> Queryable>
      static constexpr auto operator()(const Queryable& q) noexcept
        -> __query_result_t<Queryable, get_allocator_t>;
    };
    inline constexpr get_allocator_t get_allocator{};
    // Must define the operator() overload after 'get_allocator' object definition
    // so that it can pass a reference to 'get_allocator'.
    template<__has_query<get_allocator_t> Queryable>
    constexpr auto get_allocator_t::operator()(const Queryable& q) noexcept
      -> __query_result_t<Queryable, get_allocator_t> {
      return q.query(get_allocator);
    }
  }
#+end_src

This can result in potential aliasing of the CPO object, forcing an instance to live in the binary.

If queries were instead defined to pass a prvalue CPO as an argument to the ~query()~ member
function then implementations could avoid unnecessarily aliasing the global CPO object and
also allow simplification of the implementation, allowing the ~operator()~ to be defined
inline.

For example, simply changing ~get_allocator(env)~ to be expression-equivalent to ~MANDATE-NOTHROW(AS-CONST(env).query(auto(get_allocator)))~
would now permit the following implementation:
#+begin_src c++
  namespace std::execution {
    template<class Queryable, class Query>
    concept __has_query = requires(const Queryable& env) {
      env.query(Query{});
    };

    template<class Queryable, class Query>
    using __query_result_t = decltype(std::declval<const Queryable&>().query(std::declval<Query>()));

    struct get_allocator_t {
      template<__has_query<get_allocator_t> Queryable>
      static constexpr auto operator()(const Queryable& q) noexcept
        -> __query_result_t<Queryable, get_allocator_t> {
        return q.query(get_allocator_t{});
      }
    };
    inline constexpr get_allocator_t get_allocator{};
  }
#+end_src

The suggested change is to replace occurrences of a customization-point object ~cpo~ with ~auto(cpo)~ in
the "expression-equvalent to" expression for all customization-point objects defined in [exec].

** ~FWD-ENV(env)~ is unclear about ownership/lifetime of ~env~ object   :clarify:

The specification for ~FWD-ENV(env)~ says that for queryable object ~env~, ~FWD-ENV(env).query(q, as...)~
is expression-equivalent to ~env.query(q, as...)~.

My interpretation of this is that this must end up calling ~env.query~ on the original ~env~ object,
not on a copy of ~env~, and thus the resulting type of ~FWD-ENV(env)~ necessarily needs to store
~env~ itself (e.g. by in-place constructing it as a member of the ~FWD-ENV(env)~ object) or by
storing a reference to ~env~)

However, many uses of ~FWD-ENV~ use ~FWD-ENV(get_env(x))~ which might end up passing a temporary
object to ~FWD-ENV~ and so holding a reference to ~env~ does not seem like a suitable implementation
strategy.

The ~queryable~ concept does not require that the type is copyable/movable, so we cannot
necessarily guarantee that we could move/copy the object returned from ~get_env()~ into another
object anyway - it would need to be in-place constructed within the object returned by ~FWD-ENV~.

** Consider making use of ~type_order~ facilities to require canonical ~completion_signatures~ :improvement:design:

With the introduction of compile-time type-ordering, we should consider whether to mandate taking
advantage of the ability to sort types to require specializations of the ~completion_signatures~
class template to have the completion-signatures listed in a canonical order.

Forcing a canonical order could help reduce the number of template instantiations in cases where
two senders compute equivalent sets of completion signatures but where the completion signatures
are listed in a different order.

** WAITING Should ~transform_sender~, ~transform_env~ and ~apply_sender~ functions be customization points? :design:
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 19:35:13+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 19:35] \\
  Sent to lwgchair.
:END:

The ~transform_sender~ ([exec.snd.transform]), ~transform_env~ ([exec.snd.transform.env]) and ~apply_sender~ ([exec.snd.apply])
are curently all defined as regular functions, whereas other customisation points are all defined as CPOs.

Why do we define these as normal functions and the others as CPOs?
Is the distinction here intentional?

The difference between declarations is observable.
- Customization point objects would not be found by ADL, whereas the current declarations
  can be expected to be found by ADL.
  e.g. if passing ~std::execution::default_domain~ as the first argument, as specified I would expect to be
  able to make an unqualified call to ~transform_sender(std::execution::default_domain(), sndr)~
  and this would find the ~std::execution::transform_sender~ function definition.
- Customization point objects can be passed around unqualified as function-objects,
  whereas when declared as a function-template you cannot pass around the function-name
  as an object.

Note that the stdexec implementation currently has ~transform_sender~ defined as a CPO, which would be non-compliant
according to the current specification.

** CANCELLED Clarify the intent of ~static_cast<Env>()~ in ~default_domain::transform_env()~ :clarify:
CLOSED: [2025-08-25 Mon 20:28]
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 20:28:16+0930]
:END:
:LOGBOOK:
- State "CANCELLED"  from              [2025-08-25 Mon 20:28] \\
  The static_cast expression is no longer there in the latest version of the wording.
:END:

In [exec.domain.default] p5, the ~default_domain::transform_env~ is specified to have
a fallback return expression of ~static_cast<Env>(std::forward<Env>(env))~.

However, it's not clear what the purpose of the ~static_cast~ is here.
- If this function is passed an lvalue, then ~Env~ is an lvalue-reference and the static_cast does not
  do anything more than ~std::forward<Env>(env)~ does.
- If this function is passed an rvalue, then the ~static_cast~ will construct a new prvalue.
  - Why is this the desired behaviour?
  - Why is a similar cast not applied to the ~transform_sender~ implementation?

It is also not clear that introducing a move-construction here is valid:
- There is no requirement on the ~queryable~ concept that says that environment objects
  must provide a move or copy constructor, so forcing move-construction of a new
  environment object to be returned from ~transform_env()~ without constraining or
  mandating that the type ~Env~ is move-constructible seems incorrect.

** WAITING Unnecessary copy of sender in ~get-domain-late~ specification
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 18:53:14+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 18:53] \\
  Sent to lwgchair.
:END:

In [exec.snd.expos] p14.1 in the specification of ~get-domain-late~ it uses a lambda
expression with the structured binding:
  #+begin_src c++
    [] {
      auto [_, sch, _] = sndr;
      return query-with-default(get_domain, sch, default_domain());
    }();
  #+end_src

However this will try to perform a copy of the sender which will be ill-formed if the
sender is not copyable (Note ~sndr~ is a const-ref). The structured binding should instead
start with ~auto& [_, sch, _] =~.

** WAITING Inconsistent support for ~std::execution~ queries taking additional arguments
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 19:20:00+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 19:20] \\
  Sent to lwgchair.
:END:

The facilities in [exec] that define queryable types that provide implementations
of ~query()~ member-functions are inconsistent in their support for taking optional
additional arguments to the ~query()~ call.

In [exec.queryable.general] p1, which defines the general concepts of
/queryable object/, /query object/ and /query/, it talks about queries having a
possibly empty set of additional arguments.

The following definitions of ~queryable~ types defined in [exec] support taking
additional arguments to ~env.query(tag, as...)~:
- In [exec.snd.expos] p2 ~FWD-ENV(env).query(q, as...)~ is defined to be equivalent to ~env.query(q, as...)~
  if the query object ~q~ is a ~forwarding_query~.
  This is used as the environment returned by ~basic-receiver::get_env()~.
- In [exec.snd.expos] p4 ~JOIN-ENV(env1, env2)~ also defines that the environment
  object ~env3~ is returned from ~JOIN-ENV~ such that ~env3.query(q, as...)~ is
  equivalent to ~env1.query(q, as...)~ if that is valid, otherwise ~env2.query(q, as...)~.
- In [exec.as.awaitable] p4.4 the ~awaitable-receiver~ type is defined to return an
  environment ~env~ from its ~get_env()~ member-function such that ~env.query(tag, as...)~
  is equivalent to ~tag(get_env(as_const(crcvr.continuation.promise())), as...)~.
  (Which is itself a separate bug - it should be calling ~.query(tag, as...)~ member-function).
  
The following definitions of ~queryable~ types defined in [exec] *do not* support taking
additional arguments to ~env.query(tag)~.
- In [exec.snd.expos] p43.2 the ~impls-for<write-env-t>::get-env~ function is defined
  to return a ~queryable~ object ~e~ such that ~e.query(q)~ is equivalent to ~state.query(q)~
  if that is valid, otherwise ~get_env(rcvr).query(q)~.
- The ~read_env~ algorithm defined in [exec.read.env] only supports queries that do
  not take any additional arguments, although there doesn't appear to be anything
  stopping passing a stateless lambda as the query object (as long as it satisfies
  requirements of being a customization point object).
- In [exec.let] p6.2 it defines ~receiver2::get_env()~ to return a ~queryable~ object ~e~
  such that ~e.query(q)~ is equivalent to ~env.query(q)~ if that is valid, otherwise
  ~get_env(rcvr).query(q)~.
- In [exec.when.all] p6 it defines ~impls-for<when_all_t>::get-env~ to return a
  ~queryable~ object ~e~ such that ~e.query(get_stop_token)~ is equivalent to
  ~state.stop-src.get_token()~ and ~e.query(q)~ for some ~q~ that is not ~get_stop_token~
  to be ~get_env(rcvr).query(q)~.
- The class template ~env<Envs...>~ defined in [exec.env] is defined to have a
  ~query(QueryTag q)~ member-function that forwards the call to the first child
  environment env_{i} such that env_{i}.query(q) is valid.

We should be consistent with either uniformly supporting queries with additional
arguments or we should remove support for queries with additional arguments
altogether.

** WAITING The ~AS-EXCEPT-PTR(err)~ is potentially throwing when ~err~ has type ~error_code~
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 19:28:50+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 19:28] \\
  Sent to lwgchair.
:END:

The ~AS-EXCEPT-PTR(err)~ exposition-only helper defined in [exec.general] p8 is not
necessarily ~noexcept~ yet is used in a context (~sync-wait-receiver::set_error()~ in [exec.sync.wait])
where emitting an exception would result in termination.

In particular, the paragraph that says it's equivalent to ~make_exception_ptr(system_error(err))~ when ~err~ is an ~error_code~
might throw from the ~system_error~ constructor as this constructor is not marked ~noexcept~.

I suggest this case be changed to catch any exception thrown by the ~system_error~ constructor
and return ~current_exception()~ in that case.

For example, change the line in p8.2 from
#+begin_quote
- Otherwise, ~make_exception_ptr(system_error(err))~ if ~decay_t<Err>~ denotes the type ~error_code~.
#+end_quote
to
#+begin_quote
- Otherwise, ~[](std::error_code ec) noexcept { try { return make_exception_ptr(system_error(ec)); } catch (...) { return current_exception(); } }(err)~ if ~decay_t<Err>~ denotes the type ~error_code~.
#+end_quote

** WAITING Wording for ~std::execution::connect~ needs to specify that ~rcvr~ is only to be evaluated once
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 19:51:35+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 19:51] \\
  Sent to lwgchair.
:END:

In [exec.connect] p6 it states that for expressions ~sndr~ and ~rcvr~, the expression ~connect(sndr, rcvr)~
is expression equivalent to either:
- ~new_sndr.connect(rcvr)~, or
- ~connect-awaitable(new_sndr, rcvr)~

Where ~new_sndr~ is defined as the expression
~transform_sender(decltype(get-domain-late(sndr, get_env(rcvr))){}, sndr, get_env(rcvr))~.

However, if you substitute the ~new_sndr~ expression into the ~new_sndr.connect(rcvr)~ expression
you can see that in the resulting expression, the subexpression ~rcvr~ appears multiple times
and yet the wording does not state that "except where ~rcvr~ expression is only evaluated once".

I suggest that we modify [exec.connect] p6 to the following:
#+begin_quote
The expression ~connect(sndr, rcvr)~ is expression-equivalent to:
- ~new_sndr.connect(rcvr)~ if that expression is well-formed.
  /Mandates:/ The type of the expression above satisfies ~operation_state~.
- Otherwise, ~connect-awaitable(new_sndr, rcvr)~.
<ins>except that ~rcvr~ is only evaluated once.</ins>
/Mandates:/ ~sender<Sndr> && receiver<Rcvr>~ is ~true~.
#+end_quote

** WAITING Wording for ~execution::on()~ incorrectly assumes that ~start()~ is called on execution context associated with ~get_scheduler(get_env(rcvr))~
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 20:20:36+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 20:20] \\
  Sent to lwgchair.
:END:

The specification of ~execution::on~ in [exec.on], seems to assume that the scheduler obtained
from the receiver connected to it by ~get_scheduler(get_env(rcvr))~ is the scheduler that the
operation will be started on by calling ~start(op)~.

p1.1 states:
#+begin_quote
- ~on(sch, sndr)~, which starts a sender ~sndr~ on an execution agent belonging to a scheduler
  ~sch~'s associated execution resource and that, upon ~sndr~'s completion,
  *transfers execution back to the execution resource on which the sender was started*.
#+end_quote

There is currently no guarantee or requirement that callers of ~start(op)~ will make this call
on an execution agent belonging to the execution resource associated with the current
scheduler.

I suggest we amend this sentence to something like the following:
#+begin_quote
- ~on(sch, sndr)~, which starts a sender ~sndr~ on an execution agent belonging to a scheduler
  ~sch~'s associated execution resource and that, upon ~sndr~'s completion,
  *transfers execution back to the execution resource associated with the original
  current scheduler*.
#+end_quote

The /current scheduler/ is defined in p10.1:
#+begin_quote
- remember the *current scheduler*, ~get_scheduler(get_env(rcvr))~
#+end_quote

Alternatively, it may be clearer to just talk about the scheduler ~get_scheduler(get_env(rcvr))~
where ~on(sch, sndr)~ is connected to ~rcvr~.

** WAITING ~execution::transform_sender~ can return dangling references
:PROPERTIES:
:CREATED:  [2025-08-25 Mon 21:11:27+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-25 Mon 21:11] \\
  Sent to lwgchair.
:END:

The ~execution::transform_sender~ can return dangling references if a custom domain's ~transform_sender~ function
returns a prvalue.

Consider the following code:
  #+begin_src c++
  struct simple_sender { /* implementation omitted */ };
  struct other_sender { /* implementation omitted */ };
  struct my_domain {
    static constexpr other_sender transform_sender(simple_sender&& s) noexcept;
  };

  void example() {
    auto sndr = std::execution::transform_sender(my_domain{}, simple_sender{});
  }
  #+end_src

In this example, the implementation of ~std::execution::transform_sender~ is specified to have
a body for the instantiation of this call equivalent to overload #1 below:
  #+begin_src c++
  namespace std::execution {
    other_sender&& transform_sender(my_domain dom, simple_sender&& s) noexcept { // #1
      // This recursive call calls onto overload #2 below.
      return std::execution::transform_sender(dom,
                                              dom.transform_sender(std::forward<simple_sender>(s)));
    }

    other_sender&& transform_sender(my_domain dom, other_sender&& s) noexcept { // #2
      // my_domain cannot transform other_sender, so we fall back to transforming
      // using the default domain. Calls onto overload of default_domain::transform_sender() below.
      return default_domain().transform_sender(std::forward<other_sender>(s));
    }

    // As per [exec.domain.default] falls back to 'return std::forward<Sndr>(s);' if
    // tag_of_t<Sndr> is not well-formed.
    other_sender&& default_domain::transform_sender(other_sender&& s) noexcept {
      return std::forward<other_sender>(s);
    }
  }
  #+end_src

The problem here is that the call to ~dom.transform_sender()~ is returning a prvalue temporary which
is then being passed into overload #2 of ~execution::transform_sender()~ which is then returning
an rvalue reference to this temporary which it is then returning from overload #1.

However, the lifetime of this temporary ends immediately upon returning from ~execution::transform_sender()~
and thus the caller in ~example()~ above is left initializing its local variable ~sndr~ from a dangling
reference.

The definition of ~execution::transform_sender~ needs to be fixed to avoid this case of returning a
reference to a temporary object.

A simple fix here would be to use an ~auto~ return type rather than a ~decltype(auto)~ return type to
force ~execution::transform_sender~ to always return a newly constructed prvalue sender.
The downside with this, however, is that in the reasonably common case of the call to ~transform_sender()~
resulting in no transformation and just returning the original object such a design would incur
an additional move operation of the sender, which could be expensive for large sender expressions.

Another alternative could be to force the result of a nested call to ~execution::transform_sender~
to always return a prvalue:
i.e. change the ~final-sndr~ expression for the case where ~transformed-sndr~ and ~sndr~ have different
types to be ~auto(transform_sender(dom, transformed-sndr, env...))~.

Suggested wording change is to modify [exec.snd.transform] p1 as follows:
#+begin_quote
Let ~transformed-sndr~ be the expression:
- ~dom.transform_sender(std::forward<Sndr>(sndr), env...)~
if that expression is well-formed;  otherwise,
- ~default_domain().transform_sender(std::forward<Sndr>(sndr), env...)~

Let ~final-sndr~ be the expression ~transformed-sndr~ if ~transformed-sndr~ and ~sndr~
have the same type ignoring cv-qualifiers; otherwise it is the expression
<ins> ~auto(~ </ins> ~transform_sender(dom, transformed-sndr, env...)~ <ins> ~)~ </ins>.
#+end_quote

** WAITING connect-awaitable() should mandata rcvr can receive all completion-signals rather than using constraints
:PROPERTIES:
:CREATED:  [2025-08-27 Wed 11:46:52+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-27 Wed 11:46] \\
  Sent to lwgchair
:END:

- Wording for ~connect()~ defines fallback to be expression-equivalent to ~connect-awaitable(new_sndr, rcvr)~.
  However, ~connect-awaitable~ has a ~requires~ clause that checks that ~rcvr~ is able to receive all of the
  completion signals.
  - Should be be "mandating" that ~rcvr~ is able to receive all of the signals rather than using "constraints"
    here?
  - We don't seem to use constraints that check the receiver is able to accept all of the signals when
    calling member ~.connect()~ function so I think we should be consistent with the ~connect-awaitable~
    fallback here.

** WAITING ~connect()~ should use ~get_allocator(get_env(rcvr))~ to allocate the coroutine-state for ~connect-awaitable~ coroutine
:PROPERTIES:
:CREATED:  [2025-08-27 Wed 12:19:26+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-27 Wed 12:19] \\
  Sent to lwgchair
:END:

The wording for ~connect()~ ([exec.connect]) handles passing awaitable types as the sender argument by
calling the connect-awaitable() coroutine and having it execute a co_await expression.

The connect-awaitable() coroutine will typically need to dynamically allocate storage for the
coroutine state and, as specified, this currently just always uses the global default allocator.
This is because the connect-awaitable-promise type does not define any member operator new/delete overloads.

It seems desirable for this facility to use the allocator obtained from the receiver, by calling
~get_allocator(get_env(rcvr))~, in order to allocate storage for the coroutine-state instead of
always using global operator new. This would give the user at least some level of control over
how this allocation is performed.

Proposed resolution:

Insert the following paragraph after [exec.connect] p5:

#+begin_quote
Any dynamically allocated storage required for the coroutine state allocated by an
invocation of the form connect-awaitable(sndr, rcvr) is allocated using the allocator
obtained from get_allocator(get_env(rcvr)).
#+end_quote


This should cover the design intent, although we may want to spell this out more explicitly in
terms of the exact semantics in a similar way to [coro.generator] p17, which lists overloads
of operator new() and describes the rebound allocator type which allocates storage in chunks of size ~__STDCPP_DEFAULT_NEW_ALIGNMENT__~.

** WAITING Use is_void_v instead of same_as<void> in connect-awaitable

- Wording for ~connect-awaitable~ helper in [exec.connect] uses ~same_as<V, void>~ to check for void return-type
  of the await expression, but we should be using ~is_void_v<V>~ here to also handle /cv/ ~void~.

** WAITING [exec.as.awaitable] is using "Preconditions:" when it should probably be described in the constraint
:PROPERTIES:
:CREATED:  [2025-08-27 Wed 14:16:10+0930]
:END:
:LOGBOOK:
- State "WAITING"    from "WAITING"    [2025-08-27 Wed 14:16] \\
  Sent to lwgchair.
:END:

- Wording for [exec.as.awaitable] [[https://eel.is/c++draft/exec#as.awaitable-7.2][p7.2]] uses "Preconditions:" for things that look like they should be "constraints".

- Wording for [exec.as.awaitable] [[https://eel.is/c++draft/exec#as.awaitable-7.2][p7.2]] contains the phrase:
  #+begin_quote
... and the expression ~co_await expr~ in a coroutine with promise type ~U~ is expression-equivalent
to the same expression in a coroutine with promise type ~Promise~.
  #+end_quote
  It is not clear how this can be "expression-equivalent to" as the types involved are not the
  same: a different ~coroutine_handle<Promise>~ type is passed to ~await_suspend()~ and ~Promise~
  potentially calls ~await_transform~.
  Perhaps we should use some phrasing along the lines of "effects equivalent to" instead of
  "expression-equivalent to"?

  Alternatively, perhaps there is a different way to describe this by checking whether:
  ~GET-AWAITER(expr, p)~ satisfies ~is-awaiter<Promise>~ where ~p~ is an lvalue-reference to
  an unspecified promise type that does not have an ~await_transform~ member.
  This should effectively just apply the ~operator co_await()~ if such a call is well-formed
  and then check that the result is a valid awaiter in a coroutine with promise-type ~Promise~.
  This would avoid the need to say anything about whether a ~co_await~ expression in some
  coroutine with an unspecified promise is equivalent to a ~co_await~ expression in a
  coroutine with the promise type of ~Promise~.

** WAITING as_awaitable(expr,p) does not define semantics of call if p is not an lvalue

- Wording for ~as_awaitable~ in [exec.as.awaitable] defines what ~as_awaitable(expr, p)~ is
  equivalent to if ~p~ is an lvalue, but doesn't say what happens if ~p~ is not an lvalue.
  I think we need to say something like "If ~p~ is not an lvalue then ~as_awaitable(expr, p)~
  is ill-formed."

** WAITING awaitable-sender concept should qualify use of awaitable-receiver type
- Wording for [exec.as.awaitable] concept ~awaitable-sender~ refers to unqualified ~awaitable-receiver~
  type. This type should be qualified as ~sender-awaitable<Sndr, Promise>::awaitable-receiver~.

** WAITING awaitable-receiver::set_value should use mandates instead of constraints
:PROPERTIES:
:CREATED:  [2025-08-28 Thu 09:24:08+0930]
:END:
:LOGBOOK:
- State "WAITING"    from "WAITING"    [2025-08-28 Thu 09:24] \\
  Sent to lwgchair.
:END:

- In [exec.as.awaitable] the ~awaitable-receiver::set_value~ member-function is defined as having
  a constraint that the result-type is constructible from the values. Should we be using mandates
  here instead? There shouldn't be any need to change behaviour based on whether or not the
  receiver's completion methods are well-formed or not.

** WAITING Inconsistent usage of constexpr for inplace_stop_token and inplace_stop_source
:PROPERTIES:
:CREATED:  [2025-08-28 Thu 10:27:01+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-28 Thu 10:27] \\
  Sent to lwgchair.
:END:
- The ~inplace_stop_source::get_token()~ member-function is declared constexpr, but there are
  no constexpr member-functions declared on ~inplace_stop_token~. Should the member-functions
  of ~inplace_stop_token~ also be declared ~constexpr~ (e.g. ~operator==~, ~stop_possible()~ and
  ~stop_requested()~).

** WAITING transform_sender comparing types ignoring cv-qualifiers doesn't take into account differences in value-category
:PROPERTIES:
:CREATED:  [2025-08-28 Thu 10:51:28+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-28 Thu 10:51] \\
  Sent to lwgchair
:END:
- Definition of ~transform_sender~ says to compare types of ~sndr~ and ~transformed-sndr~ ignoring cv-qualifiers
  but this doesn't take into account that ~sndr~ might be ~T&&~ and ~transformed-sndr~ may be ~T~ (e.g. if the transform
  returned a prvalue).

  My interpretation was that I should apply the test ~same_as<remove_cv_t<decltype(sndr)>, remove_cv_t<decltype(transformed-sndr)>>~.
  However, ~remove_cv_t~ does not remove qualifiers from a type ~Sndr&&~ (which is the type of ~sndr~).
  Is the intention that this should instead use ~same_as<remove_cvref_t<decltype(sndr)>, remove_cvref_t<decltype(transformed-sndr)>>~?
  If so, can we use some more precise wording than "ignoring cv-qualifiers" to describe this?

** WAITING execution::as_awaitable() forwards an environment that implements too many queries
:PROPERTIES:
:CREATED:  [2025-08-28 Thu 11:02:17+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-28 Thu 11:02] \\
  Sent to lwgchair.
:END:
- In [exec.as.awaitable] [[https://eel.is/c++draft/exec#as.awaitable-4.4][p4.4]] we define ~get_env(crcvr).query(tag, as...)~ as expression equivalent
  to ~tag(get_env(as_const(crcvr.continuation.promise())), as...)~.
  However, this can result in the returned environment satisfying some queries by returning default
  values when the original environment did not provide implementations for those queries. This is
  inconsistent with the definitions of ~env<Envs...>::query()~, ~FWD-ENV~ and other environment wrappers
  for which an ~env.query(q)~ is only valid if the underlying environment's ~env.inner.query(q)~ expression is valid.

** WAITING Incorrect use of is-awaitable concept in definition of has-as-awaitable
:PROPERTIES:
:CREATED:  [2025-08-28 Thu 11:22:14+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-28 Thu 11:22] \\
  Sent to lwgchair.
:END:
- In [exec.awaitable] the definition of the ~has-as-awaitable~ concept constrains the result of calling
  ~std::forward<T>(t).as_awaitable(p)~ as needing to satisfy ~is-awaitable<Promise&>~.
  However, the ~is-awaitable~ concept takes its ~Promise~ template parameter and passes this as the
  template argument to ~coroutine_handle<Promise>~. Thus, this would end up trying to instantiate
  ~coroutine_handle<Promise&>~ which is probably not what was intended.

  The ~is-awaitable<Promise&>~ constraint needs to be changed to ~is-awaitable<Promise>~ as the
  ~is-awaitable~ concept applies the necessary lvalue reference to the template argument where
  necessary.

** WAITING [inplace_]stop_token is missing non-member swap() function
:PROPERTIES:
:CREATED:  [2025-08-28 Thu 12:43:57+0930]
:END:
:LOGBOOK:
- State "WAITING"    from              [2025-08-28 Thu 12:43] \\
  Sent to lwgchair.
:END:
- ~inplace_stop_token~ is missing non-member ~swap()~ function
  [stoptoken.inplace.general] defines ~inplace_stop_token~ with a member-~swap()~ function
  but does not declare a non-member overload of ~swap()~ that can be found by ADL by
  e.g. ~std::ranges::swap()~.

** Unformatted

- Wording for ~connect()~ defines ~operation-state-task~ which must have ~promise_type~ member equal to
  ~connect-awaitable-promise~ whose type depends on type of ~sndr~ and ~rcvr~ expressions passed into
  ~connect()~. However, other than the ~::promise_type~ member alias, there isn't anything in
  ~operation-state-task~ that actually depends on the types of the sender/receiver and so we could
  potentially avoid making this type dependent and all of the additional instantiations needed
  to use it if we instead specialised ~coroutine_traits<operation-state-task, _Sndr, _Rcvr>~ to
  have a ~promise_type~ of ~connect-awaitable-promise~ rather than specifying that ~operation-state-task~
  must have a ~promise_type~ of ~connect-awaitable-promise~.

- Should definition of ~connect-awaitable-promise~ in [exec.connect] be calling ~unreachable()~ inside
  the ~final_suspend()~, ~unhandled_exception()~ and ~return_void()~ member-functions instead of ~terminate()~?

- In [exec.as.awaitable] should ~sender-awaitable~ handle the case where the completion-signatures of the sender
  do not contain any error completions and where ~is_nothrow_constructible_v<result-type, Vs...>~ is true for
  all value completions ~set_value_t(Vs...)~ by avoiding the need to store an ~exception_ptr~ and also
  declaring the ~await_resume()~ member function of ~sender-awaitable~ as ~noexcept~?
  Implementations can already do this if they want to (strengthening is allowed), but do we want
  to require implementations to do this?

- In [exec.as.awaitable] p7.1 the wording says that ~as_awaitable(expr, p)~ is expression equivalent to
  ~expr.as_awaitable(p)~ if that expression is well formed, and if so then mandates that the type of that
  expression satisfies ~is-awaitable<Promise>~.
  - The use of MANDATES here seems inconsistent with the definition of ~with-await-transform~
    in [exec.awaitable] which has an ~await_transform~ overload that constrains the call to ~value.as_awaitable(promise)~
    to both be a valid expression and have a return-type that satisfies ~is-awaitable<Promise&>~.
  - We should be consistent between ~execution::as_awaitable(sndr, promise)~ and ~with-await-transform~
    as to whether we use constraints or mandates to check that the result of ~.as_awaitable()~ satisifies
    ~is-awaitable~.
  - In fact, we may actually want to use a different concept that only checks for the ~awaitable~ concept
    and that does not apply any ~promise.await_transform~ transformations. The ~is-awaitable~ concept will
    apply ~await_transform~ to the argument-type, which in this case is the result of calling ~expr.as_awaitable(promise)~.
    However, the typical use case for the ~as_awaitable()~ CPO is to call it from within ~await_transform~
    (like ~with_awaitable_senders~ helper does) in which case the type that we want to check has already
    gone through the promise-type's ~await_transform~ transformation and so passing the result through
    ~await_transform~ again as part of ~is-awaitable~ concept check seems incorrect.

- [exec.with.awaitable.senders] p2 The ~requires~ clause checking whether
  ~other.unhandled_stopped()~ is valid should also check that the result satisfies
  ~convertible_to<coroutine_handle<>>~, similarly to how the exposition-only concept
  ~awaitable-sender~ defined in [exec.as.awaitable] does.

- [exec.with.awaitable.senders] p3 Consider mandating here that ~derived_from<Promise, with_awaitable_senders>~ is satisfied
  to ensure that the ~static_cast<Promise&>(*this)~ is a valid expression.

- [exec.with.awaitable.senders] p3 The ~with_awaitable_senders::await_transform~ member function
  should declare a conditionally-noexcept exception specification to be consistent with
  the ~with-await-transform::await_transform~ function.


  
** Issues that need more investigation

- ~env<Envs...>::query()~ has a return-type defined as ~decltype(auto)~.
  I suspect this may cause problems for some queries that need to get the return-type but
  for which the body may not yet be valid (e.g. because some types are still incomplete).
  Although I don't have any concrete examples of where this is an issue at the moment.

- ~get_allocator_t~ uses ~MANDATE-NOTHROW~ but lots of allocator types are not actually required
  to be nothrow copyable/movable, only that they are "Throws: nothing".
  - Do we need this to be transparent to ~noexcept~ here, instead?

- ~with-await-transform::await_transform()~ uses ~decltype(auto)~ as the return-type.
  Should it use a trailing return-type instead?

- Wording for ~connect()~ requires evaluating ~get_env(rcvr)~ even if ~get-domain-late~ ends up
  returning a ~default_domain~. Do we want to allow eliding call to ~get_env(rcvr)~ if the
  returned environment would be unused?


* Notes not directly related to [exec] wording

- suggestion for language improvement for lookup of ~operator co_await()~.
  - Why can't we make the expression ~operator co_await(x)~ perform lookup of both member-function
    and namespace-scope functions (using ADL) and then perform overload resolution on both
    rather than having to separately perform member and non-member lookup?



* Notes on P3557R3 - high quality sender diagnostics
- ~dependent_sender_error~ is not specified to at least specify a default constructor
  (meaning that its construction always has exactly the semantics of ~exception()~)
  nor does it specify that it overrides the ~::what()~ member-function - meaning that
  it always just gets the default implementation provided by ~exception::what()~.
  - Do we want to specify that these members are provided at least so that
    implementations are permitted to provide custom behaviour for them?
