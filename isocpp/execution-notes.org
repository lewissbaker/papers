* Notes on std::excecution wording for pre-Sofia draft

** Standard defined queries can't customize forwarding_query_t by inheriting from it

The definition of the ~forwarding_query_t~ ([[[https://eel.is/c++draft/exec#fwd.env][exec.fwd.env]]]) states that a query is a
forwarding-query if either the expression ~q.query(forwarding_query)~ is a constant
expression that evalutes to true o or the query type inherits from forwarding_query_t.

However, all of the queries defined in [[[https://eel.is/c++draft/exec][exec]]] are defined similar to the following:
#+begin_src c++
  struct get_allocator_t { unspecified };
#+end_src

While this definition allows for the members of the class to be unspecified, it still
explicitly specifies that it has an empty list of base-classes and therefore cannot
customize ~forwarding_query_t~ by inheriting from ~forwarding_query_t~.

We should consider whether we want to change the specification of queries that are
to be forwarding-queries to allow inheritance from ~forwarding_query_t~ or otherwise
remove the support for customising ~forwarding_query_t~ by inheriting from it.

The recommended resolution is to remove the rule that checks for inheritance from
~forwarding_query_t~.

** Equal schedulers should be required to have same behaviour

The wording [[[https://eel.is/c++draft/exec#sched-4][exec.sched]]] p4 says:
#+begin_quote
For any two values ~sch1~ and ~sch2~ of some scheduler type ~Sch~, ~sch1 == sch2~ shall
return ~true~ only if both ~sch1~ and ~sch2~ share the same associated execution resource.
#+end_quote

However, I don't think this requirement is sufficient for schedulers to be considered
equal as it is possible to have two different schedulers that share the same associated
execution resource but that have different behaviour.

For example, two schedulers of the same type but where one schedules items with high
priority and others with low priority.

Ideally we want two schedulers to be equal if and only if they can be used interchangeably
such that using either scheduler to schedule work has the same behaviour.

Note that some use cases may also want to compare two schedulers as to whether or not
they share the same associated execution resource, independently of their scheduling
behaviour, however this could be added as a separate operator later.
e.g. ~std::execution::same_resource(sch1, sch2)~

It's also not clear how this definition applies to schedulers such as an ~inline_scheduler~
(added in P3552) in which has no specific associated execution resource but instances
nevertheless have the same scheduling behaviour.

I suggest this paragraph is changed to refer to the schedulers having the same
scheduling behaviour rather than having the same associated execution resource.
Or at least add a note here indicating that equality operator may return false
if the behaviour is different, even if the schedulers share an associated execution
resource.

** Remove note regarding waiting for completion of scheduled operations

The note at the end of [[https://eel.is/c++draft/exec#sched-note-1][exec.sched]] says:
#+begin_quote
[Note: The ability to wait for completion of submitted function objects can be
provided by the associated execution resource of the scheduler - end note]
#+end_quote

The suggestion that the execution resource should be used to join/wait on
scheduled work is problematic in situations that may involve more than one
execution context, as an execution resource having an empty queue of scheduled
work does not necessarily imply that tasks currently running on another
execution context will not later schedule additional work on this execution
resource.

With the introduction of ~counting_scope~ with P3149 we now have a better recommended
way of waiting for tasks that use a resource (including execution resources)
to complete.

The note as it stands represents bad guidance and should either be removed or
updated to refer to ~counting_scope~ and ~simple_counting_scope~ ([exec.counting.scopes]).

** Consider mandating that ~set_value()~, ~set_error()~ and ~set_stopped()~ calls have a return-type of ~void~

The expression ~set_value(rcvr, vs...)~ is defined as expression-equivalent to ~MANDATE-NOTHROW(rcvr.set_value(vs...))~.

As we do not also mandate that the result-type of this expression must be ~void~, it is presumably
allowed to return any other type and the ~set_value_t~ CPO is required to return any such value
returned by the member-function in order to preserve the "expression-equivalent" property.

I think we should mandate that the return-type of this expression is ~void~ to both avoid
misuse of the return-value here but also to preserve design space for potential future
extensions that might want to ascribe meaning to non-void return-values.

Similarly for the ~set_error~ and ~set_stopped~ CPOs.

*Suggestion:*
Add a "Mandates: If the expression ~set_value(rcvr, vs...)~ is well-formed, its type shall be ~void~." to [exec.set.value].
And similarly for ~set_error~ and ~set_stopped~.

** Reconsider ~weakly_parallel~ as the default ~forward_progress_guarantee~

The ~get_forward_progress_guarantee~ CPO is intended to allow querying a scheduler
as for what sort of forward-progress guarantee it provides.

Algorithms may use this to determine whether it is safe to execute certain
operations on a given scheduler.

If a scheduler does not customize this query, the query will fall back to returning
a forward-progress guarantee of ~weakly_parallel~.

I think we should reconsider what this default should be returning and suggest it
should instead return ~parallel~ by default, as this will be by far the most common
kind of scheduler - i.e. a scheduler that executes on ~std::thread~-like execution
agents and that maintains a queue of scheduled tasks.

I expect it to be common that authors of schedulers may forget to customize the
~get_forward_progress_guarantee_t~ query and just leave it at the default, which
will likely leave their scheduler reporting a weaker guarantee than it actually
provides and thus not being usable within generic algorithms that require at least
~parallel~ forward progress.

For example, the ~run_loop~ execution context defined in [exec.run.loop] does not
define its scheduler to customize the ~get_forward_progress_guarantee_t~.
This means it will report the default value of ~weakly_parallel~.

However, the scheduled operations will run on the thread that calls ~run_loop::run()~
and thus will inherit its forward-progress guarantees, and as this function might
block and is therefore unsafe to invoke it from a thread with ~weakly_parallel~
forward progress guarantes (which should probably be explicitly specified as
having undefined-behaviour) we can safely assume that ~run_loop~'s scheduler can
provide ~parallel~ forward-progress guarantee (assuming some thread eventually calls
~run()~).

It's not clear whether the current ~run_loop~ specification defaulting to it's scheduler
having ~weakly_parallel~ forward progress guarantee is intentional or unintentional here.

Schedulers that provide either ~weakly_parallel~ or ~concurrent~ forward progress
guarantees require implementations to be much more aware of the fact that these
are the guarantees they are providing and thus could be more expected to customize
the  ~get_forward_progress_guarantee~ query to return the respective values.

** Unformatted


- ~concept receiver~ is constraining on whether ~get_env(rcvr)~ returns a type that satisfies ~queryable~,
  but the ~get_env~ CPO already mandates that the return-value satisfies ~queryable~, so this check
  seems redundant. Similarly  for ~concept sender~.

- ~concept receiver~ uses ~move_constructible<remove_cvref_t<_Rcvr>> && constructible_from<remove_cvref_t<_Rcvr>, _Rcvr>~
  Could be simplfied using ~movable-value<_Rcvr>~?

- ~operation_state~ concept constraints on ~start(op)~ being ~noexcept~ but the ~start~ CPO already mandates that
  the expression is ~noexcept~. Can we simplify the concept to remove the ~noexcept~ check?

- Lots of the specification for queries are "expression equivalent to" some expression involving the
  global constexpr object. This tends to mean that the queries themselves must forward that specific
  object through by universal reference rather than taking it by copy as it may be possible to
  detect inside the implementation of a ~.query()~ function whether a reference to the actual
  global constexpr object was passed, or some copy of that object.

  - We only specify the semantics of calling the query CPO on the global object, we don't specify
    the semantics of calling the query on any copies of the query object.
  - Should we change the expression-equivalent-to to always pass a prvalue query object to the
    ~query()~ member function? This would allow query ~operator()~ to pass query objects by value.
    e.g. ~get_allocator(env)~ is expression equivalent to ~env.query(auto(get_allocator))~

  - Edit: seems like the semantics here are guaranteed by /customization-point object/ definition
    which requires that objects are default initializable and all objects of a given CPO type
    are equivalent. Still, it might be observable whether or not you are explicitly passed a
    reference to the global object or a reference to some other object.
    In fact, I think that the above change is actually necessary to satisfy the requirements of
    /customization-point object/.

- specification for ~FWD-ENV(env)~ talks about that for queryable object ~env~, ~FWD-ENV(env).query(q, as...)~ is expression-equivalent to ~env.query(q, as...)~.
  My interpretation of this is that this must end up calling ~env.query~ on the original ~env~ object, not on a copy
  of ~env~, and thus the resulting type of ~FWD-ENV(env)~ necessarily needs to store a reference to ~env~.
  However, many uses of ~FWD-ENV~ use ~FWD-ENV(get_env(x))~ which might end up passing a temporary object to ~FWD-ENV~.

- suggestion for language improvement for lookup of ~operator co_await()~.
  - Why can't we make the expression ~operator co_await(x)~ perform lookup of both member-function
    and namespace-scope functions (using ADL) and then perform overload resolution on both
    rather than having to separately perform member and non-member lookup?

- specification of ~completion_signatures~ usage should make use of ~type_order~ facilities to
  ensure a canonical ordering of types listed in ~completion_signatures~.

- ~transform_sender~, ~transform_env~ and ~apply_sender~ are all regular functions, whereas other customisation
  points are all defined as CPOs. Why do we define these as normal functions and the others as CPOs?

- ~default_domain::transform_env~ has a fallback of ~static_cast<Env>(std::forward<Env>(env))~ but it's not
  clear what the effect of the ~static_cast~ is here.
  - If this function is passed an lvalue, then ~Env~ is an lvalue-reference and the static_cast does not
    do anything more than ~std::forward<Env>(env)~ does.
  - If this function is passed an rvalue, then the ~static_cast~ will construct a new prvalue.
    - Why is this the desired behaviour?

- Use of ~common_type~ in ~completion-domain~ helper makes things extra complicated.
  Can we just get away with ~same_as~ here instead?

- In ~get-domain-late~ it uses a lambda expression with the structured binding:
  #+begin_src c++
    [] {
      auto [_, sch, _] = sndr;
      return query-with-default(get_domain, sch, default_domain());
    }()
  #+end_src
  However this will try to perform a copy of the sender which will be ill-formed if the
  sender is not copyable (Note ~sndr~ is a const-ref). The structured binding should instead
  start with ~auto& [_, sch, _] =~.

- ~env<Envs...>~ class contains a ~query(QueryTag)~ member-function that only takes the query-tag.
  However, the ~queryable~ concept description in [exec.queryable.general] still talks about
  queries taking a pack of extra arguments after the query tag. Similarly with the definition
  of ~FWD-ENV(env).query(q, as...)~ which also talks about forwarding an extra pack of arguments.
  Either we should drop support from extra arguments, or we should add support for extra arguments
  to ~env<Envs...>~ and ~prop<Query, Value>~.

- ~env<Envs...>::query()~ has a return-type defined as ~decltype(auto)~.
  I suspect this may cause problems for some queries that need to get the return-type but
  for which the body may not yet be valid (e.g. because some types are still incomplete).
  Although I don't have any concrete examples of where this is an issue at the moment.

- ~unstoppable_token~ concept is ill-formed
  - Can't use ~tok~ argument to ~requires~ clause in evaluated context.
  - Need to change requirement to ~requires (!Token::stop_possible());~ instead.

- ~AS-EXCEPT-PTR(err)~ is not necessarily ~noexcept~ yet is used in contexts (such as ~set_error()~ in [exec.sync.wait])
  where emitting an exception would result in termination.
  - In particular, the paragraph that says it's equivalent to ~make_exception_ptr(system_error(err))~ when ~err~ is an ~error_code~
    might throw from the ~system_error~ constructor, whose constructor is not marked ~noexcept~.
  - Should this be changed to catch any exception thrown by the exception and return
    ~current_exception()~ in that case?

- ~get_allocator_t~ uses ~MANDATE-NOTHROW~ but lots of allocator types are not actually required
  to be nothrow copyable/movable, only that they are "Throws: nothing".
  - Do we need this to be transparent to ~noexcept~ here, instead?

- ~with-await-transform::await_transform()~ uses ~decltype(auto)~ as the return-type.
  Should it use a trailing return-type instead?

- Wording for ~connect()~ needs to specify that ~rcvr~ is only to be evaluated once.
  - It occurs once in call to ~transform_sender(dom, sndr, rcvr)~
  - And occurs again in call to ~new_sndr.connect(rcvr)~

- Wording for ~connect()~ requires evaluating ~get_env(rcvr)~ even if ~get-domain-late~ ends up
  returning a ~default_domain~. Do we want to allow eliding call to ~get_env(rcvr)~ if the
  returned environment would be unused?

- Why are most customization points defined as CPOs, but ~transform_sender~, ~transform_env~ and ~apply_sender~
  are defined as normal functions?
