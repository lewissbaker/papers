# -*- mode: org; org-html-htmlize-output-type: css -*-
#+TITLE: D3425R2: Reducing operation-state sizes for subobject child operations
#+AUTHOR: Lewis Baker
#+EMAIL: lewissbaker@gmail.com
#+DATE: 2025-02-14
#+OPTIONS: html5-fancy
#+OPTIONS: tasks:nil
#+OPTIONS: html-postamble:nil
#+EXPORT_FILE_NAME: P3425R2
#+EXPORT_EXCLUDE_TAGS: noexport,todo

#+BEGIN_EXPORT html
  <style>
    ins { background-color:#A0FFA0 }
    del { background-color:#FFA0A0 }
    expos { font-style:italic }
    exposonly {
      content: "// exposition only";
      font-style:italic;
    }
    div.section {
      counter-reset: paragraph;
      background-color:#A0FFA0;
    }
    div.wording > div.section {
      padding: 5px;
    }
    div.wording > div.section > h3 {
      margin-top: 5px;
    }
    div.wording {
      counter-reset: paragraph;
      margin-left: 50px
    }
    div.wording p.numbered::before {
      position: absolute;
      margin-left: -20px;
      margin-top: 2px;
      font-size: 0.75em;
      color: #CCC;
      content: counter(paragraph);
      counter-increment: paragraph;
    }
    div.wording ul {
      list-style-type: '\2014   ';
      counter-reset: paragraph;
    }
    div.wording ul li::before {
      position: absolute;
      margin-left: -75px;
      margin-top: 2px;
      font-size: 0.75em;
      color: #CCC;
      content: "(" counters(paragraph, ".") ")";
      counter-increment: paragraph;
    }
    div.wording ul ul li::before {
      margin-left: -125px;
    }
    div.wording ul ul ul li::before {
      margin-left: -175px;
    }
    div.wording ul ul ul ul li::before {
      margin-left: -225px;
    }
  </style>
#+END_EXPORT

| Document | *D3424R2*                                  |
| Date     | *2025-02-14*                               |
| Reply To | *Lewis Baker <lewissbaker@gmail.com>*      |
|          | *Bryan St. Amour <bryan@bryanstamour.com>* |
| Audience | *LEWG*                                     |

* Abstract

This paper proposes defining a standard protocol between parent operation-state and child-operation state
that permits the child-operation state to avoid needing to store the receiver in cases where the receiver
can be computed on-demand from the address of the child operation-state object.

Enabling this optimisation can save a pointer of storage for each nested operation-state, e.g. saving
40 bytes for a sender-expression 5 levels deep. Further, it can improve the performance of queries
to retrieve properties from the receiver's environment, by translating a series of pointer-dereferences
through successive parent-operation-state pointers into a series of constant-offsets from the child
operation-state address, allowing compilers to constant-fold such queries into a single pointer-dereference,
reducing code size and improving runtime performance.

While such a protocol is purely additive and could theoretically be added later, there are advantages to
adding it now as it permits us to specify that default implementations of standard-library algorithms
added by P2300 must incorporate this protocol in their implementation - something that may be difficult
to retrofit later, due to the potential for this causing breaking changes in type-layout.

* Motivation

When a sender-algorithm composes one or more child operations, it typically connects the child senders
with a receiver that contains a pointer to the parent operation-state as its only data-member.
The operation-state returned from the call to ~connect()~ will need to store this receiver as a
data-member so that it can later call the completion-functions on the receiver to signal completion
of the operation.

This means that for every sender in a sender expression-tree we generally have a linked list of
operation-states, with pointers wrapped up inside receivers, going from leaf operations up to
the top-most operation. This bears similarities to a traditional call-stack, although in the
case of senders the links can form a tree rather than being limited to a linear stack.

For algorithms that have a statically-known number of child operations, it is common to have the child
operation-states stored as data-members of the parent operation-state as this allows them to avoid
dynamic memory allocations.

However, if we think about it, for cases where the child operation-state is a direct member of the
parent operation-state, the pointer to the parent operation-state stored in the receiver held by
the child is always going to be pointing to some constant offset relative to the child operation-state's
address.

In cases where we can compute the address of the parent operation-state from the address of the child
operation-state, we can potentially reduce the size of child operation-states by not storing the receiver
and instead just constructing the receiver on-demand from the address of the child operation-state
whenever the child operation-state needs it.

Doing this would have two main of benefits:

1. It reduces the size of an overall operation-state tree by at least one pointer for each operation in
   the tree (it might save more due to padding for some operation-states).
2. When querying the environment of the receiver it can turn a walk of a linked-list of operation-states
   to get the address of the operation-state providing some query result into applying a series of
   constant offsets from the current operation-state's address.

There are also some secondary benefits for composition of algorithms that adopt these optimisations:

1. It reduces the run-time overhead of composing existing algorithms to build new algorithms.
2. This in turn reduces the need to write your own sender algorithms from scratch as often
   in order to get optimal performance.

** Example

For example, consider the following sender-expression:
#+begin_src c++
  when_all(
    then(                            // then_op#3
      then(                          // then_op#2
        then(                        // then_op#1
          schedule(thread_pool),
          f),
        g),
      h),
    then(                            // then_op#6
      then(                          // then_op#5
        then(                        // then_op#4
          schedule(thread_pool),
          a),
        b),
      c))
#+end_src

With the status-quo, connecting the resulting sender to a receiver, ~rcvr~, would result in the
following operation-state layout:

#+begin_src
                          A
  +-----------------------|-----------------+
  | when_all_op           |  A              |
  | - rcvr (parent_op*) --'  |              |
  | - ref_count              |              |
  | - stop_source            |              |
  | - stop_callback          |              |
  | - result_tuple           |              |
  | +------------------------|------------+ |
  | | then_op#3              | A          | |
  | | - rcvr (when_all_op*) -' |          | |
  | | - h                      |          | |
  | | +------------------------|--------+ | |
  | | | then_op#2              | A      | | |
  | | | - rcvr (then_op#3*) ---' |      | | |
  | | | - g                      |      | | |
  | | | +------------------------|----+ | | |
  | | | | then_op#1              | A  | | | |
  | | | | - rcvr (then_op#2*) ---' |  | | | |
  | | | | - f                      |  | | | |
  | | | | +------------------------|+ | | | |
  | | | | | schedule_op            || | | | |
  | | | | | - rcvr (then_op#1*) ---'| | | | |
  | | | | | - thread_pool*          | | | | |
  | | | | | - stop_callback         | | | | |
  | | | | | - ...                   | | | | |
  | | | | +-------------------------+ | | | |
  | | | +-----------------------------+ | | |
  | | +---------------------------------+ | |
  | +-------------------------------------+ |
  | +-------------------------------------+ |
  | | then_op#6                           | |
  | | - rcvr (when_all_op*)               | |
  | | - ... (similar to above)            | |
  | +-------------------------------------+ |
  +-----------------------------------------+
#+end_src

There are a few things worth noting here.

*Operation State Size*

The child operation states all hold a receiver that contains a pointer
to the parent operation-state. In total, this consists of 8x pointers to
parent operation-states (9x pointers if you include the one likely to be stored
in the receiver held by when_all_op).

Together, these contribute at least 64-72-bytes in total across the whole
operation-state hierarchy - possibly more depending on the size/alignment
of the function-objects passed to ~then()~. e.g. if padding is required.

*Cost of Environment Queries*

The leaf ~schedule_op~ operations need to subscribe to a stop-callback
on the environment's current stop-token in order to support cancellation of
the operation - the ~when_all()~ algorithm can send a stop-request to children
if any of them fail.

However, in order to obtain the stop-token needed to register the stop-callback,
the ~schedule_op~ implementation needs to ask its receiver by calling
~std::get_stop_token(std::execution::get_env(rcvr))~.

The ~get_stop_token~ query on the receiver stored in the ~schedule_op~
forwards the query to the receiver stored in the ~then_op#1~ object, which then
forwards the query to the receiver stored in the ~then_op#2~ object, which then
forwards the query to the receiver stored in the ~then_op#3~ object, which then
satisfies the query by calling ~stop_source.get_token()~ on the stop-source
stored in the ~when_all_op~ object.

This is 4x pointer dereferences needed to obtain the address of the stop-source
object required to evaluate obtain the stop-token.
Queries which propagate further up the stack of sender-operations might have to
do even more pointer dereferencing to get the query result.

Further, each query that is satisfied by a parent environment up the stack
will require its own walk through these pointers to the operation-state that
fulfils that particular query.

This stack-walking has a run-time cost - the successive loads from memory of the
pointer data cost possibly a few cycles if the data is cache, but could be 10s or 100s
of cycles if several of the loads need to go to main memory. The successive loads
are all dependent on the prior loads and so the CPU cannot generally pipeline the
loads.

The stack-walking logic also has a code-size cost. The compiler needs to generate
a sequence of N mov/load instructions for evaluating each query, where N is the number
of levels up the stack the query needs to traverse in order to get to the
operation-state that statisfies the query.

*Cost of Completion*

Similar to the cost of pointer-walking for performing queries, calling the completion-function
on a receiver also often requires dereferencing the same set of pointers.

In the example above, when the schedule-operation completes it needs to load the pointer to
the ~then_op#3~ operation state from the ~schedule_op~ state in order to compute the address
of the function-object, ~f~, to invoke. Then, when ~f()~ returns, it needs to load the
pointer to the ~then_op#2~ operation state from the ~then_op#3~ state in order to compute
the address of the function-object, ~g~, to invoke, and so forth.

In a more extreme example, consider the case where a composition of nested operations
all just forward through the result to the parent receiver up N levels until the eventual
ancestor operation that handles the result. Even in this case, where there is no processing
of the result datums being done, we still need to follow the linked-list of operation-states
in order to compute the address of the final handler of the result.

*Cost of Composition*

The net result of all of the above costs is that there is a cost to composing these
operations.

If the code had, instead, been written with a single ~then()~ which took a function object
that composed ~f~, ~g~ and ~h~ then the result would have less overhead than the expression
where each of these transformations is applied in a separate ~then()~ invocations.

For example, we could have written:
#+begin_src c++
  when_all(
    then(schedule(thread_pool), [f, g, h] { return h(g(f())); }),
    then(schedule(thread_pool), [a, b, c] { return c(b(a())); }))
#+end_src

and this would have fewer operation-state pointers and fewer pointer-indirections than
the original code above.

While, in some cases, this kind of manual flattening of composition is possible - it is not always possible.

This makes the cost of composition have non-zero runtime overhead.

This is likely to have the unfortunate side-effect of encouraging users to try to write
their code using as few layers of composition as possible - potentially making their code
more complex, or even having to write new sender algorithms that implement certain compositions
more efficiently.

** Example - Revisited

If we look at the above example, but this time with the optimisations proposed in this paper
being applied, then the resulting operation-state will, instead, look something like this:

#+begin_src

                     A
  +------------------|---+------A-----------+
  | when_all_op      |   |      |           |
  | - (maybe?) rcvr -'   |      |           |
  | - ref_count          |      |           |
  | - stop_source    <---'      | -72 bytes |
  | - stop_callback   +16 bytes |           |
  | - result_tuple              |           |
  | +----------------------A----+---------+ |
  | | then_op#3            | -16 bytes    | |
  | | - h                  |              | |
  | | +-----------------A--+------------+ | |
  | | | then_op#2       | -4 bytes      | | |
  | | | - g             |               | | |
  | | | +-------------A-+-------------+ | | |
  | | | | then_op#1   | -8 bytes      | | | |
  | | | | - f         |               | | | |
  | | | | +-----------+-------------+ | | | |
  | | | | | schedule_op             | | | | |
  | | | | | - thread_pool*          | | | | |
  | | | | | - stop_callback         | | | | |
  | | | | | - ...                   | | | | |
  | | | | +-------------------------+ | | | |
  | | | +-----------------------------+ | | |
  | | +---------------------------------+ | |
  | +-------------------------------------+ |
  | +-------------------------------------+ |
  | | then_op#6                           | |
  | | - ... (similar to above)            | |
  | +-------------------------------------+ |
  +-----------------------------------------+
#+end_src

In this case, each of the child operations knows how to compute the address of the parent-operation
state from the address of the child operation state - because the parent operation-state injects this
information in along with the receiver in the form of a static function on the receiver type.

So, when the ~schedule_op~ object goes to construct the ~stop_callback~ member and needs to get
the stop-token from the environment, the compiler sees a series of inlinable calls to compute the
parent receiver, each of which just subtracts an offset from the child operation-state.

The net result is that, in optimised compilation modes, the compiler can constant-fold all of these
offsets into a single offset from the ~schedule_op~ address and thus does not need to perform any
memory loads in order to obtain the stop-token (which is just initialized with the address of the
stop-source object).

For example, in the above operation-state layout diagram, the compiler would effectively lower this
code to the equivalent of the following (after inlining):
#+begin_src c++
  void schedule_op::start() noexcept {
    // Evaluate:
    //  auto st = std::get_stop_token(std::get_env(this->get_receiver()));
    //
    // Lowers to equivalent to:
    auto* _op1 = reinterpret_cast<then_op_1*>(reinterpret_cast<unsigned char*>(this) - 8);
    auto* _op2 = reinterpret_cast<then_op_2*>(reinterpret_cast<unsigned char*>(_op1) - 4);
    auto* _op3 = reinterpret_cast<then_op_3*>(reinterpret_cast<unsigned char*>(_op2) - 16);
    auto* _when_all_op = reinterpret_cast<when_all_op*>(reinterpret_cast<unsigned char*>(_op3) - 72);
    auto st = _when_all_op.stop_source.get_token();
    // ...
  }
#+end_src

Which, after constant-folding would result in a constant offset from ~this~:
#+begin_src c++
  void schedule_op::start() noexcept {
    // Evaluate:
    //  auto st = std::get_stop_token(std::get_env(this->get_receiver()));
    //
    // Lowers to equivalent to:
    auto& _ss = *reinterpret_cast<std::inplace_stop_source*>(
                   reinterpret_cast<unsigned char*>(this) - 84);
    auto st = _ss.get_token();
    // ...
  }
#+end_src

In addition to this being more optimisable by the compiler, the overall operation-state size has
now shrunk by at least 64-bytes due to not having to store the pointers to parent-operation states.

There is also now a reduction in code-size in the resulting binary.
There are no longer instructions needed to initialize the the pointers to parent-operation-states.
There is no longer instructions needed to dereference the chain of pointers during query evaluation
or on completion.

The overall net result is that this optimisation permits a reduction in memory usage, an increase
in run-time performance and a reduction in code-size proportional to the depth of the sender
expression tree that can be inlined.

Further, this code is now more efficient than the hand-flattened version above that combined
the three nested invocations of ~then()~ into a single invocation of ~then()~, reducing the
motivation for programmers to perform this sort of manual optimisation.

* Proposal

The proposal includes two key parts which enable the optimisations mentioned above:
1. Defining the key protocol that allows a parent and child operation to negotiate to apply
   the optimisation when both support it.
2. Applying this protocol to the sender-algorithms proposed by P2300R10.

This proposal also includes some utilities which can be used to make it easier for authors of
sender types to implement the above optimisation protocol correctly. These facilities could
be optionally included either now or later. If not included now the sender authors can still
implement the protocol, but will need to implement their own versions of these helpers in
the meantime.

** The core protocol

The key, enabling part of this optimisation is providing a child operation with a way to
construct a receiver on-demand given the address of the child operation.

The mechanism proposed here for this is to allow receiver types to define a static factory
function that accepts a pointer to the child operation-state and that returns an instance
of that receiver type.

For example:
#+begin_src c++
  struct some_receiver {
    // Factory-construct a receiver on-demand from the child operation-state address.
    static some_receiver make_receiver_for(child_op_state* op) noexcept;

    // Other receiver methods.
    void set_value(auto&&... vs) noexcept;
    void set_error(auto&& e) noexcept;
    void set_stopped() noexcept;
    some_env get_env() const noexcept;
  };
#+end_src

If the receiver has such a factory function then the child operation is free to not store
the reciever passed to ~connect()~ and to, instead, just call this factory function to
obtain a new receiver object whenever the receiver is needed.

This requirement basically defines a new concept that subsumes the ~receiver~ concept
which can be written as follows:

#+begin_src c++
  namespace std::execution
  {
    template<typename T, typename ChildOp>
    concept inlinable_receiver =
      receiver<T> &&
      requires(ChildOp* op) {
        { T::make_receiver_for(op) } noexcept -> std::same_as<T>;
      };
  }
#+end_src

Note that the concept does not check that ~ChildOp~ satisfies ~operation_state~ as the concept
needs to be usable at a point where the ~ChildOp~ type is still an incomplete type.

With this concept, a child operation-state type, ~ChildOp~, can then specialise itself to either
hold the receiver as a data-member or not depending on whether the receiver type satisfies
the ~inlinable_receiver<ChildOp>~ concept.

For example:
#+begin_src c++
  template<typename Receiver>
  class my_op_state {
  public:
    my_op_state(Receiver r) noexcept : rcvr_(std::move(r)) {}
    void start() noexcept;
  private:
    Receiver& get_receiver() noexcept { return rcvr_; }
    Receiver rcvr_;
  };

  template<typename Receiver>
  requires inlinable_receiver<Receiver, my_op_state<Receiver>>
  class my_op_state<Receiver> {
    my_op_state([[maybe_unused]] Receiver r) noexcept {}
    void start() noexcept;
  private:
    Receiver get_receiver() noexcept { return Receiver::make_receiver_for(this); }
    // NOTE: No 'Receiver' data-member.
  };
#+end_src

It is worth noting that the optimisation proposed here requires both the parent operation
and child operation to opt-in to the protocol for the optimisation to be applied.
If either the parent or child do not opt-in to the protocol then we need to still gracefully
revert back to the default behaviour of storing the receiver.

We can see how this would work by examining the code above:
- If the specialisation for an ~inlinable_reciever~ was not present, as would be the case if the
  child operation did not opt-in to the optimisation, then the child operation would just store
  the receiver as normal.
- If the parent operation-state did not provide a receiver to the child operation-state that
  implemented the ~inlinable_receiver~ concept, then the child operation state would not
  instantiate the specialisation and would instead fall back to instantiating the primary
  template that just stores the receiver as normal.
- If the parent operation-state provides a receiver that implements the ~inlinable_reciever~
  concept /and/ the child operation implements the specialisation for ~inlinable_receiver~
  then we end up instantiating the child operation state specialisation that can avoid storing
  the receiver.

Note that while it is optional for operation-state implementations to implement this protocol,
it is recommended that all operation-state implementations do so, in order to maximise the
effectiveness of the optimisation.

** Adding a helper for child operation-states (optional)

When defining the operation-state for a sender, it would be overly verbose for the author
to have to duplicate their logic across two specialisations as defined above.

To allow encapsulating this optimisation and eliminating the duplication of code,
we can factor out this facility into a helper CRTP base-class which is responsible
for storing (or producing on demand) the receiver.

This paper proposes optionally adding the following helper class for operation-state
authors to use to enable the optimisation in their implementations:
#+begin_src c++
  // In <execution> header
  namespace std::execution
  {
    template<typename Derived, receiver Receiver>
    class inlinable_operation_state {
    protected:
      explicit inlinable_operation_state(Receiver r)
        noexcept(std::is_nothrow_move_constructible_v<Receiver>)
        : rcvr_(std::move(r)) {}

      Receiver& get_receiver() noexcept { return rcvr_; }

    private:
      Receiver rcvr_; // exposition-only
    };

    template<typename Derived, receiver Receiver>
    requires inlinable_receiver<Receiver, Derived>
    class inlinable_operation_state<Derived, Receiver> {
    protected:
      explicit inlinable_operation_state(Receiver r) noexcept {}

      Receiver get_receiver() noexcept {
        return Receiver::make_receiver_for(static_cast<Derived*>(this));
      }
    };
  }
#+end_src

This class can then be used as a base-class of any operation-state that wants to
be able to opt-in to this optimisation.

For example, the above ~my_op_state~ class can now be written as a single primary template
by inheriting publicly from ~inlinable_operation_state~:
#+begin_src c++
  template<typename Receiver>
  class my_op_state : public inlinable_operation_state<my_op_state<Receiver>, Receiver> {
  public:
    my_op_state(Receiver r) noexcept
      : inlinable_operation_state<my_op_state, Receiver>(std::move(r))
    {}

    void start() noexcept {
      // Call this->get_receiver() to get the receiver from the base-class.
      auto st = std::get_stop_token(std::execution::get_env(this->get_receiver()));
      if (st.stop_possible()) {
        // ...
      }
    }
  };
#+end_src

This facility will be useful for all sender implementations (basically any sender that might become
a child-operation of some sender-algorithm). This includes both leaf sender operations, which I
expect will be the majority of senders authored by users, as well as sender-algorithms that compose
other senders.

However, this facility is also fairly simple and straight-forward for users to write themselves
when authoring sender implementations. It is only 20 lines of code and so the benefit from having
such a facility in the standard library is one of convenience rather than one of abstracting away
something complex that would be difficult to write by-hand.

** Implementing ~make_receiver_for()~

So, now that we have shown the child-operation part of the protocol and how it can
use this protocol to avoid storing the receiver, let's now turn to looking at how
we can actually implement this protocol from the parent-operation side.

This part of the protocol is considerably more involved, and there are a few pitfalls
that we need to be careful to avoid, lest we unintentially invoke undefined behaviour.

A naive first approach might be to try something like the following which uses ~offsetof~
to compute the address of the parent operation from the address of the child:
#+begin_src c++
  template<typename ParentReceiver, typename ChildSender>
  class parent_op
    : public std::execution::inlinable_operation_state<parent_op<ParentReceiver, ChildSender>, ParentReceiver> {
  private:
    struct child_receiver {
      parent_op* op;

      template<typename ChildOp>
      static child_receiver make_receiver_for(ChildOp* child_op) noexcept {
        static_assert(std::same_as<ChildOp, child_op_t>);
        // KEY PART: Compute address of parent_op from address of child_op
        auto* parent = reinterpret_cast<parent_op*>(
            reinterpret_cast<unsigned char*>(child_op) - offsetof(parent_op, child_op_));
        return child_receiver{parent};
      }

      // ... other receiver methods omitted for brevity
    };

    using child_op_t = std::connect_result_t<ChildSender, child_receiver>;
    child_op_t child_op_;

  public:
    parent_op(ChildSender&& child, ParentReceiver rcvr)
    : std::execution::inlinable_operation_state<parent_op, ParentReceiver>(std::move(rcvr))
    , child_op_(std::execution::connect(std::forward<ChildSender>(child), child_receiver{this}))
    {}

    void start() noexcept {
      std::execution::start(child_op_);
    }
  };
#+end_src

However, while this approach may appear to work on some implementations, /it is actually undefined behaviour/
to do this.

It is not permitted to go from the address of a child data-member to the address of the parent class except
in very limited circumstances. This rule is there to permit, among other things, a compiler-optimisation
called "scalar replacement of aggregates", which allows the compiler to break up an aggregate type into
a set of separate stack-allocations for each of the data-members if the address of the parent object is
not aliased/observed.

The very limited circumstances in which we can go from the address of a sub-object to the address of
the parent-object are the following:
- When the sub-object is a non-ambiguous base-class of parent-object ([[https://eel.is/c++draft/expr.static.cast#11][[expr.static.cast] p11]])
  In this case, we can use ~static_cast~ to cast from pointer to base-class to the pointer to the derived parent-object
- When the parent-object and sub-object are "pointer-interconvertible" ([[https://eel.is/c++draft/basic.compound#5][[basic.compound] p5]]).
  In this case, we can use ~reinterpret_cast~ to cast from pointer to sub-object to pointer to parent-object.

Two objects are "pointer-interconvertible" only if:
- the parent-object is a union and the sub-object is a non-static data-member of that union; or
- the parent-object is a "standard layout" class object and the sub-object is the first non-static
  data-member of the parent-object or any base-class sub-object of the parent-object
- there exists an intermediate sub-object, ~C~, such that the parent-object is pointer-interconvertible
  with ~C~ and ~C~ is pointer-interconvertible with the sub-object (i.e. the relationship is transitive)

Note that there are a number of rules for types that are considered "standard layout" class types ([[https://eel.is/c++draft/class.prop#3][[class.prop] p3]]).
I won't go into particular details here but, among other things, this doesn't allow types with virtual methods,
virtual base-classes, types with non-static data-members with different access control, or data-members
that are not also standard layout class types.

As child operation states in general are not going to all be standard layout types and since we also want
to support cases where a parent-operation has multiple child operations, we cannot just rely on being able
to convert the address of the first non-static data member to the address of the parent as a general
solution.

This means that we are going to need to make use of base-classes to allow going from address of a
sub-object to the address of a parent-object.

Further, there are also cases where we need to be able to defer construction of a child operation-state
until after the operation is started, or where we want to be able to destroy a child operation-state
before the parent operation-state is destroyed.

This means that, in general, we cannot just use the child operation-state as a direct base-class as
this would force the lifetimes of the child operation-state to be the same as the lifetime of the
parent operation-state.
Instead, we can define a base-class that has as its only data-member an array of bytes which is used
as storage for the child-operation state, into which we can placement-new the child operation-state
at the appropriate time.

This can also be used to emulate unions of operation-states, where there might be a set of possible
operation-state types that might need to be able to be constructed in that storage. For example,
consider the set of possible operation-states for the successor operation of ~let_value()~, the type
of which may depend on what value completion-signature the predecessor completed with.

There are also some challenges with regards to avoiding circular dependencies when computing the
complete type for the child operation-state. This will generally require the receiver type to be
complete, but may also require the receiver's environment type to be complete if the child operation-state
depends on the types of query-results (e.g. if it contains a stop-callback data-member).

However, as the layout of the child operation-state needs to be known during instantiation of a base-class
of the parent operation-state type, the completeness of the receiver and its environment cannot depend
on anything defined in the interface of the parent operation-state class.

This means that the return-types of all environment queries need to be known, even if the body of the
query methods needs to access some state from the parent-operation-state (e.g. a stop-source).
This information about the environment, therefore, needs to be injected into the base-class somehow,
typically in the form of an additional template parameter.

Finally, since we might have multiple child operations which are constructed from the same sender
(consider the child operations of ~when_all(just(1), just(2))~), we need some way to distinguish
different base-class child-objects so that we don't run into issues with duplicate base-classes,
which would either be ill-formed or make the down-cast we want to perform ambiguous.

So, therefore, as we want to have a generic helper class we can use for the base-class, we also
need to add some kind of 'tag' template parameter which can be passed something different for
each child-operation to ensure that each child-operation base-class is distinct.

So, putting all of this together, we end up with some helper-classes like the following:
#+begin_src c++
  template<typename Sender, typename Receiver>
  inline constexpr bool is_nothrow_connectable_v =
    noexcept(std::execution::connect(std::declval<Sender>(), std::declval<Receiver>()));

  // Helper class for parent operations that want to manually manage the lifetime of
  // a child operation.
  template<typename ParentOp, typename Tag, typename Env, typename ChildSender>
  class manual_child_operation_state {
  private:
    class receiver {
    public:
      // Implement the prot
      template<typename ChildOp>
      static receiver make_receiver_for(ChildOp* child_op) noexcept {
        static_assert(std::same_as<ChildOp, child_op_t>);

        // Cast from 'child_op_t*' to  'unsigned char*' pointer to 'storage_' member.
        // - valid since we constructed at the storage address using placement-new.
        auto* storage = reinterpret_cast<unsigned char*>(child_op);

        // Cast from address of first member of 'manual_child_operation_state' to
        // address of 'manual_child_operation_state'.
        // Valid as 'manual_child_operation_state' is a standard-layout type.
        auto* self = reinterpret_cast<manual_child_operation_state*>(storage);

        // Cast from manual_child_operation_state address to address of 'ParentOp'
        // which inherits from manual_child_operation_state.
        auto* parent_op = static_cast<ParentOp*>(self);

        // Construct a receiver with the address of the parent operation-state.
        return receiver{parent_op};
      }

      // Forward following calls on the receiver to calls on the parent operation-state
      // object with the added 'Tag' object as the first argument.

      template<typename... Vs>
      void set_value(Vs&&... vs) noexcept {
        parent_op_->set_value(Tag{}, std::forward<Vs>(vs)...);
      }

      template<typename E>
      void set_error(E&& e) noexcept {
        parent_op_->set_error(Tag{}, std::forward<E>(e));
      }

      void set_stopped() noexcept {
        parent_op->set_stopped(Tag{});
      }

      Env get_env() const noexcept {
        return parent_op_->get_env(Tag{});
      }

    private:
      friend manual_child_operation_state;
      explicit receiver(ParentOp* parent_op) noexcept : parent_op_(parent_op) {}
      ParentOp* parent_op_;
    };

    using child_op_t = std::execution::connect_result_t<ChildSender, receiver>;

  protected:
    // Trivial default constructor/destructor
    manual_child_operation_state() noexcept = default;
    ~manual_child_operation_state() = default;

    // Start execution of the child operation state.
    void start() noexcept {
      std::execution::start(get());
    }

    // Manually construct the child operation from the sender.
    void construct(ChildSender&& sender) noexcept(is_nothrow_connectable_v<ChildSender, receiver>)
      auto* parent_op = static_cast<ParentOp*>(this);
      ::new (&storage_) child_op_t(
          std::connect(std::forward<ChildSender>(sender), receiver{parent_op}));
    }

    // Manually destruct the child operation from the sender.
    void destruct() noexcept {
      get().~child_op_t();
    }

  private:
    child_op_t& get() noexcept {
      return *std::launder(reinterpret_cast<child_op_t*>(&storage_));
    }

    alignas(child_op_t) unsigned char storage_[sizeof(child_op_t)];
  };

  // Helper class for parent operations that want a child operation with the same lifetime
  // as that of the parent operation.
  template<typename ParentOp, typename Tag, typename Env, typename ChildSender>
  class child_operation_state : public manual_child_operation_state<ParentOp, Tag, Env, ChildSender> {
  private:
    using base_t = manual_child_operation_state<ParentOp, Tag, Env, ChildSender>;
    using base_t::construct;
    using base_t::destruct;

  protected:
    explicit child_operation_state(ChildSender&& sender)
        noexcept(noexcept(base_t::construct(std::forward<ChildSender>(sender))) {
      base_t::construct(std::forward<ChildSender>(sender));
    }

    ~child_operation_state() {
      base_t::destruct();
    }
  };
#+end_src

Revisiting the ~parent_op~ example above, it can now be rewritten as follows:
#+begin_src c++
  // A tag type to used for identifying which child a completion signal comes from
  struct source_tag {};

  template<typename ParentReceiver, typename ChildSender>
  class parent_op
      : public std::execution::inlinable_operation_state<
          parent_op<ParentReceiver, ChildSender>,
          ParentReceiver>
      , public child_operation_state<   // Inherit from 'child_operation_state'
          parent_op<ParentReceiver, ChildSender>,
          source_tag,
          std::execution::env_of_t<ParentReceiver>,
          ChildSender> {
    using inline_base_t = std::execution::inlinable_operation_state<parent_op, ParentReceiver>;
    using env_t = std::execution::env_of_t<ParentReceiver>;
    using child_base_t = child_operation_state<parent_op, source_tag, env_t, ChildSender>;

  public:
    parent_op(ChildSender&& child, ParentReceiver rcvr)
      : inline_base_t(std::move(rcvr))
      , child_base_t(std::forward<ChildSender>(child))
    {}

    void start() noexcept {
      child_base_t::start();
    }

    //
    // Implement handling for signals coming from receiver passed to the
    // 'source_tag' child operation.
    //

    template<typename... Vs>
    void set_value(source_tag, Vs&&... vs) noexcept {
      // ...

      // Eventually... signal completion.
      std::execution::set_value(this->get_receiver(), the_result);
    }

    template<typename E>
    void set_error(source_tag, E&& e) noexcept {
      // ...
    }

    void set_stopped(source_tag) noexcept {
      // ...
    }

    env_t get_env(source_tag) noexcept {
      return std::execution::get_env(this->get_receiver());
    }
  };
#+end_src

Some interesting points to note with this implementation:
- There will be a separate base-class for each child operation that is stored inline
  in the parent operation for which we want to be able to use this optimisation.
- We no longer need to define our own ~receiver~ class to pass to the child sender's connect method.
  This is all handled by the ~child_operation_state~ helper.
- The use of ~inlinable_operation_state~ means that this class can avoid storing
  the parent receiver if the parent operation state includes it as a sub-object,
  and the use of ~child_operation_state~ means that the child of this operation
  can avoid storing the receiver we pass to it if it uses the ~inlinable_operation_state~
  class to manage storing (or not storing) the receiver.
  i.e. it implements the optimisation protocol both from the child-operation
  and parent-operation perspectives.
- All of the child completion signals are forwarded to methods on the operation-state, with
  signals from different children differentiated by a tag parameter.
- These methods need to be public to allow the ~manual_child_operation_state::receiver~ class
  to call them without having to declare it as a friend.
- This example just forwards through the parent environment to the child operation.
  If you wanted to modify the environment in some way (e.g. by changing the stop-token)
  then you'd need to define a separate environment class and pass that as the ~Env~ template
  argument to ~child_operation_state~ instead.

** Adding a helper for parent operation-states (optional/future)

As evidenced by the long description above, it is complicated to try to implement the
~make_receiver_for~ function needed to enable the optimisation proposed by this paper.

There are a lot of subtle details that implementations of ~make_receiver_for~ need to
get right and it's easy to accidentaly run into undefined behaviour or to creating
accidental cyclic dependencies that result in inscrutable compiler-errors.

Therefore, there is a reasonably high value in abstracting a lot of this away
for users who want to write their own sender algorithms which implement the optimisation
protocol proposed by this paper.

All users that want to implement their own sender algorithms that compose a
known set of child operations would need such a facility if they wanted their algorithm
to be able to participate in this optimisation.

However, such a facility would also be largely just an implementation detail for
sender algorithms. The majority of users of the sender/receiver framework should be just
composing those algorithms and, other than
TODO: Fix this

As long as the implementers of sender-algorithms implement the protocol proposed by
this paper in /some/ way then users will benefit from the optimisations that are
enabled by the protocol. Different libraries can use their own helper classes to
implement the protocol - we do not need to standardise

** Applying this optimisation to standard-library sender algorithms

In order for the optimisations proposed by this paper to be effective in wider code-bases,
you generally want most of the algorithms you use to opt-in to the ~inlinable_receiver~
protocols, where possible.

A sender-adapter algorithm that does not opt-into the optimisation (either as a child
or as a parent) will inhibit applying the optimisation at both the boundary with its
children and at the boundary with its parent. Thus it will result in potentially adding
two pointer-indirections in the middle of a sender expression.

So, as much as possible we want to make sure that standard-library senders all implement
this optimisation.

The proposal P2300R10, which was merged into the draft standard, includes a number of
sender factories and sender algorithms provided by the standard library.

Some of the algorithms have default implementations that are just compositions
of other algorithms and so don't need any changes.
These algorithms are:
- ~starts_on()~ - defined in terms of ~let_value()~ and ~schedule()~
- ~continues_on()~ - defined in terms of ~schedule_from()~
- ~on()~ - defined in terms of ~write-env~, ~continues_on~ an ~starts_on~.
- ~stopped_as_optional()~ - defined in terms of ~let_stopped~, ~then~ and ~just~.
- ~stopped_as_error()~ - defined in terms of ~let_stopped~, and ~just_error~.

The following algorithms are all of the algorithms which have some implementation
of a sender for the default version of the algorithm that is not just a composition
of other sender algorithms:
- ~just~
- ~just_error~
- ~just_stopped~
- ~read_env~
- ~schedule_from~
- ~then~
- ~upon_error~
- ~upon_stopped~
- ~let_value~
- ~let_error~
- ~let_stopped~
- ~bulk~
- ~split~
- ~when_all~
- ~into_variant~
- ~run_loop::run-loop-sender~

The design intent is to have each of these algorithms implement the optimization
to avoid storing the receiver if the reciever connected to it satisfies ~inlinable_receiver~.
i.e. when this sender is used as the child of another operation that stores the
child-operation as a sub-object.

Some of the above algorithms are leaf operations which do not have any children
and so do not need to implement the ~inlinable_receiver~ concept themselves.
These algorithms are: ~just~, ~just_error~, ~just_stopped~, ~read_env~, and ~run_loop::run-loop-sender~.

The algorithms that do have children and thus would need to implement the parent
operation side of the protocol are all of the other algorithms listed above.

The ~run_loop::run-loop-sender~ will need some individual rework to support omitting
storage of the parent receiver, but this should be relatively straight-forward.
The other algorithms are defined in terms of the exposition-only ~basic-operation~
and ~basic-state~ facilities and so should be able to have support added for
omitting storage of the receiver in a generic way.

There are currently some assumptions in the design of the ~impls-for<Tag>~ interface
that require the receiver object to exist for the duration of the ~basic-state~
object which will require some rework. For example, the ~get-state~ of ~schedule_from~
returns an object that holds a reference to the receiver. Similarly with ~split~'s
~get-state~ function.

Implementing the parent-side of the optimisation protocol will require changes
to move the child-operation states to be stored as base-classes rather than
as the ~basic-operation::inner-ops~ tuple-like data-member.

The ~let_value~, ~let_error~ and ~let_stopped~ algorithms all have an additional
operation-state object stored in the object returned from ~impls-for::get-state~.
This object would also need to be moved to a base-class of ~basic-operation~,
but would need to have a manual lifetime and support being any of a set of possible
operation-state types.

The ~split~ algorithm has a child operation that is a child of the ~shared-state<Sndr>~
structure. The child operation-state would need to be moved to a base-class and the
~split-receiver<Sndr>~ would need to be updated to define the ~make_receiver_for()~
static function.

All of this will need some major surgery to the specification machinery, but should
not change the semantics of any of the existing algorithms.

* Design Discussion

** Naming of ~inlinable_receiver~ concept and ~inlinable_operation_state~

The naming of the propsoed concept ~inlinable_receiver~ and ~inlinable_operation_state~
base-class for operation-states both use the ~inlinable~ adjective to indicate that this
is for operation-states which might be stored inline in their parent operation-state.

If we want to use a different name, for example because we don't want to use the term
~inlinable~ in this context, the following are some alternatives which could be considered.

Since a receiver that supports this concept is reconstructible from the operation-state address,
it could use the name ~reconstructible_receiver~ or ~reconstructible_receiver_from~, instead.

The other option is that  we make the receiver concept exposition-only and only provide
the ~inlinable_operation_state~ class as this would likely be the facility that most
people would reach for rather than constraining their own class specializations on
the concept.

With regards to naming of the ~inlinable_operation_state~ helper class, we could also
choose a name that reflects better its purpose as a holder for the receiver by naming
it ~receiver_holder_base<Op, Rcvr>~, or similar.

* Proposed Wording

** ~inlinable_receiver~ concept wording

Modify [execution.syn] as follows:

#+BEGIN_EXPORT html
<div class="wording">
<pre>
  ...
  template&lt;class Sch&gt;
    concept scheduler = <i>see below</i>;

  // [exec.recv], receivers
  struct receiver_t {};

  template&lt;class Rcvr&gt;
    concept receiver = <i>see below</i>;

  template&lt;class Rcvr, class Completions&gt;
    concept receiver_of = <i>see below</i>;
  <ins>
  template&lt;class Rcvr, class ChildOp&gt;
    concept inlinable_receiver =
      receiver&lt;Rcvr&gt; &amp;&amp;
      requires (ChildOp* child) {
        { Rcvr::make_receiver_for(child) } noexcept -> same_as&lt;Rcvr&gt;;
      };
  </ins>
  struct set_value_t { unspecified };
  struct set_error_t { unspecified };
  struct set_stopped_t { unspecified };

  inline constexpr set_value_t set_value{};
  inline constexpr set_error_t set_error{};
  inline constexpr set_stopped_t set_stopped{};

  // [exec.opstate], operation states
  struct operation_state_t {};
  ...
</pre>
</div>
#+END_EXPORT

Add the following paragraph to [exec.recv.concepts] between p1 and p2:

#+BEGIN_EXPORT html
<div class="wording" style="counter-set: paragraph 1">
<p class="numbered"><ins>The <code>inlinable_receiver</code> concept defines the requirements for a receiver that can be
reconstructed on-demand from a pointer to the operation-state object created when
the receiver was connected to a sender. Given a receiver object, <code>rcvr</code>, of type, <code>Rcvr</code>,
which was connected to a sender, producing an operation-state object, <code>op</code>, of type <code>Op</code>,
and where <code>Rcvr</code> models <code>inlinable_receiver&lt;Op></code>, then the expression,
<code>Rcvr::make_receiver_for(addressof(op))</code>, evaluates to a receiver that is equal to <code>rcvr</code>.</ins></p>
<p class="numbered"><ins><i>[Note: Such a receiver does not need to be stored as a data-member of <code>op</code> as it
can be recreated on demand - end note]</i></ins></p>
</div>
#+END_EXPORT

** Changes to /~basic-operation~/

Modify the synopsis in [exec.snd.expos] as follows:

#+begin_export html
<div class="wording" style="counter-set: paragraph 23">
<p class="numbered">
<pre>
namespace std::execution {
  template&lt;class Tag&gt;
  concept <expos>completion-tag</expos> =                                      <expos>// exposition only</expos>
    same_as&lt;Tag, set_value_t&gt; || same_as&lt;Tag, set_error_t&gt; || same_as&lt;Tag, set_stopped_t&gt;;

  template&lt;template&lt;class...&gt; class T, class... Args&gt;
  concept <expos>valid-specialization</expos> =                                <expos>// exposition only</expos>
    requires { typename T&lt;Args...&gt;; };

<ins>  template&lt;size_t Id&gt;
  using <expos>indexed-tag</expos> = integral_constant&lt;size_t, Id&gt;;            <expos>// exposition only</expos>

  template&lt;class Class, class Member&gt;
  using <expos>member-t</expos> = decltype(std::forward_like&lt;Class&gt;(declval&lt;Member&gt;()));     <expos>// exposition only</expos></ins>

<del>  struct <expos>default-impls</expos> {                                        <expos>// exposition only</expos>
    static constexpr auto <expos>get-attrs</expos> = <i>see below</i>;              <expos>// exposition only</expos>
    static constexpr auto <expos>get-env</expos> = <i>see below</i>;                <expos>// exposition only</expos>
    static constexpr auto <expos>get-state</expos> = <i>see below</i>;              <expos>// exposition only</expos>
    static constexpr auto <expos>start</expos> = <i>see below</i>;                  <expos>// exposition only</expos>
    static constexpr auto <expos>complete</expos> = <i>see below</i>;               <expos>// exposition only</expos>
  };</del>
<ins>  struct <expos>default-state-impls</expos> {
    using operation_state_concept = operation_state_t;

    template&lt;class Self&gt;
    void start(this Self& self) noexcept {
      self.<expos>start-all</expos>();
    }
    
    template&lt;class Self, class ChildTag&gt;
    constexpr decltype(auto) <expos>get-env</expos>(this Self& self, ChildTag) noexcept { <expos>// exposition only</expos>
      return get_env(self.<expos>get-receiver</expos>());
    }

    template&lt;class Self, class ChildTag, class CompletionTag, class... Datums&gt;
    constexpr void <expos>complete</expos>(this Self& self, ChildTag, CompletionTag, Datums&&... datums) noexcept { <expos>//exposition only</expos>
      CompletionTag()(std::move(self.<expos>get-receiver</expos>()), std::forward&lt;Datums&gt;(datums)...);
    }
  };

  struct <expos>default-sender-impls</expos> {   <expos>// exposition only</expos>
    template&lt;class Data, class... Children&gt;
    static constexpr decltype(auto) <expos>get-attrs</expos>(Data&amp;, Children&amp;... children) noexcept {   <expos>// exposition only</expos>
      if constexpr (sizeof...(Children) == 1) {
        return <expos>FWD-ENV</expos>(get_env(children...[0]));
      } else {
        return env<>();
      }
    }
  };
  </ins>
  
  template&lt;class Tag&gt;
  struct <expos><ins>sender-</ins>impls-for</expos> : <expos>default<ins>-sender</ins>-impls</expos> {};       <expos>// exposition only</expos>

<ins>  template&lt;class Sndr&gt;
  auto <expos>get-tag</expos>(const Sndr&amp; sndr) noexcept {        <expos>// exposition only</expos>
    auto&amp; [tag, data, ...children] = sndr;
    return tag;
  };

  template&lt;class Sndr&gt;
  decltype(auto) <expos>get-data</expos>(Sndr&amp;&amp; sndr) noexcept {        <expos>// exposition only</expos>
    auto&amp; [tag, data, ...children] = sndr;
    return std::forward_like&lt;Sndr&gt;(data);
  };

  template&lt;size_t I, class Sndr&gt;
  decltype(auto) <expos>get-child</expos>(Sndr&amp;&amp; sndr) noexcept {        <expos>// exposition only</expos>
    auto&amp; [tag, data, ...children] = sndr;
    return std::forward_like&lt;Sndr&gt;(children...[I]);
  }

  template&lt;class Sndr&gt;
  using <expos>tag-type</expos> = decltype(<expos>get-tag</expos>(declval&lt;Sndr&gt()));     <expos>// exposition only</expos>

  template&lt;class Sndr&gt;
  using <expos>data-type</expos> = decltype(<expos>get-data</expos>(declval&lt;Sndr&gt()));   <expos>// exposition only</expos>

  template&tl;size_t I, class Sndr&gt;
  using <expos>child-type</expos> = decltype(<expos>get-child</expos>&lt;I&gt;(declval&lt;Sndr&gt;());   <expos>// exposition only</expos>
  
  template&lt;T&gt;
  inline constexpr bool <expos>is-nothrow-decay-copyable-v</expos> =      <expos>// exposition only</expos>
      is_nothrow_constructible_v&lt;decay_t&lt;T&gt;, T&gt;;

  template&lt;class Sndr, class Rcvr&gt;
  inline constexpr bool <expos>is-nothrow-connectable-v</expos> =         <expos>// exposition only</expos>
      noexcept(execution::connect(declval&lt;Sndr&gt;(), declval&lt;Rcvr&gt;()));
  </ins>

<del>  template&lt;class Sndr, class Rcvr&gt;                              <expos>// exposition only</expos>
  using <expos>state-type</expos> = decay_t&lt;<expos>call-result-t</expos>&lt;
    decltype(<expos>impls-for</expos>&lt;tag_of_t&lt;Sndr&gt;&gt;::<expos>get-state</expos>), Sndr, Rcvr&amp;&gt;&gt;;

  template&lt;class Index, class Sndr, class Rcvr&gt;                 <expos>// exposition only</expos>
  using <expos>env-type</expos> = <expos>call-result-t</expos>&lt;
    decltype(<expos>impls-for</expos>&lt;tag_of_t&lt;Sndr&gt;&gt;::<expos>get-env</expos>), Index,
    <expos>state-type</expos>&lt;Sndr, Rcvr&gt;&amp;, const Rcvr&amp;&gt;;

  template&lt;class Sndr, size_t I = 0&gt;
  using <expos>child-type</expos> = decltype(declval&lt;Sndr&gt;().template get&lt;I+2&gt;());     <expos>// exposition only</expos>

  template&lt;class Sndr&gt;
  using <expos>indices-for</expos> = remove_reference_t&lt;Sndr&gt;::<expos>indices-for</expos>;           <expos>// exposition only</expos>

  template&lt;class Sndr, class Rcvr&gt;
  struct <expos>basic-state</expos> {                                          <expos>// exposition only</expos>
    <expos>basic-state</expos>(Sndr&amp;&amp; sndr, Rcvr&amp;&amp; rcvr) noexcept(see below)
      : <expos>rcvr</expos>(std::move(rcvr))
      , <expos>state</expos>(<expos>impls-for</expos>&lt;tag_of_t&lt;Sndr&gt;&gt;::<expos>get-state</expos>(std::forward&lt;Sndr&gt;(sndr), <expos>rcvr</expos>)) { }

    Rcvr <expos>rcvr</expos>;                                                  <expos>// exposition only</expos>
    <expos>state-type</expos>&lt;Sndr, Rcvr&gt; <expos>state</expos>;                               <expos>// exposition only</expos>
  };

  template&lt;class Sndr, class Rcvr, class Index&gt;
    requires <expos>valid-specialization</expos>&lt;env-type, Index, Sndr, Rcvr&gt;
  struct <expos>basic-receiver</expos> {                                       <expos>// exposition only</expos>
    using receiver_concept = receiver_t;

    using <expos>tag-t</expos> = tag_of_t&lt;Sndr&gt;;                               <expos>// exposition only</expos>
    using <expos>state-t</expos> = <expos>state-type</expos>&lt;Sndr, Rcvr&gt;;                     <expos>// exposition only</expos>
    static constexpr const auto&amp; <expos>complete</expos> = <expos>impls-for</expos>&lt;<expos>tag-t</expos>&gt;::<expos>complete</expos>;   <expos>// exposition only</expos>

    template&lt;class... Args&gt;
      requires <expos>callable</expos>&lt;decltype(<expos>complete</expos>), Index, <expos>state-t</expos>&amp;, Rcvr&amp;, set_value_t, Args...&gt;
    void set_value(Args&amp;&amp;... args) &amp;&amp; noexcept {
      <expos>complete</expos>(Index(), <expos>op</expos>-&gt;<expos>state</expos>, <expos>op</expos>-&gt;<expos>rcvr</expos>, set_value_t(), std::forward&lt;Args&gt;(args)...);
    }

    template&lt;class Error&gt;
      requires <expos>callable</expos>&lt;decltype(<expos>complete</expos>), Index, <expos>state-t</expos>&amp;, Rcvr&amp;, set_error_t, Error&gt;
    void set_error(Error&amp;&amp; err) &amp;&amp; noexcept {
      <expos>complete</expos>(Index(), <expos>op</expos>-&gt;<expos>state</expos>, <expos>op</expos>-&gt;<expos>rcvr</expos>, set_error_t(), std::forward&lt;Error&gt;(err));
    }

    void set_stopped() &amp;&amp; noexcept
      requires <expos>callable</expos>&lt;decltype(<expos>complete</expos>), Index, <expos>state-t</expos>&amp;, Rcvr&amp;, set_stopped_t&gt; {
      <expos>complete</expos>(Index(), <expos>op</expos>-&gt;<expos>state</expos>, <expos>op</expos>-&gt;<expos>rcvr</expos>, set_stopped_t());
    }

    auto get_env() const noexcept -&gt; <expos>env-type</expos>&lt;Index, Sndr, Rcvr&gt; {
      return <expos>impls-for</expos>&lt;<expos>tag-t</expos>&gt;::<expos>get-env</expos>(Index(), <expos>op</expos>-&gt;<expos>state</expos>, <expos>op</expos>-&gt;<expos>rcvr</expos>);
    }

    <expos>basic-state</expos>&lt;Sndr, Rcvr&gt;* <expos>op</expos>;                           <expos>// exposition only</expos>
  };

  constexpr auto <expos>connect-all</expos> = <i>see below</i>;                         <expos>// exposition only</expos>

  template&lt;class Sndr, class Rcvr&gt;
  using <expos>connect-all-result</expos> = <expos>call-result-t</expos>&lt;                     <expos>// exposition only</expos>
    decltype(<expos>connect-all</expos>), <expos>basic-state</expos>&lt;Sndr, Rcvr&gt;*, Sndr, <expos>indices-for</expos>&lt;Sndr&gt;&gt;;</del>

<ins>  template&lt;class Op, class Rcvr&gt;
  struct <expos>inlinable-operation-state</expos> {      <expos>// exposition only</expos>
    explicit <expos>inlinable-operation-state</expos>(Rcvr&& r) noexcept(is_nothrow_move_constructible_v&lt;Rcvr&gt;)
      : <expos>rcvr</expos>(std::move(r))
    {}

    Rcvr& <expos>get-receiver</expos>() noexcept { return rcvr; }      <expos>// exposition only</expos>

    Rcvr <expos>rcvr</expos>;   <expos>// exposition only</expos>
  };

  template&lt;class Op, class Rcvr&gt;
    requires inlinable_receiver&lt;Rcvr, Op&gt;
  struct <expos>inlinable-operation-state</expos>&lt;Op, Rcvr&gt; {    <expos>// exposition only</expos>
    explicit <expos>inlinable-operation-state</expos>(Rcvr&&) noexcept {}

    Rcvr <expos>get-receiver</expos>() noexcept {    <expos>// exposition only</expos>
      return Rcvr::make_receiver_for(static_cast<Op*>(this));
    }
  };

  template&lt;class ParentOp, class ChildTag, class ChildEnv, class ChildSndr&gt;
  class <expos>manual-child-operation</expos> {       <expos>// exposition only</expos>
    struct <expos>child-receiver</expos> {         <expos>// exposition only</expos>
      using receiver_concept = receiver_t;

      template&lt;class ChildOp&gt;
      static <expos>child-receiver</expos> make_receiver_for(ChildOp* child) noexcept {
        auto* parent = static_cast&lt;ParentOp*&gt;(
                         reinterpret_cast&lt;<expos>manual-child-operation</expos>*&gt(
                           reinterpret_cast&lt;<expos>storage-t</expos>*&gt;(child)));
        return <expos>child-receiver</expos>{parent};
      }

      ChildEnv get_env() const noexcept {
        return <expos>parent</expos>-&gt;<expos>get-env</expos>(ChildTag{});
      }

      template&lt;class... Vs&gt;
      void set_value(Vs&amp;&amp;... vs) && noexcept {
        <expos>parent</expos>-&gt;<expos>complete</expos>(ChildTag{}, set_value_t{}, std::forward&lt;Vs&gt;(vs)...);
      }

      template&lt;class E&gt;
      void set_error(E&amp;&amp; e) && noexcept {
        <expos>parent</expos>-&gt;<expos>complete</expos>(ChildTag{}, set_error_t{}, std::forward&lt;E&gt;(e));
      }

      void set_stopped() && noexcept {
        <expos>parent</expos>-&gt;<expos>complete</expos>(ChildTag{}, set_stopped_t{});
      }

    private:
      friend <expos>manual-child-operation</expos>;

      explicit <expos>child-receiver</expos>(ParentOp* p) noexcept   <expos>// exposition only</expos>
      : <expos>parent</expos>(p) {}

      ParentOp* <expos>parent</expos>;      <expos>// exposition only</expos>
    };

    using <expos>child-op</expos> = connect_result_t&lt;ChildSndr, <expos>child-receiver</expos>&gt;; <expos>//exposition only</expos>

  protected:
    <expos>manual-child-operation</expos>() noexcept {} <expos>// exposition only</expos>
    ~<expos>manual-child-operation</expos>() {}         <expos>// exposition only</expos>

  public:
    using <expos>is-nothrow-connectable</expos> =     <expos>// exposition only</expos>
        <expos>is-nothrow-connectable-v&lt;ChildSndr, <expos>child-receiver</expos>&gt;

    void <expos>start-child</expos>() noexcept { <expos>// exposition only</expos>
      execution::start(this-&gt;<expos>get</expos>());
    }

    void <expos>construct</expos>(ChildSndr&amp;&amp; child) noexcept { <expos>// exposition only</expos>
      ::new (static_cast<void*>(addressof(<expos>storage</expos>))) <expos>child-op</expos>(
        execution::connect(std::forward&lt;ChildSndr&gt;(child),
                           <expos>child-receiver</expos>(static_cast&lt;ParentOp*&gt;(this))));
    }

    void <expos>destruct</expos>() noexcept { <expos>// exposition only</expos>
      this-&gt;<expos>get</expos>().~<expos>child-op</expos>();
    }

  private:
    <expos>child-op</expos>&amp; <expos>get</expos>() noexcept {  <expos>// exposition only</expos>
      return *launder(reinterpret_cast&lt;<expos>child-op</expos>*&gt;(addressof(<expos>storage</expos>)));
    }

    using <expos>storage-t</expos> =     <expos>// exposition only</expos>
      conditional_t&lt;
        is_empty_v&lt;<expos>child-op</expos>&gt; &amp;&amp; is_standard_layout_v&lt;<expos>child-op</expos>&gt;,
        <expos>child-op</expos>,
        unsigned char[sizeof(<expos>child-op</expos>)]&gt;;

    union {
      alignas(<expos>child-op</expos>) <expos>storage-t</expos> <expos>storage</expos>;  <expos>// exposition only</expos>
    };
  };

  template&lt;class ParentOp, class ChildTag, class ChildEnv, class ChildSndr&gt;
  class <expos>child-operation</expos>        <expos>// exposition only</expos>
      : public <expos>manual-child-operation</expos>&lt;ParentOp, ChildTag, ChildEnv, ChildSndr&gt; {
    using <expos>base-t</expos> = <expos>manual-child-operation</expos>&lt;ParentOp, ChildTag, ChildEnv, ChildSndr&gt;

  protected:
    explicit <expos>child-operation</expos>(ChildSndr&amp;&amp; child)    <expos>// exposition only</expos>
        noexcept(<expos>base-t</expos>::<expos>is-nothrow-connectable</expos>) {
      <expos>base-t</expos>::<expos>construct</expos>(std::forward&lt;ChildSndr&gt;(child));
    }

    ~<expos>child-operation</expos>() {   <expos>// exposition only</expos>
      <expos>base-t</expos>::<expos>destruct</expos>();
    }
  };

  template&lt;
    class ParentOp,
    class ParentEnv,
    template&lt;class, size_t&gt; class ChildEnv,
    class Indices,
    class... Child&gt;
  class <expos>child-operations</expos>;    <expos>// exposition only</expos>

  template&lt;
    class ParentOp,
    class ParentEnv,
    template&lt;class, size_t&gt; class ChildEnv,
    size_t... Indices,
    class... Child&gt;
  class <expos>child-operations</expos>&lt;ParentOp, ParentEnv, ChildEnv, index_sequence&lt;Indices...&gt;, Child&gt;   <expos>// exposition only</expos>
    : public <expos>child-operation</expos>&lt;ParentOp, <expos>indexed-tag</expos>&lt;Indices&gt;, ChildEnv&lt;ParentEnv, Indicies&gt;, Child&gt;... {
  protected:
    template&lt;size_t Id&gt;
      using <expos>child-t</expos> =    <expos>//exposition only</expos>
        <expos>child-operation</expos>&lt;ParentOp, <expos>indexed-tag</expos>&lt;Id&gt;, ChildEnv&lt;ParentEnv, Id&gt;, Child...[Id]&gt;

    explicit <expos>child-operations</expos>(Child&amp;&amp;... child)  <expos>// exposition only</expos>
      noexcept((is_nothrow_constructible_v&lt;<expos>child-t</expos>&lt;Indices&gt;, Child...[Indices]&gt; &amp;&amp; ...))
      : <expos>child-t</expos>&lt;Indices&gt;(std::forward&lt;Child&gt;(child))...
    {}

    void <expos>start-all</expos>() noexcept {     <expos>// exposition only</expos>
      (<expos>child-t</expos>&lt;Indices&gt;::<expos>start-child</expos>(), ...);
    }
  };

  template&lt;
    class ParentOp,
    template&lt;size_t&gt; class childTag,
    class Env,
    class... Child&gt;
  class <expos>manual-child-operation-variant</expos> {   <expos>// exposition only</expos>
    template&lt;size_t Index&gt;
    class <expos>child-receiver</expos> {
    public:
      using receiver_concept = receiver_t;

      template&lt;class ChildOp&gt;
      static <expos>child-receiver</expos> make_receiver_for(ChildOp* child) noexcept {
        auto* parent = static_cast&lt;ParentOp*&gt;(
          reinterpret_cast&lt;<expos>manual-child-operation-variant</expos>*&gt;(
            reinterpret_cast&lt;<expos>storage-t</expos>(child)));
        return <expos>child-receiver</expos>(parent);
      }

      Env get_env() const noexcept {
        return <expos>parent</expos>-&gt;<expos>get-env</expos>(ChildTag&lt;Index&gt;{});
      }

      template&lt;class... Vs&gt;
      void set_value(Vs&amp;&amp;... vs) noexcept {
        <expos>parent</expos>-&gt;<expos>complete</expos>(ChildTag&lt;Index&gt;(), set_value_t(), std::forward&lt;Vs&gt;(vs)...);
      }

      template&lt;class E&gt;
      void set_error(E&amp;&amp; e) noexcept {
        <expos>parent</expos>-&gt;<expos>complete</expos>(ChildTag&lt;Index&gt;(), set_error_t(), std::forward&lt;E&gt;(e));
      }

      void set_stopped() noexcept {
        <expos>parent</expos>-&gt;<expos>complete</expos>(ChildTag&lt;Index&gt;(), set_stopped_t());
      }

    private:
      friend <expos>manual-child-operation-variant</expos>;
      explicit <expos>child-receiver</expos>(ParentOp* p) noexcept <expos>// exposition only</expos>
      : <expos>parent</expos>(p) {}

      ParentOp* <expos>parent</expos>;    <expos>// exposition only</expos>
    };

    template&lt;size_t Index&gt;
    using <expos>child-op-t</expos> =    <expos>// exposition only</expos>
      connect_result_t&lt;Child...[Index], <expos>child-receiver</expos>&lt;Index&gt;&gt;;
    
  protected:
    template&lt;class C&gt;
    static consteval size_t <expos>index-of</expos>() noexcept {    <expos>// exposition only</expos>
      constexpr bool matches[sizeof...(Child)] = {same_as<C, Child>...};
      for (size_t i = 0; i < sizeof...(Child); ++i) {
        if (matches([i]) return i;
      }
      unreachable();
    }

    template&lt;size_t Index&gt;
    static constexpr bool <expos>is-nothrow-connectable</expos> =    <expos>// exposition only</expos>
      <expos>is-nothrow-connectable-v</expos>&lt;Child...[Index], <expos>child-receiver</expos>&lt;Index&gt;&gt;;

    <expos>manual-child-operation-variant</expos>() noexcept {}  <expos>// exposition only</expos>
    ~<expos>manual-child-operation-variant</expos>() {}

    template&lt;size_t Index&gt;
    void <expos>start-child</expos>() & noexcept {    <expos>// exposition only</expos>
      execution::start(<expos>get-op</expos>&lt;Index&gt;());
    }

    template&lt;size_t Index&gt;
    void <expos>construct</expos>(Child...[Index]&& child)
      noexcept(<expos>is-nothrow-connectable</expos>&lt;[Index]&gt;) {
      ParentOp* parent = static_cast&lt;ParentOp*&gt;(this);
      ::new (static_cast&lt;void*&gt;(addressof(<expos>storage</expos>)))
        <expos>child-op-t</expos>&lt;Index&gt;(execution::connect(
          std::forward&lt;Child&gt;(child),
          <expos>child-receiver</expos>&lt;Index&gt;(parent)));
    }

    template&lt;size_t Index&gt;
    void <expos>destruct</expos>() noexcept {   <expos>// exposition only</expos>
      <expos>get-op</expos>&lt;Index&gt;().~<expos>child-op-t</expos>&lt;Index&gt;();
    }

    template&lt;size_t Index&gt;
    <expos>child-op-t</expos>&lt;Index&gt; <expos>get-op</expos>() & noexcept {  <expos>// exposition only</expos>
      return *std::launder(
        reinterpret_cast&lt;<expos>child-op-t</expos>&lt;Index&gt;*&gt;(addressof(<expos>storage</expos>)));
    }

    static constexpr size_t <expos>max-size</expos> =  <expos>// exposition only</expos>
      []&lt;size_t... Ids&gt;(index_sequence&lt;Ids...&gt;) {
        size_t result = 0;
        ((result = std::max(result, sizeof(<expos>child-op-t</expos>&lt;Ids&gt;))), ...);
        return result;
      }(std::index_sequence_for&lt;Child...&gt;{});

    static constexpr size_t <expos>max-align</expos> =   <expos>// exposition only</expos>
      []&lt;size_t... Ids&gt;(index_sequence&lt;Ids...&gt;) {
        size_t result = 0;
        ((result = std::max(result, sizeof(<expos>child-op-t</expos>&lt;Ids&gt;))), ...);
        return result;
      }(std::index_sqeuence_for&lt;Child...&gt;{});

    using <expos>storage-t</expos> = std::byte[<expos>max-size</expos>];  <expos>// exposition only</expos>
    alignas(<expos>max-align</expos>) <expos>storage-t</expos> <expos>storage</expos>;   <expos>// exposition only</expos>
  };</ins>
  
  template&lt;class <ins>Tag</ins><del>Sndr</del>, class Rcvr<ins>, class Data, class... Children</ins>&gt;
    <del>requires <expos>valid-specialization</expos>&lt;<expos>state-type</expos>, Sndr, Rcvr&gt; &amp;&amp;
             <expos>valid-specialization</expos>&lt;<expos>connect-all-result</expos>, Sndr, Rcvr&gt;</del>
  struct <expos>basic-operation</expos><del> : <expos>basic-state</expos>&lt;Sndr, Rcvr&gt; {</del><ins>;</ins>                <expos>// exposition only</expos>
<del>    using operation_state_concept = operation_state_t;
    using <expos>tag-t</expos> = tag_of_t&lt;Sndr&gt;;                               <expos>// exposition only</expos>

    <expos>connect-all-result</expos>&lt;Sndr, Rcvr&gt; <expos>inner-ops</expos>;              <expos>// exposition only</expos>

    <expos>basic-operation</expos>(Sndr&amp;&amp; sndr, Rcvr&amp;&amp; rcvr) noexcept(<i>see below</i>)  <expos>// exposition only</expos>
      : <expos>basic-state</expos>&lt;Sndr, Rcvr&gt;(std::forward&lt;Sndr&gt;(sndr), std::move(rcvr)),
        <expos>inner-ops</expos>(<expos>connect-all</expos>(this, std::forward&lt;Sndr&gt;(sndr), <expos>indices-for</expos>&lt;Sndr&gt;()))
    {}

    void start() &amp; noexcept {
      auto&amp; [...ops] = <expos>inner-ops</expos>;
      <expos>impls-for</expos>&lt;<expos>tag-t</expos>&gt;::<expos>start</expos>(this-&gt;<expos>state</expos>, this-&gt;<expos>rcvr</expos>, ops...);
    }
  };</del>

  template&lt;class Sndr, class Env&gt;
  using <expos>completion-signatures-for</expos> = <i>see below</i>;                   <expos>// exposition only</expos>

  template&lt;class Tag, class Data, class... Child&gt;
  struct <expos>basic-sender</expos> : <expos>product-type</expos>&lt;Tag, Data, Child...&gt; {    <expos>// exposition only</expos>
    using sender_concept = sender_t;
    <del>using <expos>indices-for</expos> = index_sequence_for&lt;Child...&gt;;       <expos>// exposition only</expos></del>

    decltype(auto) get_env() const noexcept {
      auto&amp; [_, data, ...child] = *this;
      return <expos><ins>sender-</ins>impls-for</expos>&lt;Tag&gt;::<expos>get-attrs</expos>(data, child...);
    }

    template&lt;<expos>decays-to</expos>&lt;<expos>basic-sender</expos>&gt; Self, receiver Rcvr&gt;
    auto connect(this Self&amp;&amp; self, Rcvr rcvr) noexcept(<i>see below</i>)
      -&gt; <expos>basic-operation</expos>&lt;<del>Self</del><ins>Tag</ins>, Rcvr<ins>, <expos>state-type</expos>&lt;Self&gt;, <expos>data-type</expos>&lt;Self&gt;, <expos>member-t</expos>&lt;Self, Child&gt;...</ins>&gt; {
      <del>return {std::forward&lt;Self&gt;(self), std::move(rcvr)};</del>
      <ins>auto& [tag, data, ...child] = self;
      return {std::move(rcvr), std::forward_like&lt;Self&gt;(data), std::forward_like&lt;Self&gt;(child)...};</ins>
    }

    template&lt;<expos>decays-to</expos>&lt;<expos>basic-sender</expos>&gt; Self, class Env&gt;
    auto get_completion_signatures(this Self&amp;&amp; self, Env&amp;&amp; env) noexcept
      -&gt; <expos>completion-signatures-for</expos>&lt;Self, Env&gt; {
      return {};
    }
  };
}
</pre>
</p>
</div>
#+end_export

Strike paragraphs 28 through 32 from [exec.snd.expos]:

#+BEGIN_EXPORT html
<div class="wording" style="counter-set: paragraph 27">
<p class="numbered"><del>The expression in the <code>noexcept</code> clause of the constructor of <code><expos>basic-state</expos></code> is</del>
<pre>
<del>is_nothrow_move_constructible&lt;Rcvr&gt; &amp;&amp;
<expos>nothrow-callable</expos>&lt;decltype(<expos>impls-for</expos>&lt;tag_of_of&lt;Sndr&gt;&gt;::<expos>get-state</expos>), Sndr, Rcvr&amp;&gt; &amp;&amp;
(same_as&lt;<expos>state-type&lt;Sndr, Rcvr&gt;, <expos>get-state-result</expos>&gt; ||
 is_nothrow_constructible_v&lt;<expos>state-type</expos>&lt;Sndr, Rcvr&gt;, <expos>get-state-result</expos>&gt;)</del>
</pre>
<del>where <code><expos>get-state-result</expos></code> is</del>
<pre>
<del><expos>call-result-t</expos>&lt;decltype(<expos>impls-for</expos>&lt;tag_of_t&lt;Sndr&gt;&gt;::<expos>get-state</expos>), Sndr, Rcvr&amp;&gt;</del>
</pre><del>.</del>
</p>
<p class="numbered">
<del>The object <code><expos>connect-all</expos></code> is initialized with a callable object equivalent to the following lambda:</del>
<pre>
<del>[]&lt;class Sndr, class Rcvr, size_t... Is&gt;(
  <expos>basic-state</expos>&lt;Sndr, Rcvr&gt;* op, Sndr&amp;&amp; sndr, index_sequence&lt;Is...&gt;) noexcept(<i>see below</i>)
    -&gt; decltype(auto) {
    auto&amp; [_, data, ...child] = sndr;
    return <expos>product-type</expos>{connect(
      std::forward_like&lt;Sndr&gt;(child),
      <expos>basic-receiver</expos>&lt;Sndr, Rcvr, integral_constant&lt;size_t, Is&gt;&gt;{op})...};
  }</del>
</pre>
</p>
<p class="numbered">
<del><i>Constraints</i>: The express in the <code>return</code> statement is well-formed.</del>
</p>
<p class="numbered">
<del><i>Remarks</i>: The expression in the <code>noexcept</code> clause is <code>true</code> if the <code>return</code> statement is not potentially throwing; otherwise, <code>false</code>.</del>
</p>
<p class="numbered">
<del>The expression in the <code>noexcept</code> clause of the constructor of <code><expos>basic-operation</expos></code> is:</del>
<pre>
<del>is_nothrow_constructible_v&lt;<expos>basic-state</expos>&lt;Self, Rcvr&gt;, Self, Rcvr&gt; &amp;&amp;
noexcept(<expos>connect-all</expos>(this, std::forward&lt;Sndr&gt;(sndr), <expos>indices-for</expos>&lt;Sndr&gt;()))</del>
</pre>
</p>
</div>
#+END_EXPORT

Modify paragraph 33 from [exec.snd.expos] as follows:

#+BEGIN_EXPORT html
<div class="wording" style="counter-set: paragraph 32">
<p class="numbered">
The expression in the <code>noexcept</code> clause of the <code>connect</code> member function of <code><expos>basic-sender</expos></code> is:
<pre>
is_nothrow_constructible_v&lt;basic-operation&lt;<del>Self</del><ins>Tag</ins>, Rcvr<ins>, Data, Child...</ins>&gt;, <del>Self, </del>Rcvr<ins>, <expos>member-t</expos>&lt;Self, Data&gt;, <expos>member-t</expos>&lt;Self, Child&gt;...&gt;
</pre>
</p>
</div>
#+END_EXPORT


Strike paragraphs 34 through 38 from [exec.snd.expos]:

#+BEGIN_EXPORT html
<div class="wording" style="counter-set: paragraph 33">

<p class="numbered">
<del>The member <code><expos>default-impls</expos>::<expos>get-attrs</expos></code> is initialized with a callable object equivalent to the following
lambda:</del>
<pre><del>[](const auto&, const auto&... child) noexcept -> decltype(auto) {
  if constexpr (sizeof...(child) == 1)
    return (<expos>FWD-ENV</expos>(get_env(child)), ...);
  else
    return env<>();
}
</del></pre>
</p>

<p class="numbered">
<del>The member <code><expos>default-impls</expos>::<expos>get-env</expos></code> is initialized with a callable object equivalent to the following
lambda:</del>
<pre><del>[](auto, auto&, const auto& rcvr) noexcept -> decltype(auto) {
  return <expos>FWD-ENV</expos>(get_env(rcvr));
}</del></pre>
</p>

<p class="numbered">
<del>The member <code><expos>default-impls</expos>::<expos>get-state</expos></code> is initialized with a callable object equivalent to the following
lambda:</del>
<pre><del>[]<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept -> decltype(auto) {
  auto& [_, data, ...child] = sndr;
  return std::forward_like&lt;Sndr&gt;(data);
}</del></pre></p>

<p class="numbered">
<del>The member <code><expos>default-impls</expos>::<expos>start</expos></code> is initialized with a callable object equivalent to the following lambda:</del>
<pre><del>[](auto&, auto&, auto&... ops) noexcept -> void {
  (execution::start(ops), ...);
}</del></pre></p>

<p class="numbered">
<del>The member <code><expos>default-impls</expos>::<expos>complete</expos></code> is initialized with a callable object equivalent to the following
lambda:</del>
<pre><del>[]&lt;class Index, class Rcvr, class Tag, class... Args&gt;(
  Index, auto& state, Rcvr& rcvr, Tag, Args&&... args) noexcept
  -> void requires <expos>callable</expos>&lt;Tag, Rcvr, Args...&gt; {
  static_assert(Index::value == 0);
  Tag()(std::move(rcvr), std::forward&lt;Args&gt;(args)...);
}</del></pre></p>

</div>
#+END_EXPORT

**TODO: Modify definition of /~write-env~/ to use the new facilities**

** Changes to /~just~/, /~just_error~/, and /~just_stopped~/

Modify [exec.just] p2 as follows:

#+BEGIN_EXPORT html
<div class="wording" style="counter-set: paragraph 1">

<p class="numbered">
The names <code>just</code>, <code>just_error</code>, and <code>just_stopped</code> denote customization point objects.
Let <code><expos>just-cpo</expos></code> be one of <code>just</code>, <code>just_error</code> or <code>just_stopped</code>.
For a pack of subexpressions, <code>ts</code>, let <code>Ts</code> be the pack of types <code>decltype((ts))</code>.
The expression <code><expos>just-cpo</expos>(ts...)</code> is ill-formed if:
<ul>
<li><code>(<expos>movable-value</expos>&lt;Ts&gt; &amp;&amp;...)</code> is <code>false</code>, or</li>
<li><code><expos>just-cpo</expos></code> is <code>just_error</code> and <code>sizeof...(ts) == 1</code> is <code>false</code>, or</li>
<li><code><expos>just-cpo</expos></code> is <code>just_stopped</code> and <code>sizeof...(ts) ==  0</code> is <code>false</code>.</li>
</ul>
Otherwise, it is expression-equivalent to <code><expos>make-sender</expos>(<expos>just-cpo</expos>, <expos>product-type</expos>{ts...})</code>.<br>
For <code>just</code>, <code>just_error</code>, and <code>just_stopped</code>, let <code><expos>set-cpo</expos></code> be <code>set_value</code>, <code>set_error</code>,
and <code>set_stopped</code>, respectively. The exposition-only class template
<code><del><expos>impls-for</expos></del><ins><expos>basic-operation</expos></ins></code>
(33.9.1) is specialized for <code><expos>just-cpo</expos></code> as follows:

<pre>namespace std::execution {

<del>template&lt;&gt;
struct <expos>impls-for</expos>&lt;<expos>decayed-typeof</expos>&lt;<expos>just-cpo</expos>&gt;&gt; : <expos>default-impls</expos> {
  static constexpr auto start =
    [](auto& state, auto& rcvr) noexcept -&gt; void {
      auto& [...ts] = state;
      <expos>set-cpo</expos>(std::move(rcvr), std::move(ts)...);
    };
};</del>

<ins>template&lt;typename Rcvr, typename Values&gt;
struct <expos>basic-operation</expos>&lt;<expos>just-cpo</expos>, Rcvr, Values&gt;  <expos>// exposition only</expos>
: <expos>default-state-impls</expos>
, <expos>inlinable-operation-state</expos>&lt;<expos>basic-operation</expos>&lt;just-cpo, Rcvr, Values&gt;, Rcvr&gt; {

  Values <expos>values</expos>;    <expos>// exposition only</expos>

  template&lt;class Values2&gt;
  <expos>basic-operation</expos>(Rcvr r, Values2&amp;&amp; vs)   <expos>// exposition only</expos>
  : inlinable_operation_state&lt;<expos>basic-operation</expos>, Rcvr&gt;(std::move(r))
  , <expos>values</expos>(std::forward<Values2>(vs))
  {}

  void start() &amp; noexcept {
    auto&amp; [...vs] = <expos>values</expos>;
    <expos>set-cpo</expos>(std::move(this-&gt;<expos>get-receiver</expos>()), std::move(vs)...);
  }
};</ins>

}</pre>
</div>
#+END_EXPORT

** Changes to /~read_env~/

Modify [exec.read.env] p3 as follows:

#+BEGIN_EXPORT html
<div class="wording" style="counter-set: paragraph 2">
<p class="numbered">
The exposition-only class template <code><expos><del>impls-for</del><ins>basic-operation</ins></expos></code> ([exec.snd.general]) is specialized for <code>read_env</code> as follows:
<pre><del>template<>
struct <expos>impls-for</expos>&lt;<expos>decayed-typeof</expos>&lt;read_env&gt;&gt; : <expos>default-impls</expos> {
  static constexpr auto start =
    [](auto query, auto& rcvr) noexcept -> void {
      TRY-SET-VALUE (rcvr, query(get_env(rcvr)));
    };  
};</del>
<ins>template<class Rcvr, class Query>
struct <expos>basic-operation</expos>&lt;<expos>decayed-typeof</expos>&lt;read_env&gt;, Rcvr, Query&gt;
: <expos>default-state-impls</expos>
, <expos>inlinable-operation-state</expos>&lt;<expos>basic-operation</expos>&lt;<expos>decayed-typeof</expos>&lt;read_env&gt;, Rcvr, Query&gt;, Rcvr&gt; {
  decay_t&lt;Query&gt; <expos>query</expos>;  <expos>// exposition only</expos>

  <expos>basic-operation</expos>(Rcvr r, Query q) noexcept(is_nothrow_move_constructible_v&lt;Rcvr&gt;)
  : <expos>inlinable-operation-state</expos>&lt;<expos>basic-operation</expos>, Rcvr&gt;(std::move(r))
  , <expos>query</expos>(std::forward&lt;Query&gt;(q))
  {}

  void start() & noexcept {
    decltype(auto) rcvr = this-&gt;<expos>get-receiver</expos>();
    <expos>TRY-SET-VALUE</expos>(rcvr, <expos>query</expos>(get_env(rcvr)));
  }
};
</ins>
</pre>
</div>
#+END_EXPORT

** Changes to /~schedule_from~/ :noexport:

Modify [exec.schedule.from] p4 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The exposition-only class template<ins>s</ins> <ins>sender-</ins>impls-for and <ins>state-impls-for</ins>
(33.9.1) <del>is</del><ins>are</ins> specialized for schedule_from_t as follows:

<pre>namespace std::execution {
  template<>
  struct <ins>sender-</ins>impls-for <schedule_from_t> : default-<ins>sender-</ins>impls {
    <del>static constexpr auto get-attrs = see below ;
    static constexpr auto get-state = see below ;
    static constexpr auto complete = see below ;</del>
    <ins>template<class Data, class... Children>
    static decltype(auto) get-attrs(const Data& data,
                                    const Children&... children) noexcept; // exposition only
    template<class Self, class Rcvr>
    auto get-state(this Self&& s, Rcvr&& rcvr) noexcept; // exposition only</ins>
  };
  <ins>template<>
  struct state-impls-for <schedule_from_t> : default-state-impls {
    template&lt;class Self, size_t Id, class CompletionTag, class... Datums&gt;
      constexpr void complete(this Self& self, indexed-tag&lt;Id&gt;,
        CompletionTag, Datums&&... datums) noexcept;
  };</ins>
}</pre>
</div>
#+END_EXPORT

Modify [exec.schedule.from] p5 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>sender-</ins>impls-for&lt;schedule_from_t&gt;::get-attrs is <del>initialized with a callable object</del> equivalent to
the following <del>lambda</del>:

<pre><del>[](const auto& data, const auto& child) noexcept -> decltype(auto) {</del>
return JOIN-ENV(SCHED-ATTRS(data), FWD-ENV(get_env(children...[0])));
<del>}</del></pre>
</div>
#+END_EXPORT

Modify [exec.schedule.from] p6 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>sender-</ins>impls-for<schedule_from_t>::get-state is <del>initialized with a callable object</del> equivalent to
the following<del> lambda</del>:

<pre><del>[]&lt;class Sndr, class Rcvr&gt;(Sndr&& sndr, Rcvr& rcvr) noexcept(see below )
    requires sender_in&lt;child-type&lt;Sndr&gt;, env_of_t&lt;Rcvr&gt;&gt; {
  auto& [_, sch, child] = sndr;
  using sched_t = decltype(auto(sch));
  using variant_t = see below ;
  using receiver_t = see below ;
  using operation_t = connect_result_t&lt;schedule_result_t&lt;sched_t&gt;, receiver_t&gt;;
  constexpr bool nothrow = noexcept(connect(schedule(sch), receiver_t{nullptr}));
  struct state-type {
    Rcvr& rcvr ; // exposition only
    variant_t async-result ; // exposition only
    operation_t op-state ; // exposition only
    explicit state-type (sched_t sch, Rcvr& rcvr) noexcept(nothrow)
      : rcvr (rcvr), op-state (connect(schedule(sch), receiver_t{this})) {}
  };
  return state-type {sch, rcvr};
}</del>
<ins>auto& [_, sch, child] = sndr;
using sched_t = decltype(auto(sch));
using variant_t = see below ;
using receiver_t = see below ;
using operation_t = connect_result_t&lt;schedule_result_t&lt;sched_t&gt;, receiver_t&gt;;
constexpr bool nothrow = noexcept(connect(schedule(sch), receiver_t{nullptr}));
struct state-type {
  Rcvr& rcvr ; // exposition only
  variant_t async-result ; // exposition only
  operation_t op-state ; // exposition only
  explicit state-type (sched_t sch, Rcvr& rcvr) noexcept(nothrow)
    : rcvr (rcvr), op-state (connect(schedule(sch), receiver_t{this})) {}
};
return state-type {sch, rcvr};</ins></pre>
</div>
#+END_EXPORT

Modify [exec.schedule.from] p11 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>state-</ins>impls-for&lt;schedule_from_t&gt;::complete is <del>initialized with a callable object</del>
equivalent to <del>the following lambda</del>:

<pre><del>[]&lt;class Tag, class... Args&gt;(auto, auto& state, auto& rcvr, Tag, Args&&... args) noexcept
-&gt; void {
  using result_t = decayed-tuple&lt;Tag, Args...&gt;;
  constexpr bool nothrow = is_nothrow_constructible_v&lt;result_t, Tag, Args...&gt;;
  try {
    state.async-result .template emplace&lt;result_t&gt;(Tag(), std::forward&lt;Args&gt;(args)...);
  } catch (...) {
    if constexpr (!nothrow) {
      set_error(std::move(rcvr), current_exception());
      return;
    }
  }
  start(state.op-state );
}</del>
<ins>using result_t = decayed-tuple&lt;CompletionTag, Datums...&gt;;
constexpr bool nothrow = is_nothrow_constructible_v&lt;result_t, CompletionTag, Datums...&gt;;
try {
  state.async-result .template emplace&lt;result_t&gt;(CompletionTag(), std::forward&lt;Datums&gt;(datums)...);
} catch (...) {
  if constexpr (!nothrow) {
    set_error(std::move(self.get_receiver()), current_exception());
    return;
  }
}
start(get-data(self).op-state);</ins></pre>
</div>
#+END_EXPORT


** Changes to /~then~/, /~upon_error~/, /~upon_stopped~/

Modify [exec.then] p4 as follows:

#+BEGIN_EXPORT html
<div class="wording">
For then, upon_error, and upon_stopped, let <expos>set-cpo</expos> be set_value, set_error,
and set_stopped, respectively. The exposition-only class template
<del><expos>impls-for</expos></del><ins><expos>basic-operation</expos></ins> (33.9.1) is specialized for <expos>then-cpo</expos> as follows:

<pre>namespace std::execution {

<del>template&lt;&gt;
struct <expos>impls-for</expos>&lt;<expos>decayed-typeof</expos>&lt;<expos>then-cpo</expos>&gt;&gt; : <expos>default-impls</expos> {
  static constexpr auto <expos>complete</expos> =
    []&lt;class Tag, class... Args&gt;
    (auto, auto& fn, auto& rcvr, Tag, Args&&... args) noexcept -&gt; void {
      if constexpr (same_as&lt;Tag, <expos>decayed-typeof</expos>&lt;<expos>set-cpo</expos>&gt;&gt;) {
        TRY-SET-VALUE (rcvr,
          invoke(std::move(fn), std::forward&lt;Args&gt;(args)...));
      } else {
        Tag()(std::move(rcvr), std::forward&lt;Args&gt;(args)...);
      }
    };
};</del>

<ins>template &lt;class Rcvr, class Data, class Child&gt;
struct <expos>basic-operation</expos>&lt;<expos>then-cpo</expos>, Rcvr, Data, Child&gt;
  : <expos>default-state-impls</expos>
  , inlinable_operation_state&lt;<expos>basic-operation</expos>&lt;<expos>then-cpo</expos>, Rcvr, Data, Child&gt;, Rcvr&gt;
  , <expos>manual-child-operation</expos>&lt;
      <expos>basic-operation</expos>&lt;<expos>then-cpo</expos>, Rcvr, Data, Child&gt;,
      <expos>indexed-tag</expos>&lt;0&gt;,
      env_of_t&lt;Rcvr&gt;,
      Child&gt; {

  using <expos>child-op-t</expos> = <expos>manual-child-operation</expos>&lt; // <expos>exposition only</expos>
      <expos>basic_operation</expos>,
      <expos>indexed-tag</expos>&lt;0&gt;,
      env_of_t&lt;Rcvr&gt;,
      Child&gt;;

  using <expos>func-t</expos> = decay_t&lt;Data&gt;; // <expos>exposition only</expos>
  [[no_unique_address]] <expos>func-t</expos> <expos>func</expos>; // <expos>exposition only</expos>

  <expos>basic-operation</expos>(Rcvr r, Data&& data, Child&& child)
    noexcept(<expos>child-op-t</expos>::<expos>is-nothrow-connectable</expos> && is_nothrow_constructible_v&lt;decay_t&lt;Data&gt;, Data&gt;)
    : inlinable_operation_state<<expos>basic-operation</expos>, Rcvr>(std::move(r))
    , <expos>func</expos>(std::forward&lt;Data&gt;(data)) {
     <expos>child-op-t</expos>::<expos>construct</expos>(std::forward&lt;Child&gt;(child));
  }

  ~<expos>basic-operation</expos>() {
    <expos>child-op-t</expos>::_destruct();
  }

  void start() & noexcept {
    <expos>child-op-t</expos>::_start();
  }

  template &lt;class Self, size_t Id, class Tag, class... Args&gt;
  void <expos>complete</expos>(this Self& self, <expos>indexed-tag</expos>&lt;Id&gt;,
      Tag, Args&&... args) noexcept {
    if constexpr (same_as&lt;Tag, <expos>set-cpo</expos>&gt;) {
      TRY-SET-VALUE(self.get_receiver(),
        invoke(self.<expos>func</expos>, std::forward&lt;Args&gt;(args)...));
    } else {
      return Tag{}(
          std::move(self.get_receiver()), std::forward&lt;Datums&gt;(args)...);
    }
  }
};</ins>

}</pre>
</div>
#+END_EXPORT

Insert the following paragraph between [exec.then] p4 and p5:

#+BEGIN_EXPORT html
<div class="wording">
<ins>The exposition-only class template
<expos>sender-impls-for</expos> (33.9.1) is specialized for <expos>then-cpo</expos> as follows:</ins>

<pre><ins>template&lt;&gt;
struct <expos>sender-impls-for</expos>&lt;<expos>then-cpo</expos>&gt; : <expos>default-sender-impls</expos> {
  template&lt;class Sender, class Env&gt;
  using <expos>completion-signatures-of-t</expos>
    = <expos>completion-signatures-for</expos>&lt;Sender, Env&gt;;
};</ins></pre>
</div>
#+END_EXPORT


** Changes to /~let_value~/, /~let_error~/, /~let_stopped~/

Modify p5 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The exposition-only class template <del><expos>impls-for</expos></del>
<ins><expos>basic-operation</expos></ins> (33.9.1) is specialized
for <expos>let-cpo</expos> as follows:

<pre>namespace std::execution {

<del>template&lt;class State, class Rcvr, class... Args&gt;
void <expos>let-bind</expos>(State& state, Rcvr& rcvr, Args&&... args); // <expos>exposition only</expos></del>

<del>template&lt;&gt;
struct <expos>impls-for</expos>&lt;<expos>decayed-typeof</expos>&lt;<expos>let-cpo</expos>&gt;&gt; : default-impls {
  static constexpr auto <expos>get-state</expos> = see below ;
  static constexpr auto <expos>complete</expos> = see below ;
};</del>

<ins>struct <expos>predecessor-tag</expos> {}; // <expos>exposition only</expos>

template&lt;size_t Index&gt;
struct <expos>successor-tag</expos> {};  // <expos>exposition only</expos>

template&lt;class Func, class ValueSig&gt;
struct <expos>let-value-successor-for</expos>; // <expos>exposition only</expos>
template&lt;class Func, class... Vs&gt;
struct <expos>let-value-successor-for</expos>&lt;Func, set_value_t(Vs...)&gt; {
  using type = invoke_result_t&lt;Func, decay_t&lt;Vs&gt;&...&gt;;
};

template&lt;class Derived, class Env, class Func, class ValueSignatures&gt;
struct <expos>let-value-successor-child</expos>;  // <expos>exposition only</expos>
template&lt;class Derived, class Env, class Func, class... ValueSigs&gt;
struct <expos>let-value-successor-child</expos>&lt;Derived, Env, Func, completion_signatures&lt;ValueSigs...&gt;&gt;
: <expos>manual-child-operation-variant</expos>&lt;
    Derived,
    <expos>successor-tag</expos>,
    Env,
    typename <expos>let-value-successor-for</expos>&lt;Func, ValueSigs&gt;::type...&gt;
{};

template&lt;class Rcvr, class Func, class Source&gt;
struct <expos>basic-operation</expos>&lt;<expos>let-cpo</expos>, Rcvr, Func, Source&gt;
: <expos>default-state-impls</expos>
, inlinable_operation_state&lt;<expos>basic-operation</expos>&lt;<expos>let-cpo</expos>, Rcvr, Func, Source&gt;, Rcvr&gt;
, <expos>manual-child-operation</expos>&lt;
    <expos>basic-operation</expos>&lt;<expos>let-cpo</expos>, Rcvr, Func, Source&gt;,
    <expos>predecessor_tag</expos>,
    env_of_t&lt;Rcvr&gt;,
    Source&gt;
, <expos>let-value-successor-child</expos>&lt;
    <expos>basic-operation</expos>&lt;<expos>let-cpo</expos>, Rcvr, Func, Source&gt;,
    env_of_t&lt;Rcvr&gt;,
    decay_t&lt;Func&gt;,
    <expos>filter-completion-signatures-t</expos>&lt;<expos>set-cpo</expos>, completion_signatures_of_t&lt;Source, env_of_t&lt;Rcvr&gt;&gt;&gt;&gt; {

  using <expos>pred-child-t</expos> = <expos>manual-child-operation</expos>&lt; // <expos>exposition only</expos>
    <expos>basic-operation</expos>,
    <expos>predecessor-tag</expos>,
    env_of_t&lt;Rcvr&gt;,
    Source&gt;;

  using <expos>func-t</expos> = decay_t&lt;Func&gt;; // <expos>exposition only</expos>

  using <expos>succ-child-t</expos> = <expos>let-value-successor-child</expos>&lt; // <expos>exposition only</expos>
    <expos>basic-operation</expos>,
    env_of_t&lt;Rcvr&gt;,
    <expos>func-t</expos>,
    <expos>filter-completion-signatures-t</expos>&lt;<expos>set-cpo</expos>, completion_signatures_of_t&lt;Source, env_of_t&lt;Rcvr&gt;&gt;&gt;&gt;;

  using <expos>result-variant-t</expos> = // <expos>exposition only</expos>
    value_types_of_t&lt;Source, env_of_t&lt;Rcvr&gt;, <expos>decayed-tuple</expos>, <expos>variant-with-monostate</expos>&gt;;

  [[no_unique_address]] <expos>func-t</expos> <expos>func</expos>; // <expos>exposition only</expos>
  <expos>result-variant-t</expos> <expos>result</expos>; // <expos>exposition only</expos>

  <expos>basic_operation</expos>(Rcvr r, Func&& func, Source&& src)
    noexcept(<expos>pred-child-t</expos>::<expos>is-nothrow-connectable</expos> && is_nothrow_constructible_v&lt;<expos>func-t</expos>, Func&gt;)
  : inlinable_operation_state&lt;<expos>basic_operation</expos>, Rcvr&gt;(std::move(r))
  , <expos>func</expos>(std::forward&lt;Func&gt;(func)) {
    <expos>pred-child-t</expos>::<expos>construct</expos>(std::forward&lt;Source&gt;(src));
  }

  ~<expos>basic_operation</expos>();

  void start() & noexcept {
    <expos>pred-child-t</expos>::<expos>start</expos>();
  }

  template&lt;class CPO, class... Args&gt;
  void <expos>complete</expos>(<expos>predecessor-tag</expos>, CPO, Args&&... args) noexcept;

  template&lt;class CPO, size_t Index, class... Args&gt;
  void <expos>complete</expos>(<expos>successor-tag</expos>&lt;Index&gt;, CPO, Args&&... args) noexcept;
};</ins>

}</pre>
</div>
#+END_EXPORT

Remove [exec.let] p6.

Remove [exec.let] p7 and replace it with the following paragraphs:

#+BEGIN_EXPORT html
<div class="wording">

<pre>~<expos>basic_operation</expos>&lt;<expos>let-cpo</expos>&gt;()</pre>

Equivalent to:

<pre>if (<expos>result</expos>.index() != 0) {
  <expos>dispatch-index</expos>&lt;(variant_size_v&lt;<expos>result-variant-t</expos>&gt; - 1)&gt;(
    [&]&lt;size_t Index&gt;(integral_constant&lt;size_t, Index&gt;) noexcept {
      <expos>succ-child-t</expos>::template <expos>destruct</expos>&lt;Index&gt;();
    }, <expos>result</expos>.index() - 1);
  <expos>result</expos>.template emplace&lt;0&gt;();
}
<expos>pred-child-t</expos>::_destruct();</pre>

</div>
#+END_EXPORT

#+BEGIN_EXPORT html
<div class="wording">

<pre>template&lt;class CPO, class... Args&gt;
void <expos>complete</expos>(<expos>predecessor-tag</expos>, CPO, Args&&... args) noexcept</pre>

Equivalent to:

<pre>if constexpr (same_as&lt;CPO, set_value_t&gt;)  {
  using tuple_t = _decayed_tuple&lt;Args...&gt;;
  using successor_t = invoke_result_t&lt;<expos>func-t</expos>, decay_t&lt;Args&gt;&...&gt;;
  constexpr size_t successor_index = <expos>succ-child-t</expos>::template <expos>index-of</expos>&lt;successor_t&gt;();

  constexpr bool is_nothrow =
    (is_nothrow_constructible_v&lt;decay_t&lt;Args&gt;, Args&gt; && ...) &&
     <expos>succ-child-t</expos>::template <expos>is-nothrow-connectable</expos>&lt;successor_index&gt; &&
     is_nothrow_invocable_v&lt;<expos>func-t</expos>, decay_t&lt;Args&gt;&...&gt;;

  try {
    auto& t = _result.template emplace&lt;tuple_t&gt;(std::forward&lt;Args&gt;(args)...);
    std::apply([&](decay_t&lt;Args&gt;&amp... args_copy) {
      <expos>succ-child-t</expos>::template <expos>construct</expos>&lt;successor_index&gt;(
        std::invoke(std::forward&lt;<expos>func-t</expos>&gt;(<expos>func</expos>), args_copy...));
      }, t);
    <expos>succ-child-t</expos>::template <expos>start</expos>&lt;successor_index&gt;();
  } catch (...) {
    if constexpr (!is_nothrow) {
      <expos>result</expos>.template emplace&lt;0&gt;();
      execution::set_error(std::move(this-&gt;get_receiver()), std::current_exception());
    }
  }
} else {
  CPO{}(std::move(this-&gt;get_receiver()), std::forward&lt;Args&gt;(args)...);
}</pre>

</div>
#+END_EXPORT

#+BEGIN_EXPORT html
<div class="wording">

<pre>template&lt;class CPO, size_t Index, class... Args&gt;
void <expos>complete</expos>(<expos>successor-tag</expos>&lt;Index&gt;, CPO, Args&&... args) noexcept</pre>

Equivalent to:

<pre>CPO{}(std::move(this-&gt;get_receiver()), std::forward&lt;Args&gt;(args)...);</pre>

</div>
#+END_EXPORT



** Changes to /~bulk~/

Modify [exec.bulk] p3 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The exposition-only class template <del><expos>impls-for</expos></del>
<ins><expos>basic-operation</expos></ins> (33.9.1) is specialized for bulk_t as follows:

<pre>namespace std::execution {

  <del>template&lt;&gt;
  struct <expos>impls-for</expos>&lt;bulk_t&gt; : <expos>default-impls</expos> {
    static constexpr auto <expos>complete</expos> = <expos>see below</expos>;
  };</del>

<ins>template&lt;class Rcvr, class Shape, class F&gt;
struct <expos>basic-operation</expos>&lt;bulk_t, Rcvr, Shape, F&gt;
: <expos>product-type</expos>&lt;Ts...&gt;
, <expos>default-state-impls</expos>
, inlinable_operation_state&lt;<expos>basic-operation</expos>&lt;bulk_t, Rcvr, Shape, F&gt;, Rcvr&gt; {

  <expos>basic-operation</expos>(Rcvr r, Shape shape, F f)
  : inlinable_operation_state&lt;<expos>basic-operation</expos>, Rcvr&gt;(std::move(r))
  , <expos>product-type</expos>(std::move(shape), std::move(f))
  {}

  template&lt;class Self, class Tag, class CPO, class... Args&gt;
  void complete(this Self&& self, Tag, CPO, Args&&... args) noexcept;
};</ins>

}</pre>
</div>
#+END_EXPORT

Delete [exec.bulk] p4, and replace with the following:

#+BEGIN_EXPORT html
<div class="wording">
<pre>template&lt;class Self, class Tag, class CPO, class... Args&gt;
void complete(this Self&& self, Tag, CPO, Args&&... args) noexcept</pre>

Equivalent to:

<pre>if constexpr (same_as&lt;Tag, set_value_t&gt;) {
  auto& [shape, f] = self;
  constexpr bool nothrow = noexcept(f(auto(shape), args...));
  TRY-EVAL (self.get_receiver(), [&]() noexcept(nothrow) {
    for (decltype(auto(shape)) i = 0; i &lt; shape; ++i) {
      f(auto(i), args...);
    }
    Tag()(self.get_receiver(), std::forward&lt;Args&gt;(args)...);
  }());
} else {
  Tag()(self.get_receiver(), std::forward&lt;Args&gt;(args)...);
}</pre>

</div>
#+END_EXPORT

Delete [exec.bulk] p5

** Changes to /~split~/ :noexport:

Modify [exec.split] p21 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The exposition-only class template impls-for (33.9.1) is specialized for split-impl-tag as follows:

<pre>namespace std::execution {
  <del>template&lt;&gt;
  struct impls-for&lt;split-impl-tag&gt; : default-impls {
    static constexpr auto get-state = see below ;
    static constexpr auto start = see below ;
  };</del>
  <ins>template&lt;&gt;
  struct sender-impls-for&lt;split-impl-tag&gt; : default-sender-impls {
    template&lt;class Self, class Rcvr&gt;
    auto get-state(this Self&& s, Rcvr&& rcvr) noexcept;
  };
  template&lt;&gt;
  struct state-impls-for&lt;split-impl-tag&gt; : default-state-impls {
    template&lt;class Self&gt;
    constexpr void start(this Self& self) noexcept;
  };</ins>
}</pre>
</div>
#+END_EXPORT


Modify [exec.split] p22 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>sender-</ins>impls-for&lt;split-impl-tag&gt;::get-state is <del>initialized with a callable object</del> equivalent to
the following<del> lambda expression</del>:

<pre><del>[]&lt;class Sndr&gt;(Sndr&& sndr, auto& rcvr) noexcept {</del>
  return local-state {std::forward&lt;Self&gt;(self), rcvr};
<del>}</del></pre>
</div>
#+END_EXPORT


Modify [exec.split] p23 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>state-</ins>impls-for&lt;split-impl-tag&gt;::start is <del>initialized with a callable object that has a function
call operator</del> equivalent to the following:

<pre><del>template&lt;class Sndr, class Rcvr&gt;
void operator()(local-state&lt;Sndr, Rcvr&gt;&amp; state, Rcvr& rcvr) const noexcept;</del></pre>

Effects: If state.sh_state-&gt;completed is true, evaluates state.notify() and returns. Otherwise, does
the following in order:

<ul>
<li>Evaluates state.on_stop.emplace(get_stop_token(get_env(<ins>state.</ins>rcvr)),
      on-stop-request {state.sh_state ->stop_src });</li>
<li>Then atomically does the following:
<ul>
<li>Reads the value c of state.sh_state-&gt;completed , and</li>
<li>Inserts addressof(state) into state.sh_state-&gt;waiting_states if c is false.</li>
<li>If c is true, calls state.notify () and returns.</li>
<li>Otherwise, if addressof(state) is the first item added to state.sh_state-&gt;waiting_states , eval-
uates state.sh_state-&gt;start-op ().</li>
</ul>
</li>
</ul>
</div>
#+END_EXPORT


** Changes to /~when_all~/ :noexport:

Modify [exec.when.all] p4 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The exposition-only class template<ins>s</ins> <ins>sender-</ins>impls-for and <ins>state-impls-for</ins>
 (33.9.1) <del>is</del><ins>are</ins> specialized for when_all_t as follows:

<pre>namespace std::execution {
  <del>template&lt;&gt;
  struct impls-for&lt;when_all_t&gt; : default-impls {
    static constexpr auto get-attrs = see below ;
    static constexpr auto get-env = see below ;
    static constexpr auto get-state = see below ;
    static constexpr auto start = see below ;
    static constexpr auto complete = see below ;
  };</del>
  <ins>template&lt;&gt;
  struct sender-impls-for&lt;when_all_t&gt; : default-sender-impls {
    template&lt;class Data, class... Children&gt;
    static decltype(auto) get-attrs(const Data& data,
                                    const Children&... children) noexcept;
    template&lt;class Self, class Rcvr&gt;
    auto get-state(this Self&& s, Rcvr&& rcvr) noexcept;
  };

  template&lt;&gt;
  struct state-impls-for&lt;when_all_t&gt; : default-state-impls {
    template&lt;class Self, size_t Id&gt;
    constexpr decltype(auto) get-env(this Self& self, indexed-tag&lt;Id&gt;) noexcept;
    template&lt;class Self&gt;
    constexpr void start(this Self& self) noexcept ;
    template&lt;class Self, size_t Id, class CompletionTag, class... Datums&gt;
    constexpr void complete(this Self& self, indexed-tag&lt;Id&gt;,
        CompletionTag, Datums&&... datums) noexcept;
  };</ins>
}</pre>
</div>
#+END_EXPORT



Modify [exec.when.all] p5 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>sender-</ins>impls-for&lt;when_all_t&gt;::get-attrs is <del>initialized with a callable object</del> equivalent to the
following<del> lambda expression</del>:

<pre><del>[](auto&&, auto&&... child) noexcept {</del>
if constexpr (same_as&lt;CD, default_domain&gt;) {
  return env&lt;&gt;();
} else {
  return MAKE-ENV(get_domain, CD());
}
<del>}</del></pre>
</div>
#+END_EXPORT

Modify [exec.when.all] p6 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>state-</ins>impls-for&lt;when_all_t&gt;::get-env is <del>initialized with a callable object</del> equivalent to the
following<del> lambda expression</del>:

<pre><del>[]<class State, class Rcvr>(auto&&, State& state, const Receiver& rcvr) noexcept {</del>
<ins>auto& [_, state, children...] = self;</ins>
return see below ;
<del>}</del></pre>

Returns an object e such that

<ul>
<li>decltype(e) models queryable , and</li>
<li>e.query(get_stop_token) is expression-equivalent to state.stop-src .get_token(), and</li>
<li>given a query object q with type other than cv stop_token_t, e.query(q) is expression-equivalent to
get_env(<del>rcvr</del><ins>self.get_receiver()</ins>).query(q).</li>
</ul>
</div>
#+END_EXPORT



Modify [exec.when.all] p7 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>sender-</ins>impls-for&lt;when_all_t&gt;::get-state is <del>initialized with a callable object</del> equivalent to the
following<del> lambda expression</del>:

<pre><del>[]<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept(e) -> decltype(e) {</del>
  return e;
<del>}</del></pre>

where e is the expression

<pre>std::forward&lt;<del>Sndr</del><ins>Self</ins>&gt;(<del>sndr</del><ins>self</ins>).apply(make-state&lt;Rcvr&gt;())</pre>

and where make-state is the following exposition-only class template:

<pre>template&lt;class Sndr, class Env&gt;
concept max-1-sender-in = sender_in&lt;Sndr, Env&gt; && // exposition only
  (tuple_size_v&lt;value_types_of_t&lt;Sndr, Env, tuple, tuple&gt;&gt; &lt;= 1);

enum class disposition { started , error , stopped }; // exposition only

template&lt;class Rcvr&gt;
struct make-state {
  template&lt;max-1-sender-in &lt;env_of_t&lt;Rcvr&gt;&gt;... Sndrs&gt;
  auto operator()(auto, auto, Sndrs&&... sndrs) const {
    using values_tuple = see below ;
    using errors_variant = see below ;
    using stop_callback = stop_callback_for_t&lt;stop_token_of_t&lt;env_of_t&lt;Rcvr&gt;&gt;, on-stop-request&gt;;
    struct state-type {
      void arrive (Rcvr& rcvr) noexcept { // exposition only
        if (0 == --count) {
          complete (rcvr);
        }
      }
      void complete (Rcvr& rcvr) noexcept; // exposition only
      atomic&lt;size_t&gt; count {sizeof...(sndrs)}; // exposition only
      inplace_stop_source stop_src {}; // exposition only
      atomic&lt;disposition&gt; disp{disposition::started}; // exposition only
      errors_variant errors {}; // exposition only
      values_tuple values {}; // exposition only
      optional&lt;stop_callback&gt; on_stop {nullopt}; // exposition only
    };
    return state-type {};
  }
};</pre>
</div>
#+END_EXPORT



Modify [exec.when.all] p12 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>state-</ins>impls-for&lt;when_all_t&gt;::start is <del>initialized with a callable object</del> equivalent to the following
<del>lambda expression</del>:

<pre><del>[]&lt;class State, class Rcvr, class... Ops&gt;(
  State& state, Rcvr& rcvr, Ops&... ops) noexcept -&gt; void {</del>
<ins>auto& [_, state, child...] = self;</ins>
state.on_stop.emplace(
  get_stop_token(get_env(<del>rcvr</del><ins>self.get_receiver()</ins>)),
  on-stop-request{state.stop_src});
if (state.stop_src.stop_requested()) {
  state.on_stop.reset();
  set_stopped(<del>std::move(rcvr)</del><ins>self.get_receiver()</ins>);
} else {
  (start(child), ...);
}
<del>}</del></pre>
</div>
#+END_EXPORT


Modify [exec.when.all] p13 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>state-</ins>impls-for&lt;when_all_t&gt;::complete is <del>initialized with a callable object</del> equivalent to the
following<del> lambda expression</del>:

<pre><del>[]&lt;class Index, class State, class Rcvr, class Set, class... Args&gt;(
    this auto& complete, Index, State& state, Rcvr& rcvr, Set, Args&&... args) noexcept -&gt; void {</del>
  <ins>auto& [_, state, child...] = self;</ins>
  if constexpr (same_as&lt;<del>Set</del><ins>CompletionTag</ins>, set_error_t&gt;) {
    if (disposition::error != state.disp.exchange(disposition ::error)) {
      state.stop_src.request_stop();
      TRY-EMPLACE-ERROR(state.errors, std::forward&lt;<del>Args</del><ins>Datums</ins>&gt;(<del>args</del><ins>datums</ins>)...);
    }
  } else if constexpr (same_as&lt;<del>Set</del><ins>CompletionTag</ins>, set_stopped_t&gt;) {
    auto expected = disposition::started;
    if (state.disp.compare_exchange_strong(expected, disposition::stopped )) {
      state.stop_src.request_stop();
    }
  } else if constexpr (!same_as&lt;decltype(<del>State::values</del><ins>state.values</ins>), tuple&lt;&gt;&gt;) {
    if (state.disp == disposition::started ) {
      auto& opt = get&lt;Id&gt;(state.values);
      TRY-EMPLACE-VALUE (complete, opt, std::forward&lt;<del>Args</del><ins>Datums</ins>&gt;(<del>args</del><ins>datums</ins>)...);
    }
  }
  state.arrive (<del>rcvr</del><ins>self.get_receiver()</ins>);
<del>}</del></pre>

where TRY-EMPLACE-ERROR (v, e), for subexpressions v and e, is equivalent to:

<pre>try {
  v.template emplace&lt;decltype(auto(e))&gt;(e);
} catch (...) {
  v.template emplace&lt;exception_ptr&gt;(current_exception());
}</pre>

if the expression decltype(auto(e))(e) is potentially throwing; otherwise,
v.template emplace&lt;decltype(auto(e))&gt;(e); and where TRY-EMPLACE-VALUE (c, o, as...),
for subexpressions c, o, and pack of subexpressions as, is equivalent to:

<pre>try {
  o.emplace(as...);
} catch (...) {
  c(Index(), state, <del>rcvr</del><ins>self.get_receiver()</ins>, set_error, current_exception());
  return;
}</pre>

if the expression decayed-tuple&lt;decltype(as)...&gt;{as...} is potentially throwing; otherwise,
o.emplace(as...).
</div>
#+END_EXPORT


** Changes to /~into_variant~/ :noexport:

Modify [exec.into.variant] p4 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The exposition-only class template<ins>s</ins> <ins>state-</ins>impls-for <ins>and sender-impls-for</ins> (33.9.1) is specialized for into_variant as follows:

<pre>namespace std::execution {
  <del>template<>
  struct impls-for <into_variant_t> : default-impls {
    static constexpr auto get-state = see below ;
    static constexpr auto complete = see below ;
  };</del>
  <ins>template&lt;&gt;
  struct state-impls-for&lt;into_variant_t&gt; : default-state-impls {
    template&lt;class Self, size_t Id, class CompletionTag, class... Datums&gt;
      constexpr void complete(this Self& self, indexed-tag&lt;Id&gt;,
        CompletionTag, Datums&&... datums) noexcept;
  };
  <ins>template&lt;&gt;
  struct sender-impls-for&lt;into_variant_t&gt; : default-sender-impls {
    template&lt;class Self, class Recr&gt;
    auto get-state(this Self&& self, Rcvr& rcvr) // exposition only
      requires see-below;
  };</ins>
}</pre>
</div>
#+END_EXPORT

Modify [exec.into.variant] p5 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>sender-</ins>impls-for&lt;into_variant_t&gt;::get-state is <del>initialized with a callable object</del> equivalent to
<del>the following lambda</del>:</del>

<pre><del>[]&lt;class Sndr, class Rcvr&gt;(Sndr&& sndr, Rcvr& rcvr) noexcept
  -&gt; type_identity&lt;value_types_of_t&lt;child-type&lt;Sndr&gt;, env_of_t&lt;Rcvr&gt;&gt;&gt; {
  return {};
}</del>
<ins>return type_identity&lt;value_types_of_t&lt;child-type&lt;Self&gt;, env_of_t&lt;Rcvr&gt;&gt;&gt{};</ins></pre>
</div>
#+END_EXPORT

Modify [exec.into.variant] p6 as follows:

#+BEGIN_EXPORT html
<div class="wording">
The member <ins>state-</ins>impls-for&lt;into_variant_t&gt;::complete is <del>initialized with a callable object</del> equivalent to<del> the
following lambda</del>:

<pre><del>[]&lt;class State, class Rcvr, class Tag, class... Args&gt;(
    auto, State, Rcvr& rcvr, Tag, Args&&... args) noexcept -&gt; void {
  if constexpr (same_as&lt;Tag, set_value_t&gt;) {
    using variant_type = typename State::type;
    TRY-SET-VALUE (rcvr, variant_type(decayed-tuple&lt;Args...&gt;{std::forward&lt;Args&gt;(args)...}));
  } else {
    Tag()(std::move(rcvr), std::forward&lt;Args&gt;(args)...);
  }
}</del>
<ins>if constexpr (same_as&lt;CompletionTag, set_value_t&gt;) {
    using variant_type = value_types_of&lt;child-type&lt;Self&gt;, env_of_t&lt;decltype(auto(self.get_receiver()))&gt;&gt;;
    TRY-SET-VALUE(self.get_receiver(), variant_type(decayed-tuple&lt;Args...&gt;{std::forward&lt;Args&gt;(args)...}));
  } else {
    Tag()(std::move(self.get_receiver()), std::forward&lt;Args&gt;(args)...);
  }
}</ins></pre>
</div>
#+END_EXPORT


** Changes to /~run_loop::run-loop-opstate~/ :noexport:

Modify [exec.run.loop.types] by inserting a new paragraph after paragraph 9:

#+BEGIN_EXPORT html
<div class="wording">
<ins>If Rcvr models inlinable_receiver&lt;<expos>run-loop-opstate</expos>&lt;Rcvr&gt;&gt;,
then objects of type <expos>run-loop-opstate</expos>&lt;Rcvr&gt; do not contain
subobjects of type Rcvr.</ins>
</div>
#+END_EXPORT





* Proposed Wording :noexport:

Modify [exec.snd.expos] p24 follows:

#+BEGIN_EXPORT html
<pre>
  ...
  template&lt;class Sndr>
  using <expos>indices-for</expos> = remove_reference_t&lt;Sndr>::<expos>indices-for</expos>;           // <expos>exposition only</expos>

  <ins>template&lt;class Op, class Rcvr>
  struct <expos>receiver-holder</expos> {                                       // <expos>exposition only</expos>
    <expos>receiver-holder</expos>(Rcvr&& rcvr2) noexcept(is_nothrow_move_constructible_v&lt;Rcvr>)
    : <expos>rcvr</expos>(std::forward&lt;Rcvr>(rcvr2)) { }

    Rcvr& <expos>get-receiver</expos>() noexcept { return <expos>rcvr</expos>; }               // <expos>exposition only</expos>

    Rcvr <expos>rcvr</expos>;                                                   // <expos>exposition only</expos>
  };

  template&lt;class Op, class Rcvr>
    requires inlinable_receiver&lt;Rcvr, Op>
  struct <expos>receiver-holder</expos>&lt;Op, Rcvr> {
    <expos>receiver-holder</expos>(Rcvr&&) noexcept {}

    Rcvr <expos>get-receiver</expos>() noexcept {                              // <expos>exposition only</expos>
      return Rcvr::make_receiver_for(static_cast&lt;Op*>(this));
    }
  };

  template&lt;class Sndr, class Rcvr>
  struct <expos>basic-operation</expos>;
  </ins>
  template&lt;class Sndr, class Rcvr>
  struct <expos>basic-state</expos><del> {</del>                                          // <expos>exposition only</expos>
    <ins>: <expos>receiver-holder</expos>&lt;<expos>basic-operation</expos>&lt;Sndr, Rcvr>, Rcvr> {</ins>
    <expos>basic-state</expos>(Sndr&& sndr, Rcvr&& rcvr) noexcept(<expos>see below</expos>)
      : <del><expos>rcvr</expos></del><ins><expos>receiver-holder</expos>&lt;<expos>basic-operation</expos>&lt;Sndr, Rcvr>></ins>(std::move(rcvr))
      , <expos>state</expos>(<ins>[&amp;] {
          decltype(auto) rcvr2 =
          <expos>impls-for</expos>&lt;tag_of_t&lt;Sndr>>::<expos>get-state</expos>(std::forward&lt;Sndr>(sndr), <expos>rcvr</expos>)) { }

  <del>  Rcvr <expos>rcvr</expos>;                                                  // <expos>exposition only</expos></del>
    <expos>state-type</expos>&lt;Sndr, Rcvr> <expos>state</expos>;                               // <expos>exposition only</expos>
  };

  template&lt;class Sndr, class Rcvr, class Index>
    requires <expos>valid-specialization</expos>&lt;<expos>env-type</expos>, Index, Sndr, Rcvr>
  struct <expos>basic-receiver</expos> {                                       // <expos>exposition only</expos>
    using receiver_concept = receiver_t;

    using <expos>tag-t</expos> = tag_of_t&lt;Sndr>;                               // <expos>exposition only</expos>
    using <expos>state-t</expos> = <expos>state-type</expos>&lt;Sndr, Rcvr>;                     // <expos>exposition only</expos>
    static constexpr const auto& <expos>complete</expos> = <expos>impls-for</expos>&lt;tag-t>::<expos>complete</expos>;   // exposition only

    template&lt;class... Args>
      requires <expos>callable</expos>&lt;decltype(<expos>complete</expos>), Index, <expos>state-t</expos>&, Rcvr&, set_value_t, Args...>
    void set_value(Args&&... args) && noexcept {
      <ins>decltype(auto) rcvr = <expos>op</expos>-><expos>get-receiver</expos>();</ins>
      <expos>complete</expos>(Index(), <expos>op</expos>-&gt;<expos>state</expos>, <del><expos>op</expos>-><expos>rcvr</expos></del><ins>rcvr</ins>, set_value_t(), std::forward&lt;Args>(args)...);
    }

    template&lt;class Error>
      requires <expos>callable</expos>&lt;decltype(<expos>complete</expos>), Index, <expos>state-t</expos>&, Rcvr&, set_error_t, Error>
    void set_error(Error&& err) && noexcept {
      <ins>decltype(auto) rcvr = <expos>op</expos>-><expos>get-receiver</exposo>();</ins>
      <expos>complete</expos>(Index(), <expos>op</expos>-><expos>state</expos>, <del><expos>op</expos>-><expos>rcvr</expos></del><ins>rcvr</ins>, set_error_t(), std::forward&lt;Error>(err));
    }

    void set_stopped() && noexcept
      requires <expos>callable</expos>&lt;decltype(<expos>complete</expos>), Index, <expos>state-t</expos>&amp;, Rcvr&amp;, set_stopped_t> {
      <ins>decltype(auto) rcvr = <expos>op</expos>-><expos>get-receiver</exposo>();</ins>
      <expos>complete</expos>(Index(), <expos>op</expos>-><expos>state</expos>, <del><expos>op</expos>-><expos>rcvr</expos></del><ins>rcvr</ins>, set_stopped_t());
    }

    auto get_env() const noexcept -> <expos>env-type</expos>&lt;Index, Sndr, Rcvr> {
      <ins>decltype(auto) rcvr = <expos>op</expos>-><expos>get-receiver</exposo>();</ins>
      return <expos>impls-for</expos>&lt;<expos>tag-t</expos>>::<expos>get-env</expos>(Index(), <expos>op</expos>-><expos>state</expos>, <del><expos>op</expos>-><expos>rcvr</expos></del><ins>rcvr</ins>);
    }

    <expos>basic-state</expos>&lt;Sndr, Rcvr>* <expos>op</expos>;                           // <expos>exposition only</expos>
  };

</pre>
#+END_EXPORT


#+begin_src
  namespace std::execution {
    template<class Tag>
    concept completion-tag =                                      // exposition only
      same_as<Tag, set_value_t> || same_as<Tag, set_error_t> || same_as<Tag, set_stopped_t>;

    template<template<class...> class T, class... Args>
    concept valid-specialization =                                // exposition only
      requires { typename T<Args...>; };

    template<size_t Id>
    using indexed-tag = integral_constant<size_t, Id>; // exposition only

    struct default-state-impls { // exposition only
      template<class ParentEnv, std::size_t Id>
      using child-env-type = ParentEnv; // exposition only

      template<class Self, std::size_t Id>
      decltype(auto) get-env(this Self& self, indexed-tag<Id>) noexcept { //exposition only
        return execution::get_env(self.get-receiver());
      }

      template<class Self>
      void start(this Self& self) noexcept { // exposition only
        self.start-all();
      }

      template<class Self, std::size_t Id, class CompletionTag, class... Datums>
      void complete(this Self& self, indexed-tag<Id>, CompletionTag, Datums&&... Datums) noexcept { // exposition only
        return CompletionTag{}(std::move(self.get_receiver()), std::forward<Datums>(datums)...);
      }
    };

    template<class Tag>
    struct state-impls-for : default-state-impls {};      // exposition only

    template<class Tag, class Data>
    struct default-state : state-impls-for<Tag> {         // exposition only
      Data data; // exposition only
    };

    template<class Sndr>
    decltype(auto) get-data(Sndr&& sndr) noexcept { // exposition only
      auto&& [tag, data, ...children] = std::forward<Sndr>(sndr);
      return std::forward_like<Sndr>(data);
    }

    template<class Sndr>
    using data-type-t = decltype(get-data(std::declval<Sndr>())); // exposition-only

    template<class T>
    inline constexpr bool is-nothrow-decay-copyable-v = // exposition-only
      is_nothrow_constructible_v<decay_t<T>, T>;

    template<class Sndr, class Rcvr>
    inline constexpr bool is-nothrow-connectable-v = // exposition-only
      noexcept(execution::connect(std::declval<Sndr>(), std::declval<Rcvr>()));

    struct default-sender-impls {                                 // exposition only

      template<class Self>
      static decltype(auto) <expos>get-attrs(this const Self& self) noexcept { // exposition-only
        auto& [tag, data, ...children] = self;
        if constexpr (sizeof...(children) == 1) {
          return fwd-env(execution::get_env(children...[0]));
        } else {
          return empty_env{};
        }
      }

      template<class Self>
      default-state<tag_of_t<Self>, decay_t<data-type-t<Self>>> get-state(this Self&& self) // exposition-only
          noexcept(is-nothrow-decay-copyable-v<data-type-t<Self>>) {
        return {{}, get-data(std::forward<Self>(self))};
      }
    };

    template<class Tag>
    struct sender-impls-for : default-sender-impls {}; // exposition only

    template<class Op, class Rcvr>
    struct inlinable-operation-state {  // exposition only
      explicit inlinable-operation-state(Rcvr&& r) noexcept(is_nothrow_move_constructible_v<Rcvr>)
        : rcvr(std::move(r))
      {}

      Rcvr& get-receiver() noexcept { return rcvr; } // exposition only

      Rcvr rcvr; // exposition-only
    };

    template<class Op, class Rcvr>
      requires inlinable_receiver<Rcvr, Op>
    struct inlinable-operation-state<Op, Rcvr> { // exposition only
      explicit inlinable-operation-state(Rcvr&&) noexcept {}

      Rcvr get-receiver() noexcept { // exposition only
        return Rcvr::make_receiver_for(static_cast<Op*>(this));
      }
    };

    template<class ParentOp, class ChildTag, class ChildEnv, class ChildSndr>
    class manual-child-operation { // exposition-only
      struct child-receiver { // exposition-only
        using receiver_concept = receiver_t;

        template<class ChildOp>
        static child-receiver make_receiver_for(ChildOp* child) noexcept {
          auto* parent = static_cast<ParentOp*>(
                           reinterpret_cast<manual-child-operation*>(
                             reinterpret_cast<storage-t*>(child)));
          return child-receiver{parent};
        }

        Env get_env() const noexcept {
          return parent->get-env(ChildTag{});
        }

        template<class... Vs>
        void set_value(Vs&&... vs) noexcept {
          parent->complete(ChildTag{}, set_value_t{}, std::forward<Vs>(vs)...);
        }

        template<class E>
        void set_error(E&& e) noexcept {
          parent->complete(ChildTag{}, set_error_t{}, std::forward<E>(e));
        }

        void set_stopped() noexcept {
          parent->complete(ChildTag{}, set_stopped_t{});
        }

      private:
        child-receiver(ParentOp* p) noexcept : parent(p) {}

        ParentOp* parent; // exposition-only
      };

      using child-op = connect_result_t<ChildSndr, child-receiver>;

    protected:
      static constexpr bool is-nothrow-connectable = is-nothrow-connectable-v<ChildSndr, child-receiver>;

      manual-child-operation() noexcept {}
      ~manual-child-operation() {}

      void start() noexcept { // exposition-only
        execution::start(get());
      }

      void construct(ChildSndr&& child) noexcept(is-nothrow-connectable) {   // exposition-only
        ::new (static_cast<void*>(addressof(storage))) child-op(
          execution::connect(std::forward<ChildSndr>(child), child-receiver{static_cast<ParentOp*>(this)}));
      }

      void destruct() noexcept { // exposition-only
        get().~child-op();
      }

    private:
      child-op& get() noexcept {
        return *launder(reinterpret_cast<child-op*>(addressof(storage)));
      }

      using storage-t = conditional_t<
        is_empty_v<child-op> && is_standard_layout_v<child-op>,
        child-op,
        unsigned char[sizeof(child-op)]>; //exposition-only

      union {
        [[no_unique_address]] storage_t storage; // exposition-only
      };
    };

    template<class ParentOp, class ChildTag, class ChildEnv, class ChildSndr>
    class child-operation : public manual-child-operation<ParentOp, ChildTag, Env, Child> {
      using base-t = manual-child-operation<ParentOp, ChildTag, Env, Child>;
      using base-t::construct;
      using base-t::destruct;

    protected:
      child-operation(Child&& child) noexcept(base-t::is-nothrow-connectable) {
        base-t::construct(std::forward<Child>(child));
      }

      ~child-operation() {
        base-t::destruct();
      }
    };

    template<
      class ParentOp,
      class ParentEnv,
      template<class, size_t> class ChildEnv,
      class Indices,
      class... Children>
    class child-operations; // exposition-only

    template<
      class ParentOp,
      class ParentEnv,
      template<class, size_t> class ChildEnv,
      size_t... Indices,
      class... Children>
    class child-operations<ParentOp, ParentEnv, ChildEnv, index_sequence<Indices...>, Children...>
      : public child-operation<ParentOp, indexed-tag<Ids>, ChildEnv<ParentEnv, Ids>, Children>... {
    protected:
      template<size_t Id>
        using child-t = child-operation<ParentOp, indexed-tag<Id>, ChildEnv<ParentEnv, Id>, Children...[Id]>;

      explicit child-operations(Children&&... children)
        : child-t<Indices>(std::forward<Children>(children))...
      {}

      void start-all() noexcept {
        (child_t<Ids>::start(), ...);
      }
    };

    template<class Tag, class Rcvr, class State, class... Children>
    struct basic-operation  // exposition-only
      : inlinable-operation-state<basic-operation<Tag, Rcvr, State, Children...>, Rcvr>
      , State
      , child-operations<
          basic-operation<Tag, Rcvr, State, Children...>,
          env_of_t<Rcvr>,
          State::template env-type,
          index_sequence_for<Children...>,
          Children...> {
      using rcvr-base = inlinable-operation-state<basic-operation, Rcvr; // exposition-only
      using children-base = child-operations<
        basic-operation,
        env_of_t<Rcvr>,
        State::template env-type,
        index_sequence_for<Children...>,
        Children...>; // exposition-only

      template<class Data>
      basic-operation(Rcvr rcvr, Data&& data, Children&&... children)
        : rcvr-base(std::move(rcvr))
        , State(std::forward<Data>(data))
        , children-base(std::forward<Children>(children)...)
      {}

      void start() &  noexcept {
        this->State::start();
      }
    };

    template<class Sndr, class Env>
    using completion-signatures-for = see below;                   // exposition only

    template<class Tag, class Data, class... Child>
    struct basic-sender : product-type<Tag, Data, Child...> {    // exposition only
      using sender_concept = sender_t;
      using indices-for = index_sequence_for<Child...>;       // exposition only

      decltype(auto) get_env() const noexcept {
        auto& [_, data, ...child] = *this;
        return sender-impls-for<Tag>::get-attrs(data, child...);
      }

      template<decays-to<basic-sender> Self, receiver Rcvr>
      auto connect(this Self&& self, Rcvr rcvr) noexcept(see below)
        -> basic-operation<Self, Rcvr> {
        return {std::forward<Self>(self), std::move(rcvr)};
      }

      template<decays-to<basic-sender> Self, class Env>
      auto get_completion_signatures(this Self&& self, Env&& env) noexcept
        -> completion-signatures-for<Self, Env> {
        return {};
      }
    };
  }
#+end_src


* References

- https://github.com/cplusplus/sender-receiver/issues/224
  Original github issue describing the problem and suggested solution described
  by this paper.

* NOTES :noexport:

- https://godbolt.org/z/7xT4v9Yzc
  Experimental implementation of std wording with this optimisation applied.
  NOTE: Compiles, but something is inhibiting the optimisation.
